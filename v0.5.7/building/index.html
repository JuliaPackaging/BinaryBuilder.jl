<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Building Packages · BinaryBuilder.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BinaryBuilder.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Building Packages</a><ul class="internal"><li><a class="tocitem" href="#Name"><span>Name</span></a></li><li><a class="tocitem" href="#Version-number"><span>Version number</span></a></li><li><a class="tocitem" href="#Sources"><span>Sources</span></a></li><li><a class="tocitem" href="#Build-script"><span>Build script</span></a></li><li><a class="tocitem" href="#Platforms"><span>Platforms</span></a></li><li><a class="tocitem" href="#Products"><span>Products</span></a></li><li><a class="tocitem" href="#Binary-dependencies"><span>Binary dependencies</span></a></li><li class="toplevel"><a class="tocitem" href="#Building-and-testing-JLL-packages-locally"><span>Building and testing JLL packages locally</span></a></li><li><a class="tocitem" href="#Overriding-a-prebuilt-JLL-package&#39;s-binaries"><span>Overriding a prebuilt JLL package&#39;s binaries</span></a></li><li><a class="tocitem" href="#Building-a-custom-JLL-package-locally"><span>Building a custom JLL package locally</span></a></li><li><a class="tocitem" href="#Deploying-local-builds-without-recreating-the-tarballs"><span>Deploying local builds without recreating the tarballs</span></a></li></ul></li><li><a class="tocitem" href="../build_tips/">Build Tips</a></li><li><a class="tocitem" href="../jll/">JLL packages</a></li><li><a class="tocitem" href="../FAQ/">FAQ</a></li><li><a class="tocitem" href="../troubleshooting/">Build Troubleshooting</a></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../rootfs/">RootFS</a></li><li><a class="tocitem" href="../environment_variables/">Environment Variables</a></li><li><a class="tocitem" href="../tricksy_gotchas/">Tricksy Gotchas</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Building Packages</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Building Packages</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/master/docs/src/building.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Building-Packages"><a class="docs-heading-anchor" href="#Building-Packages">Building Packages</a><a id="Building-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Building-Packages" title="Permalink"></a></h1><p>A <code>BinaryBuilder.jl</code> build script (what is often referred to as a <code>build_tarballs.jl</code> file) looks something like this:</p><pre><code class="language-julia hljs">using BinaryBuilder

name = &quot;libfoo&quot;
version = v&quot;1.0.1&quot;
sources = [
    ArchiveSource(&quot;&lt;url to source tarball&gt;&quot;, &quot;sha256 hash&quot;),
]

script = raw&quot;&quot;&quot;
cd ${WORKSPACE}/srcdir/libfoo-*
make -j${nproc}
make install
&quot;&quot;&quot;

platforms = supported_platforms()

products = [
    LibraryProduct(&quot;libfoo&quot;, :libfoo),
    ExecutableProduct(&quot;fooifier&quot;, :fooifier),
]

dependencies = [
    Dependency(&quot;Zlib_jll&quot;),
]

build_tarballs(ARGS, name, version, sources, script, platforms, products, dependencies)</code></pre><p>The <a href="../reference/#BinaryBuilder.build_tarballs"><code>build_tarballs</code></a> function takes in the variables defined above and runs the builds, placing output tarballs into the <code>./products</code> directory, and optionally generating and publishing the <a href="../jll/">JLL package</a>.  Let&#39;s see in more details what are the ingredients of the builder.</p><h2 id="Name"><a class="docs-heading-anchor" href="#Name">Name</a><a id="Name-1"></a><a class="docs-heading-anchor-permalink" href="#Name" title="Permalink"></a></h2><p>This is the name that will be used in the tarballs and for the JLL package.  It should be the name of the upstream package, not for example that of a specific library or executable provided by it, even though they may coincide.  The case of the name should match that of the upstream package.  Note that the name should be a valid Julia identifier, so it has meet some requirements, among which:</p><ul><li>it cannot start with a number,</li><li>it cannot have spaces, dashes, or dots in the name.  You can use underscores to replace them.</li></ul><p>If you are unsure, you can use <code>Base.isidentifer</code> to check whehter the name is acceptable:</p><pre><code class="language-julia hljs">julia&gt; Base.isidentifier(&quot;valid_package_name&quot;)
true

julia&gt; Base.isidentifier(&quot;100-invalid package.name&quot;)
false</code></pre><p>Note that <code>_jll</code> will be automatically appended to the name of the generated JLL package.</p><h2 id="Version-number"><a class="docs-heading-anchor" href="#Version-number">Version number</a><a id="Version-number-1"></a><a class="docs-heading-anchor-permalink" href="#Version-number" title="Permalink"></a></h2><p>This is the version number used in tarballs and should coincide with the version of the upstream package.  However, note that this should only contain major, minor and patch numbers, so</p><pre><code class="language-julia hljs">julia&gt; v&quot;1.2.3&quot;
v&quot;1.2.3&quot;</code></pre><p>is acceptable, but</p><pre><code class="language-julia hljs">julia&gt; v&quot;1.2.3-alpha&quot;
v&quot;1.2.3-alpha&quot;

julia&gt; v&quot;1.2.3+3&quot;
v&quot;1.2.3+3&quot;</code></pre><p>or a version including more than three levels (e.g., <code>1.2.3.4</code>) are not. Truncate the version to the patch number if necessary.</p><p>The generated JLL package will automatically add a build number, increasing it for each rebuild of the same package version.</p><h2 id="Sources"><a class="docs-heading-anchor" href="#Sources">Sources</a><a id="Sources-1"></a><a class="docs-heading-anchor-permalink" href="#Sources" title="Permalink"></a></h2><p>The sources are what will be compiled with the build script.  They will be placed under <code>${WORKSPACE}/srcdir</code> inside the build environment.  Sources can be of the following types:</p><ul><li><a href="../reference/#BinaryBuilderBase.ArchiveSource"><code>ArchiveSource</code></a>: a compressed archive (e.g., <code>tar.gz</code>, <code>tar.bz2</code>, <code>tar.xz</code>, <code>zip</code>) that will be downloaded and automatically uncompressed;</li><li><a href="../reference/#BinaryBuilderBase.GitSource"><code>GitSource</code></a>: a git repository that will be automatically cloned.  The specified revision will be checked out;</li><li><a href="../reference/#BinaryBuilderBase.FileSource"><code>FileSource</code></a>: a generic file that will be downloaded from the Internet, without special treatment;</li><li><a href="../reference/#BinaryBuilderBase.DirectorySource"><code>DirectorySource</code></a>: a local directory whose content will be copied in <code>${WORKSPACE}/srcdir</code>.  This usually contains local patches used to non-interactively edit files in the source code of the package you want to build.</li></ul><p>Example of packages with multiple sources of different types:</p><ul><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/62d44097a26fe338763da8263b36ce6a63e7fa9c/L/libftd2xx/build_tarballs.jl#L9-L29"><code>libftd2xx</code></a>.</li></ul><p>Sources are not to be confused with the <a href="#Binary-dependencies-1">binary dependencies</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Each builder should build a single package: don&#39;t use multiple sources to bundle multiple packages into a single recipe.  Instead, build each package separately, and use them as binary dependencies as appropriate.  This will increase reusability of packages.</p></div></div><h2 id="Build-script"><a class="docs-heading-anchor" href="#Build-script">Build script</a><a id="Build-script-1"></a><a class="docs-heading-anchor-permalink" href="#Build-script" title="Permalink"></a></h2><p>The script is a bash script executed within the build environment, which is a <code>x86_64</code> Linux environment using the Musl C library, based on Alpine Linux (triplet: <code>x86_64-linux-musl</code>).  The section <a href="../build_tips/">Build Tips</a> provides more details about what you can usually do inside the build script.</p><h2 id="Platforms"><a class="docs-heading-anchor" href="#Platforms">Platforms</a><a id="Platforms-1"></a><a class="docs-heading-anchor-permalink" href="#Platforms" title="Permalink"></a></h2><p>The builder should also specify the list of platforms for which you want to build the package.  At the time of writing, we support Linux (<code>x86_64</code>, <code>i686</code>, <code>armv6l</code>, <code>armv7l</code>, <code>aarch64</code>, <code>ppc64le</code>), Windows (<code>x86_64</code>, <code>i686</code>), macOS (<code>x86_64</code>, <code>aarch64</code>) and FreeBSD (<code>x86_64</code>).  When possible, we try to build for all supported platforms, in which case you can set</p><pre><code class="language-julia hljs">platforms = supported_platforms()</code></pre><p>You can get the list of the supported platforms and their associated <em>triplets</em> by using the functions <code>supported_platforms</code> and <code>triplet</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using BinaryBuilder</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; supported_platforms()</code><code class="nohighlight hljs ansi" style="display:block;">16-element Vector{Platform}:
 Linux i686 {libc=glibc}
 Linux x86_64 {libc=glibc}
 Linux aarch64 {libc=glibc}
 Linux armv6l {call_abi=eabihf, libc=glibc}
 Linux armv7l {call_abi=eabihf, libc=glibc}
 Linux powerpc64le {libc=glibc}
 Linux i686 {libc=musl}
 Linux x86_64 {libc=musl}
 Linux aarch64 {libc=musl}
 Linux armv6l {call_abi=eabihf, libc=musl}
 Linux armv7l {call_abi=eabihf, libc=musl}
 macOS x86_64
 macOS aarch64
 FreeBSD x86_64
 Windows i686
 Windows x86_64</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; triplet.(supported_platforms())</code><code class="nohighlight hljs ansi" style="display:block;">16-element Vector{String}:
 &quot;i686-linux-gnu&quot;
 &quot;x86_64-linux-gnu&quot;
 &quot;aarch64-linux-gnu&quot;
 &quot;armv6l-linux-gnueabihf&quot;
 &quot;armv7l-linux-gnueabihf&quot;
 &quot;powerpc64le-linux-gnu&quot;
 &quot;i686-linux-musl&quot;
 &quot;x86_64-linux-musl&quot;
 &quot;aarch64-linux-musl&quot;
 &quot;armv6l-linux-musleabihf&quot;
 &quot;armv7l-linux-musleabihf&quot;
 &quot;x86_64-apple-darwin&quot;
 &quot;aarch64-apple-darwin&quot;
 &quot;x86_64-unknown-freebsd&quot;
 &quot;i686-w64-mingw32&quot;
 &quot;x86_64-w64-mingw32&quot;</code></pre><p>The triplet of the platform is used in the name of the tarball generated.</p><p>For some packages, (cross-)compilation may not be possible for all those platforms, or you have interested in building the package only for a subset of them.  Examples of packages built only for some platforms are</p><ul><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/eb3728a2303c98519338fe0be370ef299b807e19/L/libevent/build_tarballs.jl#L24-L36"><code>libevent</code></a>;</li><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/eb3728a2303c98519338fe0be370ef299b807e19/X/Xorg_libX11/build_tarballs.jl#L29"><code>Xorg_libX11</code></a>: this is built only for Linux and FreeBSD systems, automatically filtered from <code>supported_platforms</code>, instead of listing the platforms explicitly.</li></ul><h3 id="Expanding-C-string-ABIs-or-libgfortran-versions"><a class="docs-heading-anchor" href="#Expanding-C-string-ABIs-or-libgfortran-versions">Expanding C++ string ABIs or libgfortran versions</a><a id="Expanding-C-string-ABIs-or-libgfortran-versions-1"></a><a class="docs-heading-anchor-permalink" href="#Expanding-C-string-ABIs-or-libgfortran-versions" title="Permalink"></a></h3><p>Building libraries is not a trivial task and entails a lot of compatibility issues, some of which are detailed in <a href="../tricksy_gotchas/">Tricksy Gotchas</a>.</p><p>You should be aware of two incompatibilities in particular:</p><ul><li><p>The standard C++ library that comes with GCC can have one of <a href="https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html">two incompatible ABIs</a> for <code>std::string</code>, an old one usually referred to as C++03 string ABI, and a newer one conforming to the 2011 C++ standard.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This ABI does <em>not</em> have to do with the C++ standard used by the source code, in fact you can build a C++03 library with the C++11 <code>std::string</code> ABI and a C++11 library with the C++03 <code>std::string</code> ABI.  This is achieved by appropriately setting the <code>_GLIBCXX_USE_CXX11_ABI</code> macro.</p></div></div><p>This means that when building with GCC a C++ library or program which exposes the <code>std::string</code> ABI, you must make sure that the user whill run a binary matching their <code>std::string</code> ABI.  You can manually specify the <code>std::string</code> ABI in the <code>compiler_abi</code> part of the platform, but <code>BinaryBuilder</code> lets you automatically expand the list of platform to include an entry for the C++03 <code>std::string</code> ABI and another one for the C++11 <code>std::string</code> ABI, by using the <a href="../reference/#BinaryBuilderBase.expand_cxxstring_abis-Tuple{AbstractPlatform}"><code>expand_cxxstring_abis</code></a> function:</p><pre><code class="language-julia-repl hljs">julia&gt; using BinaryBuilder

julia&gt; platforms = [Platform(&quot;x86_64&quot;, &quot;linux&quot;)]
1-element Vector{Platform}:
 Linux x86_64 {libc=glibc}

julia&gt; expand_cxxstring_abis(platforms)
2-element Vector{Platform}:
 Linux x86_64 {cxxstring_abi=cxx03, libc=glibc}
 Linux x86_64 {cxxstring_abi=cxx11, libc=glibc}</code></pre><p>Example of packages dealing with the C++ <code>std::string</code> ABIs are:</p><ul><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/1ba8f726810ba5315f686ef0137469a9bf6cca2c/G/GEOS/build_tarballs.jl#L33"><code>GEOS</code></a>: expands the the C++ <code>std::string</code> ABIs for all supported platforms;</li><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/14ee948c38385fc4dfd7b6167885fa4005b5da35/B/Bloaty/build_tarballs.jl#L37"><code>Bloaty</code></a>: builds the package only for some platforms and expands the C++ <code>std::string</code> ABIs;</li><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/b73815bb1e3894c9ed18801fc7d62ad98fd9f8ba/L/libcgal_julia/build_tarballs.jl#L52-L57"><code>libcgal_julia</code></a>: builds only for platforms with C++11 <code>std::string</code> ABI.</li></ul></li><li><p>The <code>libgfortran</code> that comes with GCC changed the ABI in a backward-incompatible way in the 6.X -&gt; 7.X and the 7.X -&gt; 8.X transitions. This means that when you build a package that will link to <code>libgfortran</code>, you must be sure that the user will use a package linking to a <code>libgfortran</code> version compatible with their own.  Also in this case you can either manually specify the <code>libgfortran</code> version in the <code>compiler_abi</code> part fo the platform or use a function, <a href="../reference/#BinaryBuilderBase.expand_gfortran_versions-Tuple{AbstractPlatform}"><code>expand_gfortran_versions</code></a>, to automatically expand the list of platform to include all possible <code>libgfortran</code> versions:</p><pre><code class="language-julia-repl hljs">julia&gt; using BinaryBuilder

julia&gt; platforms = [Platform(&quot;x86_64&quot;, &quot;linux&quot;)]
1-element Vector{Platform}:
 Linux x86_64 {libc=glibc}

julia&gt; expand_gfortran_versions(platforms)
3-element Vector{Platform}:
 Linux x86_64 {libc=glibc, libgfortran_version=3.0.0}
 Linux x86_64 {libc=glibc, libgfortran_version=4.0.0}
 Linux x86_64 {libc=glibc, libgfortran_version=5.0.0}</code></pre><p>Example of packages expanding the <code>libgfortran</code> versions are:</p><ul><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/4f20fd7c58f6ad58911345adec74deaa8aed1f65/O/OpenSpecFun/build_tarballs.jl#L34"><code>OpenSpecFun</code></a>: expands the <code>libgfortran</code> versions for all supported platforms;</li><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/dbc6aa9dded5ae2fe967f262473f77f7e75f6973/L/LibAMVW/build_tarballs.jl#L65-L73"><code>LibAMVW</code></a>: builds the package only for some platforms and expands the <code>libgfortran</code> versions.</li></ul></li></ul><p>Note that whether you need to build for different C++ string ABIs or libgfortran versions depends exclusively on whether the products of the current build expose the <code>std::string</code> ABI or directly link to <code>libgfortran</code>.  The fact that some of the dependencies need to expand the C++ string ABIs or libgfortran versions is not relevant for the current build recipe and BinaryBuilder will take care of installing libraries with matching ABI.</p><p>Don&#39;t worry if you don&#39;t know whether you need to expand the list of platforms for the C++ <code>std::string</code> ABIs or the libgfortran versions: this is often not possible to know in advance without thoroughly reading the source code or actually building the package.  In any case the audit will inform you if you have to use these <code>expand-*</code> functions.</p><h3 id="Platform-independent-packages"><a class="docs-heading-anchor" href="#Platform-independent-packages">Platform-independent packages</a><a id="Platform-independent-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Platform-independent-packages" title="Permalink"></a></h3><p><code>BinaryBuilder.jl</code> is particularly useful to build packages involving shared libraries and binary executables.  There is little benefit in using this package to build a package that would be platform-independent, for example to install a dataset to be used in a Julia package on the user&#39;s machine.  For this purpose a simple <a href="https://julialang.github.io/Pkg.jl/v1/artifacts/#Artifacts.toml-files-1"><code>Artifacts.toml</code></a> file generated with <a href="https://julialang.github.io/Pkg.jl/v1/artifacts/#Using-Artifacts-1"><code>create_artifact</code></a> would do exactly the same job.  Nevertheless, there are cases where a platform-independent JLL package would still be useful, for example to build a package containing only header files that will be used as dependency of other packages.  To build a platform-independent package you can use the special platform <a href="../reference/#BinaryBuilderBase.AnyPlatform"><code>AnyPlatform</code></a>:</p><pre><code class="language-julia hljs">platforms = [AnyPlatform()]</code></pre><p>Within the build environment, an <code>AnyPlatform</code> looks like <code>x86_64-linux-musl</code>, but this shouldn&#39;t affect your build in any way.  Note that when building a package for <code>AnyPlatform</code> you can only have products of type <code>FileProduct</code>, as all other types are platform-dependent.  The JLL package generated for an <code>AnyPlatform</code> is <a href="https://julialang.github.io/Pkg.jl/v1/artifacts/#Artifact-types-and-properties-1">platform-independent</a> and can thus be installed on any machine.</p><p>Example of builders using <code>AnyPlatform</code>:</p><ul><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/1e069da9a4f9649b5f42547ced7273c27bd2db30/O/OpenCL_Headers/build_tarballs.jl"><code>OpenCL_Headers</code></a>;</li><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/1e069da9a4f9649b5f42547ced7273c27bd2db30/S/SPIRV_Headers/build_tarballs.jl"><code>SPIRV_Headers</code></a>.</li></ul><h2 id="Products"><a class="docs-heading-anchor" href="#Products">Products</a><a id="Products-1"></a><a class="docs-heading-anchor-permalink" href="#Products" title="Permalink"></a></h2><p>The products are the files expected to be present in the generated tarballs.  If a product is not found in the tarball, the build will fail.  Products can be of the following types:</p><ul><li><a href="../reference/#BinaryBuilderBase.LibraryProduct"><code>LibraryProduct</code></a>: this represent a shared library;</li><li><a href="../reference/#BinaryBuilderBase.ExecutableProduct"><code>ExecutableProduct</code></a>: this represent a binary executable program. Note: this cannot be used for interpreted scripts;</li><li><a href="../reference/#BinaryBuilderBase.FrameworkProduct"><code>FrameworkProduct</code></a> (only when building for <code>MacOS</code>): this represents a <a href="https://en.wikipedia.org/wiki/Bundle_(macOS)#macOS_framework_bundles">macOS framework</a>;</li><li><a href="../reference/#BinaryBuilderBase.FileProduct"><code>FileProduct</code></a>: a file of any type, with no special treatment.</li></ul><p>The audit will perform a series of sanity checks on the products of the builder, with the exclusion <code>FileProduct</code>s, trying also to automatically fix some common issues.</p><p>You don&#39;t need to list as products <em>all</em> files that will end up in the tarball, but only those you want to make sure are there and on which you want the audit to perform its checks.  This usually includes the shared libraries and the binary executables.  If you are also generating a JLL package, the products will have some variables that make it easy to reference them.  See the documentation of <a href="../jll/">JLL packages</a> for more information about this.</p><p>Packages listing products of different types:</p><ul><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/eb3728a2303c98519338fe0be370ef299b807e19/F/Fontconfig/build_tarballs.jl#L57-L69"><code>Fontconfig</code></a>.</li></ul><h2 id="Binary-dependencies"><a class="docs-heading-anchor" href="#Binary-dependencies">Binary dependencies</a><a id="Binary-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-dependencies" title="Permalink"></a></h2><p>A build script can depend on binaries generated by another builder. A builder specifies <code>dependencies</code> in the form of previously-built JLL packages:</p><pre><code class="language-julia hljs"># Dependencies of Xorg_xkbcomp
dependencies = [
    Dependency(&quot;Xorg_libxkbfile_jll&quot;),
    BuildDependency(&quot;Xorg_util_macros_jll&quot;),
]</code></pre><ul><li><a href="../reference/#BinaryBuilderBase.Dependency"><code>Dependency</code></a> specify a JLL package that is necessary to build and load the current builder.  Binaries for the target platform will be installed;</li><li><a href="../reference/#BinaryBuilderBase.RuntimeDependency"><code>RuntimeDependency</code></a>: a JLL package that is necessary only at runtime.  Its artifact will not be installed in the prefix during the build.</li><li><a href="../reference/#BinaryBuilderBase.BuildDependency"><code>BuildDependency</code></a> is a JLL package necessary only to build the current package, but not to load it.  This dependency will install binaries for the target platforms and will not be added to the list of the dependencies of the generated JLL package;</li><li><a href="../reference/#BinaryBuilderBase.HostBuildDependency"><code>HostBuildDependency</code></a>: similar to <code>BuildDependency</code>, but it will install binaries for the host system.  This kind of dependency is usually added to provide some binary utilities to run during the build process.</li></ul><p>The argument of <code>Dependency</code>, <code>RuntimeDependency</code>, <code>BuildDependency</code>, and <code>HostBuildDependency</code> can also be a <code>Pkg.PackageSpec</code>, with which you can specify more details about the dependency, like a version number, or also a non-registered package.  Note that in Yggdrasil only JLL packages in the <a href="https://github.com/JuliaRegistries/General">General registry</a> can be accepted.</p><p>The dependencies for the target system (<code>Dependency</code> and <code>BuildDependency</code>) will be installed under <code>${prefix}</code> within the build environment, while the dependencies for the host system (<code>HostBuildDependency</code>) will be installed under <code>${host_prefix}</code>.</p><p>In the wizard, dependencies can be specified with the prompt: <em>Do you require any (binary) dependencies?  [y/N]</em>.</p><p>Examples of builders that depend on other binaries include:</p><ul><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/eb3728a2303c98519338fe0be370ef299b807e19/X/Xorg_libX11/build_tarballs.jl#L36-L42"><code>Xorg_libX11</code></a> depends on <code>Xorg_libxcb_jll</code>, and <code>Xorg_xtrans_jll</code> at build- and run-time, and on <code>Xorg_xorgproto_jll</code> and <code>Xorg_util_macros_jll</code> only at build-time.</li></ul><h3 id="Platform-specific-dependencies"><a class="docs-heading-anchor" href="#Platform-specific-dependencies">Platform-specific dependencies</a><a id="Platform-specific-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Platform-specific-dependencies" title="Permalink"></a></h3><p>By default, all dependencies are used for all platforms, but there are some cases where a package requires some dependencies only on some platforms.  You can specify the platforms where a dependency is needed by passing the <code>platforms</code> keyword argument to the dependency constructor, which is the vector of <code>AbstractPlatforms</code> where the dependency should be used.</p><p>For example, assuming that the variable <code>platforms</code> holds the vector of the platforms for which to build your package, you can specify that <code>Package_jl</code> is required on all platforms excluding Windows one with</p><pre><code class="language-julia hljs">Dependency(&quot;Package_jll&quot;; platforms=filter(!Sys.iswindows, platforms))</code></pre><p>The information that a dependency is only needed on some platforms is transferred to the JLL package as well: the wrappers will load the platform-dependent JLL dependencies only when needed.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Julia&#39;s package manager doesn&#39;t have the concept of optional (or platform-dependent) dependencies: this means that when installing a JLL package in your environment, all of its dependencies will always be installed as well in any case.  It&#39;s only at runtime that platform-specific dependencies will be loaded where necessary.</p><p>For the same reason, even if you specify a dependency to be not needed on for a platform, the build recipe may still pull it in if that&#39;s also an indirect dependency required by some other dependencies.  At the moment <code>BinaryBuilder.jl</code> isn&#39;t able to propagate the information that a dependency is platform-dependent when installing the artifacts of the dependencies.</p></div></div><p>Examples:</p><ul><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/0528e0f31b55355df632c79a2784621583443d9c/A/ADIOS2/build_tarballs.jl#L122-L123"><code>ADIOS2</code></a> uses <code>MPICH_jll</code> to provide an MPI implementations on all platforms excluding Windows, and <code>MicrosoftMPI_jll</code> for Windows.</li><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/0528e0f31b55355df632c79a2784621583443d9c/G/GTK3/build_tarballs.jl#L70-L104"><code>GTK3</code></a> uses the X11 software stack only on Linux and FreeBSD platforms, and Wayland only on Linux.</li><li><a href="https://github.com/JuliaPackaging/Yggdrasil/blob/0528e0f31b55355df632c79a2784621583443d9c/N/NativeFileDialog/build_tarballs.jl#L40-L44"><code>NativeFileDialog</code></a> uses GTK3 only on Linux and FreeBSD, on all other platforms it uses system libraries, so no other packages are needed in those cases.</li></ul><h3 id="Version-number-of-dependencies"><a class="docs-heading-anchor" href="#Version-number-of-dependencies">Version number of dependencies</a><a id="Version-number-of-dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Version-number-of-dependencies" title="Permalink"></a></h3><p>There are two different ways to specify the version of a dependency, with two different meanings:</p><ul><li><code>Dependency(&quot;Foo_jll&quot;, v&quot;1.2.3&quot;)</code>: the second argument of <code>Dependency</code> specifies the version of the package to be used for building: this version <em>is not</em> reflected into a compatibility bound in the project of the generated JLL package.  This is useful when the package you want to build is compatible with all the versions of the dependency starting from the given one (and then you don&#39;t want to restrict compatibility bounds of the JLL package), but to maximize compatibility you want to build against the oldest compatible version.</li><li><code>Dependency(PackageSpec(; name=&quot;Foo_jll&quot;, version=v&quot;1.2.3&quot;))</code>: if the package is given as a <code>Pkg.PackageSpec</code> and the <code>version</code> keyword argument is given, this version of the package is used for the build <em>and</em> the generated JLL package will be compatible with the provided version of the package.  This should be used when your package is compatible only with a single version of the dependency, a condition that you want to reflect also in the project of the JLL package.</li></ul><h1 id="Building-and-testing-JLL-packages-locally"><a class="docs-heading-anchor" href="#Building-and-testing-JLL-packages-locally">Building and testing JLL packages locally</a><a id="Building-and-testing-JLL-packages-locally-1"></a><a class="docs-heading-anchor-permalink" href="#Building-and-testing-JLL-packages-locally" title="Permalink"></a></h1><p>As a package developer, you may want to test JLL packages locally, or as a binary dependency developer you may want to easily use custom binaries.  Through a combination of <code>dev</code>&#39;ing out the JLL package and creating an <code>overrides</code> directory, it is easy to get complete control over the local JLL package state.</p><h2 id="Overriding-a-prebuilt-JLL-package&#39;s-binaries"><a class="docs-heading-anchor" href="#Overriding-a-prebuilt-JLL-package&#39;s-binaries">Overriding a prebuilt JLL package&#39;s binaries</a><a id="Overriding-a-prebuilt-JLL-package&#39;s-binaries-1"></a><a class="docs-heading-anchor-permalink" href="#Overriding-a-prebuilt-JLL-package&#39;s-binaries" title="Permalink"></a></h2><p>After running <code>pkg&gt; dev LibFoo_jll</code>, a local JLL package will be checked out to your depot&#39;s <code>dev</code> directory (on most installations this is <code>~/.julia/dev</code>) and by default the JLL package will make use of binaries within your depot&#39;s <code>artifacts</code> directory.  If an <code>override</code> directory is present within the JLL package directory, the JLL package will look within that <code>override</code> directory for binaries, rather than in any artifact directory.  Note that there is no mixing and matching of binaries within a single JLL package; if an <code>override</code> directory is present, all products defined within that JLL package must be found within the <code>override</code> directory, none will be sourced from an artifact.  Dependencies (e.g. found within another JLL package) may still be loaded from their respective artifacts, so dependency JLLs must themselves be <code>dev</code>&#39;ed and have <code>override</code> directories created with files or symlinks created within them.</p><h3 id="Auto-populating-the-override-directory"><a class="docs-heading-anchor" href="#Auto-populating-the-override-directory">Auto-populating the <code>override</code> directory</a><a id="Auto-populating-the-override-directory-1"></a><a class="docs-heading-anchor-permalink" href="#Auto-populating-the-override-directory" title="Permalink"></a></h3><p>To ease creation of an <code>override</code> directory, JLL packages contain a <code>dev_jll()</code> function, that will ensure that a <code>~/.julia/dev/&lt;jll name&gt;</code> package is <code>dev</code>&#39;ed out, and will copy the normal artifact contents into the appropriate <code>override</code> directory.  This will result in no functional difference from simply using the artifact directory, but provides a template of files that can be replaced by custom-built binaries.</p><p>Note that this feature is rolling out to new JLL packages as they are rebuilt; if a JLL package does not have a <code>dev_jll()</code> function, <a href="https://github.com/JuliaPackaging/Yggdrasil/issues/new">open an issue on Yggdrasil</a> and a new JLL version will be generated to provide the function.</p><h2 id="Building-a-custom-JLL-package-locally"><a class="docs-heading-anchor" href="#Building-a-custom-JLL-package-locally">Building a custom JLL package locally</a><a id="Building-a-custom-JLL-package-locally-1"></a><a class="docs-heading-anchor-permalink" href="#Building-a-custom-JLL-package-locally" title="Permalink"></a></h2><p>When building a new version of a JLL package, if <code>--deploy</code> is passed to <code>build_tarballs.jl</code> then a newly-built JLL package will be deployed to a GitHub repository.  (Read the documentation in the <a href="../reference/#Command-Line">Command Line</a> section or given by passing <code>--help</code> to a <code>build_tarballs.jl</code> script for more on <code>--deploy</code> options).  If <code>--deploy=local</code> is passed, the JLL package will still be built in the <code>~/.julia/dev/</code> directory, but it will not be uploaded anywhere.  This is useful for local testing and validation that the built artifacts are working with your package.</p><h2 id="Deploying-local-builds-without-recreating-the-tarballs"><a class="docs-heading-anchor" href="#Deploying-local-builds-without-recreating-the-tarballs">Deploying local builds without recreating the tarballs</a><a id="Deploying-local-builds-without-recreating-the-tarballs-1"></a><a class="docs-heading-anchor-permalink" href="#Deploying-local-builds-without-recreating-the-tarballs" title="Permalink"></a></h2><p>Sometimes all tarballs have already been created successfully locally but not deployed to GitHub. This can happen, e.g., if it is tricky to figure out the correct build script for all platforms, or if each platform build takes a long time. In this case, it is possible to skip the build process and just deploy the JLL package by providing the <code>--skip-build</code> flag to the <code>build_tarballs.jl</code> script. Read the help (<code>--help</code>) for more information.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../build_tips/">Build Tips »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 30 December 2023 12:31">Saturday 30 December 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
