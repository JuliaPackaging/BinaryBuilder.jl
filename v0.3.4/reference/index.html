<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · BinaryBuilder.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">BinaryBuilder.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../building/">Building Packages</a></li><li><a class="tocitem" href="../build_tips/">Build Tips</a></li><li><a class="tocitem" href="../jll/">JLL packages</a></li><li><a class="tocitem" href="../FAQ/">FAQ</a></li><li><a class="tocitem" href="../troubleshooting/">Build Troubleshooting</a></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../rootfs/">RootFS</a></li><li><a class="tocitem" href="../environment_variables/">Environment Variables</a></li><li><a class="tocitem" href="../tricksy_gotchas/">Tricksy Gotchas</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Command-Line"><span>Command Line</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Internals</a></li><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.AbstractDependency" href="#BinaryBuilderBase.AbstractDependency"><code>BinaryBuilderBase.AbstractDependency</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>AbstractDependency</code> is a binary dependency of the JLL package.  Dependencies are installed to <code>${prefix}</code> in the build environment.</p><p>Concrete subtypes of <code>AbstractDependency</code> are</p><ul><li><a href="#BinaryBuilderBase.Dependency"><code>Dependency</code></a>: a JLL package that is necessary for to build the package and to load the generated JLL package.</li><li><a href="#BinaryBuilderBase.BuildDependency"><code>BuildDependency</code></a>: a JLL package that is necessary only to build the package.  This will not be a dependency of the generated JLL package.</li><li><a href="#BinaryBuilderBase.HostBuildDependency"><code>HostBuildDependency</code></a>: similar to <code>BuildDependency</code>, but it will install the artifact for the host platform, instead of that for the target platform.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.AbstractSource" href="#BinaryBuilderBase.AbstractSource"><code>BinaryBuilderBase.AbstractSource</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>AbstractSource</code> is something used as source to build the package.  Sources are installed to <code>${WORKSPACE}/srcdir</code> in the build environment.</p><p>Concrete subtypes of <code>AbstractSource</code> are:</p><ul><li><a href="#BinaryBuilderBase.ArchiveSource"><code>ArchiveSource</code></a>: a remote archive to download from the Internet;</li><li><a href="#BinaryBuilderBase.FileSource"><code>FileSource</code></a>: a remote file to download from the Internet;</li><li><a href="#BinaryBuilderBase.GitSource"><code>GitSource</code></a>: a remote Git repository to clone;</li><li><a href="#BinaryBuilderBase.DirectorySource"><code>DirectorySource</code></a>: a local directory to mount.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.AnyPlatform" href="#BinaryBuilderBase.AnyPlatform"><code>BinaryBuilderBase.AnyPlatform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AnyPlatform()</code></pre><p>A special platform to be used to build platform-independent tarballs, like those containing only header files.  <a href="#BinaryBuilderBase.FileProduct"><code>FileProduct</code></a> is the only product type allowed with this platform.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.ArchiveSource" href="#BinaryBuilderBase.ArchiveSource"><code>BinaryBuilderBase.ArchiveSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ArchiveSource(url::String, hash::String; unpack_target::String = &quot;&quot;)</code></pre><p>Specify a remote archive in one of the supported archive formats (e.g., TAR or ZIP balls) to be downloaded from the Internet from <code>url</code>.  <code>hash</code> is the 64-character SHA256 checksum of the file.</p><p>In the builder environment, the archive will be automatically unpacked to <code>${WORKSPACE}/srcdir</code>, or in its subdirectory pointed to by the optional keyword <code>unpack_target</code>, if provided.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.BuildDependency" href="#BinaryBuilderBase.BuildDependency"><code>BinaryBuilderBase.BuildDependency</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BuildDependency(dep::Union{PackageSpec,String})</code></pre><p>Define a binary dependency that is necessary only to build the package.  The argument can be either a string with the name of the JLL package or a <code>Pkg.PackageSpec</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.Dependency" href="#BinaryBuilderBase.Dependency"><code>BinaryBuilderBase.Dependency</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Dependency(dep::Union{PackageSpec,String})</code></pre><p>Define a binary dependency that is necessary to build the package and load the generated JLL package.  The argument can be either a string with the name of the JLL package or a <code>Pkg.PackageSpec</code>.</p><p>The optional keyword argument <code>build_version</code> can be used to specify the version of the dependency to be installed when building it.</p><p>The optional keyword argument <code>compat</code> can be used to specify a string for use in the <code>Project.toml</code> of the generated Julia package.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.DirectorySource" href="#BinaryBuilderBase.DirectorySource"><code>BinaryBuilderBase.DirectorySource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DirectorySource(path::String; target::String = basename(path), follow_symlinks=false)</code></pre><p>Specify a local directory to mount from <code>path</code>.</p><p>The content of the directory will be mounted in <code>${WORKSPACE}/srcdir</code>, or in its subdirectory pointed to by the optional keyword <code>target</code>, if provided. Symbolic links are replaced by a copy of the target when <code>follow_symlinks</code> is <code>true</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.DockerRunner" href="#BinaryBuilderBase.DockerRunner"><code>BinaryBuilderBase.DockerRunner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DockerRunner</code></pre><p>Use <code>docker</code> as an execution engine; a reasonable backup for platforms that do not have user namespaces (e.g. MacOS, Windows).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.ExecutableProduct" href="#BinaryBuilderBase.ExecutableProduct"><code>BinaryBuilderBase.ExecutableProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An <code>ExecutableProduct</code> is a <a href="#BinaryBuilderBase.Product"><code>Product</code></a> that represents an executable file.</p><p>On all platforms, an ExecutableProduct checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set.  On Windows platforms, it will check that the file ends with &quot;.exe&quot;, (adding it on automatically, if it is not already present).</p><hr/><pre><code class="language-none">ExecutableProduct(binname, varname::Symbol, dir_path=&quot;bin&quot;)</code></pre><p>Declares an <code>ExecutableProduct</code> that points to an executable located within the prefix.  <code>binname</code> specifies the basename of the executable, <code>varname</code> is the name of the variable in the JLL package that can be used to call into the library.  By default, the library is searched in the <code>bindir</code>, but you can specify a different directory within the prefix with the <code>dir_path</code> argument.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.FileProduct" href="#BinaryBuilderBase.FileProduct"><code>BinaryBuilderBase.FileProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FileProduct(path::AbstractString, varname::Symbol, dir_path = nothing)</code></pre><p>Declares a <a href="#BinaryBuilderBase.FileProduct"><code>FileProduct</code></a> that points to a file located relative to the root of a <code>Prefix</code>, must simply exist to be satisfied.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.FileSource" href="#BinaryBuilderBase.FileSource"><code>BinaryBuilderBase.FileSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FileSource(url::String, hash::String; filename::String = basename(url))</code></pre><p>Specify a remote file to be downloaded from the Internet from <code>url</code>.  <code>hash</code> is the 64-character SHA256 checksum of the file.</p><p>In the builder environment, the file will be saved under <code>${WORKSPACE}/srcdir</code> with the same name as the basename of the originating URL, unless the the keyword argument <code>filename</code> is specified.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.FrameworkProduct" href="#BinaryBuilderBase.FrameworkProduct"><code>BinaryBuilderBase.FrameworkProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>FrameworkProduct</code> is a  <a href="#BinaryBuilderBase.Product"><code>Product</code></a> that encapsulates a macOS Framework. It behaves mostly as a <a href="#BinaryBuilderBase.LibraryProduct"><code>LibraryProduct</code></a> for now, but is a distinct type. This implies that for cross-platform builds where a library is provided as a Framework on macOS and as a normal library on other platforms, two calls to BinaryBuilder&#39;s <code>build_tarballs</code> are needed: one with the <code>LibraryProduct</code> and all non-macOS platforms, and one with the <code>FrameworkProduct</code> and the <code>MacOS</code> platforms.</p><hr/><pre><code class="language-none">FrameworkProduct(fwnames, varname::Symbol)</code></pre><p>Declares a macOS <code>FrameworkProduct</code> that points to a framework located within the prefix, with a name containing <code>fwname</code> appended with <code>.framework</code>.  As an example, given that <code>fwname</code> is equal to <code>QtCore</code>, this would be satisfied by the following path:</p><pre><code class="language-none">lib/QtCore.framework</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.GitSource" href="#BinaryBuilderBase.GitSource"><code>BinaryBuilderBase.GitSource</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GitSource(url::String, hash::String; unpack_target::String = &quot;&quot;)</code></pre><p>Specify a remote Git repository to clone form <code>url</code>.  <code>hash</code> is the 40-character SHA1 revision to checkout after cloning.</p><p>The repository will be cloned in <code>${WORKSPACE}/srcdir</code>, or in its subdirectory pointed to by the optional keyword <code>unpack_target</code>, if provided.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.HostBuildDependency" href="#BinaryBuilderBase.HostBuildDependency"><code>BinaryBuilderBase.HostBuildDependency</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HostBuildDependency(dep::Union{PackageSpec,String})</code></pre><p>Define a binary dependency that is necessary only to build the package. Different from the <a href="#BinaryBuilderBase.BuildDependency"><code>BuildDependency</code></a>, the artifact for the host platform will be installed, instead of that for the target platform.</p><p>The argument can be either a string with the name of the JLL package or a <code>Pkg.PackageSpec</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.LibraryProduct" href="#BinaryBuilderBase.LibraryProduct"><code>BinaryBuilderBase.LibraryProduct</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>LibraryProduct</code> is a special kind of <a href="#BinaryBuilderBase.Product"><code>Product</code></a> that not only needs to exist, but needs to be <code>dlopen()</code>&#39;able.  You must know which directory the library will be installed to, and its name, e.g. to build a <code>LibraryProduct</code> that refers to <code>&quot;/lib/libnettle.so&quot;</code>, the &quot;directory&quot; would be &quot;/lib&quot;, and the &quot;libname&quot; would be &quot;libnettle&quot;.  Note that a <code>LibraryProduct</code> can support multiple libnames, as some software projects change the libname based on the build configuration.</p><hr/><pre><code class="language-none">LibraryProduct(libname, varname::Symbol; dir_paths=String[],
                                         dont_dlopen=false,
                                         dlopen_flags=Symbol[])</code></pre><p>Declares a <code>LibraryProduct</code> that points to a library located within the prefix. <code>libname</code> specifies the basename of the library, <code>varname</code> is the name of the variable in the JLL package that can be used to call into the library.  By default, the library is searched in the <code>libdir</code>, but you can add other directories within the prefix to the <code>dir_paths</code> keyword argument.  You can specify the flags to pass to <code>dlopen</code> as a vector of <code>Symbols</code> with the <code>dlopen_flags</code> keyword argument.  If the library should not be dlopen&#39;ed automatically by the JLL package, set <code>dont_dlopen=true</code>.</p><p>For example, if the <code>libname</code> is <code>libnettle</code>, this would be satisfied by the following paths:</p><ul><li><code>lib/libnettle.so</code> or <code>lib/libnettle.so.6</code> on Linux and FreeBSD;</li><li><code>lib/libnettle.6.dylib</code> on macOS;</li><li><code>lib/libnettle-6.dll</code> on Windows.</li></ul><p>Libraries matching the search pattern are rejected if they are not <code>dlopen()</code>&#39;able.</p><p>If you are unsure what value to use for <code>libname</code>, you can use <code>Base.BinaryPlatforms.parse_dl_name_version</code>:</p><pre><code class="language-none">julia&gt; using Base.BinaryPlatforms

julia&gt; parse_dl_name_version(&quot;sfml-audio-2.dll&quot;, &quot;windows&quot;)[1]
&quot;sfml-audio&quot;</code></pre><p>If the library would have different basenames on different operating systems (e.g., <code>libz.so</code> on Linux and FreeBSD, <code>libz.dylib</code> on macOS, and <code>zlib.dll</code> on Windows), <code>libname</code> can be also a vector of <code>String</code>s with the different alternatives:</p><pre><code class="language-none">LibraryProduct([&quot;libz&quot;, &quot;zlib&quot;], :libz)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.Product" href="#BinaryBuilderBase.Product"><code>BinaryBuilderBase.Product</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Product</code> is an expected result after building or installation of a package.</p><p>Examples of <code>Product</code>s include <a href="#BinaryBuilderBase.LibraryProduct"><code>LibraryProduct</code></a>, <a href="#BinaryBuilderBase.FrameworkProduct"><code>FrameworkProduct</code></a>, <a href="#BinaryBuilderBase.ExecutableProduct"><code>ExecutableProduct</code></a> and <a href="#BinaryBuilderBase.FileProduct"><code>FileProduct</code></a>. All <code>Product</code> types must define the following minimum set of functionality:</p><ul><li><p><a href="#BinaryBuilderBase.locate-Tuple{ExecutableProduct, Prefix}"><code>locate(::Product)</code></a>: given a <code>Product</code>, locate it within the wrapped <code>Prefix</code> returning its location as a string</p></li><li><p><a href="#BinaryBuilderBase.satisfied-Tuple{Product, Prefix}"><code>satisfied(::Product)</code></a>: given a <code>Product</code>, determine whether it has been successfully satisfied (e.g. it is locateable and it passes all callbacks)</p></li><li><p><a href="#BinaryBuilderBase.variable_name-Tuple{Product}"><code>variable_name(::Product)</code></a>: return the variable name assigned to a <code>Product</code></p></li><li><p><code>repr(::Product)</code>: Return a representation of this <code>Product</code>, useful for auto-generating source code that constructs <code>Products</code>, if that&#39;s your thing.</p></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.UserNSRunner" href="#BinaryBuilderBase.UserNSRunner"><code>BinaryBuilderBase.UserNSRunner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UserNSRunner</code></pre><p>A <code>UserNSRunner</code> represents an &quot;execution context&quot;, an object that bundles all necessary information to run commands within the container that contains our crossbuild environment.  Use <code>run()</code> to actually run commands within the <code>UserNSRunner</code>, and <a href="#BinaryBuilderBase.runshell"><code>runshell()</code></a> as a quick way to get an interactive shell within the crossbuild environment.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.WizardState" href="#BinaryBuilder.Wizard.WizardState"><code>BinaryBuilder.Wizard.WizardState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">WizardState</code></pre><p>Building large dependencies can take a lot of time. This state object captures all relevant state of this function. It can be passed back to the function to resume where we left off. This can aid debugging when code changes are necessary.  It also holds all necessary metadata such as input/output streams.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/state.jl#L16-L23">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.abi_agnostic-Tuple{Platform}" href="#BinaryBuilderBase.abi_agnostic-Tuple{Platform}"><code>BinaryBuilderBase.abi_agnostic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abi_agnostic(p::AbstractPlatform)</code></pre><p>Strip out any tags that are not the basic annotations like <code>libc</code> and <code>call_abi</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.accept_apple_sdk-Tuple{IO, IO}" href="#BinaryBuilderBase.accept_apple_sdk-Tuple{IO, IO}"><code>BinaryBuilderBase.accept_apple_sdk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">accept_apple_sdk(ins::IO, outs::IO) -&gt; Bool</code></pre><p>Ask the user whether they accept the terms of the macOS SDK, and return a boolean with their choice.  Write messages to <code>outs</code>, read input from <code>ins</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.artifact_name-Tuple{CompilerShard}" href="#BinaryBuilderBase.artifact_name-Tuple{CompilerShard}"><code>BinaryBuilderBase.artifact_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">artifact_name(cs::CompilerShard)</code></pre><p>Return the bound artifact name for a particular shard.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.bindir-Tuple{Prefix}" href="#BinaryBuilderBase.bindir-Tuple{Prefix}"><code>BinaryBuilderBase.bindir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bindir(prefix::Prefix)</code></pre><p>Returns the binary directory for the given <code>prefix</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.choose_shards-Tuple{AbstractPlatform}" href="#BinaryBuilderBase.choose_shards-Tuple{AbstractPlatform}"><code>BinaryBuilderBase.choose_shards</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">choose_shards(p::AbstractPlatform; rootfs_build, ps_build, GCC_builds,
                           LLVM_builds, archive_type)</code></pre><p>This method chooses, given a <code>Platform</code>, which shards to download, extract and mount, returning a list of <code>CompilerShard</code> objects.  At the moment, this always consists of four shards, but that may not always be the case.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.chown_cleanup-Tuple{DockerRunner}" href="#BinaryBuilderBase.chown_cleanup-Tuple{DockerRunner}"><code>BinaryBuilderBase.chown_cleanup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chown_cleanup(dr::DockerRunner)</code></pre><p>On Linux, the user id inside of the docker container doesn&#39;t correspond to ours on the outside, so permissions get all kinds of screwed up.  To fix this, we have to <code>chown -R $(id -u):$(id -g) $prefix</code>, which really sucks, but is still better than nothing.  This is why we prefer the UserNSRunner on Linux.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.collect_jlls-Tuple{Dict, Set{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:AbstractString}" href="#BinaryBuilderBase.collect_jlls-Tuple{Dict, Set{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:AbstractString}"><code>BinaryBuilderBase.collect_jlls</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">collect_jlls(manifest::Dict, dependencies::Vector{&lt;:AbstractString})</code></pre><p>Return a <code>Set</code> of all JLL packages in the <code>manifest</code> with <code>dependencies</code> being the list of direct dependencies of the environment.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.compress_dir-Tuple{AbstractString}" href="#BinaryBuilderBase.compress_dir-Tuple{AbstractString}"><code>BinaryBuilderBase.compress_dir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compress_dir(dir::AbstractString;
             compressor_stream = GzipCompressorStream,
             level::Int = 9,
             extension::AbstractString = &quot;.gz&quot;,
             verbose::Bool = false)</code></pre><p>Compress all files in <code>dir</code> using the specified <code>compressor_stream</code> with compression level equal to <code>level</code>, appending <code>extension</code> to the filenames. Remove the original uncompressed files at the end.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.download_all_artifacts-Tuple{}" href="#BinaryBuilderBase.download_all_artifacts-Tuple{}"><code>BinaryBuilderBase.download_all_artifacts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">download_all_artifacts(; verbose::Bool=false)</code></pre><p>Helper function to download all shards/helper binaries so that no matter what happens, you don&#39;t need an internet connection to build your precious, precious binaries.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.download_source" href="#BinaryBuilderBase.download_source"><code>BinaryBuilderBase.download_source</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">download_source(source::AbstractSource; verbose::Bool = false)</code></pre><p>Download the given <code>source</code>.  All downloads are cached within the BinaryBuilder <code>downloads</code> storage directory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.enable_apple_file-Tuple{}" href="#BinaryBuilderBase.enable_apple_file-Tuple{}"><code>BinaryBuilderBase.enable_apple_file</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">enable_apple_file()</code></pre><p>Return the path to file that, if exists, indicates that the user accepts to download macOS SDK.  The file is automatically created when the package is loaded if the environment variable <code>BINARYBUILDER_AUTOMATIC_APPLE</code> is set to <code>&quot;true&quot;</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.expand_cxxstring_abis-Tuple{AbstractPlatform}" href="#BinaryBuilderBase.expand_cxxstring_abis-Tuple{AbstractPlatform}"><code>BinaryBuilderBase.expand_cxxstring_abis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand_cxxstring_abis(p::AbstractPlatform; skip=Sys.isbsd)</code></pre><p>Given a <code>Platform</code>, returns an array of <code>Platforms</code> with a spread of identical entries with the exception of the <code>cxxstring_abi</code> tag within the <code>Platform</code> object.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.</p><p>If the given <code>Platform</code> already specifies a <code>cxxstring_abi</code> (as opposed to <code>nothing</code>) only that <code>Platform</code> is returned.  If <code>skip</code> is a function for which <code>skip(platform)</code> evaluates to <code>true</code>, the given platform is not expanded.  By default FreeBSD and macOS platforms are skipped, due to their lack of a dependence on <code>libstdc++</code> and not needing this compatibility shim.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.expand_gfortran_versions-Tuple{AbstractPlatform}" href="#BinaryBuilderBase.expand_gfortran_versions-Tuple{AbstractPlatform}"><code>BinaryBuilderBase.expand_gfortran_versions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand_gfortran_versions(p::AbstractPlatform)</code></pre><p>Given a <code>Platform</code>, returns an array of <code>Platforms</code> with a spread of identical entries with the exception of the <code>libgfortran_version</code> tag within the <code>Platform</code>.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.  If the given <code>Platform</code> already specifies a <code>libgfortran_version</code> (as opposed to <code>nothing</code>) only that <code>Platform</code> is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.expand_microarchitectures-Tuple{AbstractPlatform}" href="#BinaryBuilderBase.expand_microarchitectures-Tuple{AbstractPlatform}"><code>BinaryBuilderBase.expand_microarchitectures</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand_microarchitectures(p::AbstractPlatform)</code></pre><p>Given a <code>Platform</code>, returns a vector of <code>Platforms</code> with differing <code>march</code> attributes as specified by the <code>ARCHITECTURE_FLAGS</code> mapping.  If the given <code>Platform</code> alread has a <code>march</code> tag specified, only that platform is returned.</p><pre><code class="language-julia-repl">julia&gt; using BinaryBuilderBase

julia&gt; expand_microarchitectures(Platform(&quot;x86_64&quot;, &quot;freebsd&quot;))
4-element Vector{Platform}:
 FreeBSD x86_64 {march=x86_64}
 FreeBSD x86_64 {march=avx}
 FreeBSD x86_64 {march=avx2}
 FreeBSD x86_64 {march=avx512}

julia&gt; expand_microarchitectures(Platform(&quot;armv7l&quot;, &quot;linux&quot;))
2-element Vector{Platform}:
 Linux armv7l {call_abi=eabihf, libc=glibc, march=armv7l}
 Linux armv7l {call_abi=eabihf, libc=glibc, march=neonvfpv4}

julia&gt; expand_microarchitectures(Platform(&quot;aarch64&quot;, &quot;linux&quot;))
4-element Vector{Platform}:
 Linux aarch64 {libc=glibc, march=armv8_0}
 Linux aarch64 {libc=glibc, march=armv8_4_crypto_sve}
 Linux aarch64 {libc=glibc, march=armv8_2_crypto}
 Linux aarch64 {libc=glibc, march=armv8_1}

julia&gt; expand_microarchitectures(Platform(&quot;i686&quot;, &quot;windows&quot;))
2-element Vector{Platform}:
 Windows i686 {march=pentium4}
 Windows i686 {march=prescott}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.expand_microarchitectures-Tuple{Vector{var&quot;#s1006&quot;} where var&quot;#s1006&quot;&lt;:AbstractPlatform}" href="#BinaryBuilderBase.expand_microarchitectures-Tuple{Vector{var&quot;#s1006&quot;} where var&quot;#s1006&quot;&lt;:AbstractPlatform}"><code>BinaryBuilderBase.expand_microarchitectures</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand_microarchitectures(ps::Vector{&lt;:Platform})</code></pre><p>Expand all platforms in the given vector with the supported microarchitectures.</p><pre><code class="language-julia-repl">julia&gt; using BinaryBuilderBase

julia&gt; expand_microarchitectures(filter!(p -&gt; Sys.islinux(p) &amp;&amp; libc(p) == &quot;glibc&quot;, supported_platforms()))
13-element Vector{Platform}:
 Linux i686 {libc=glibc, march=pentium4}
 Linux i686 {libc=glibc, march=prescott}
 Linux x86_64 {libc=glibc, march=x86_64}
 Linux x86_64 {libc=glibc, march=avx}
 Linux x86_64 {libc=glibc, march=avx2}
 Linux x86_64 {libc=glibc, march=avx512}
 Linux aarch64 {libc=glibc, march=armv8_0}
 Linux aarch64 {libc=glibc, march=armv8_4_crypto_sve}
 Linux aarch64 {libc=glibc, march=armv8_2_crypto}
 Linux aarch64 {libc=glibc, march=armv8_1}
 Linux armv7l {call_abi=eabihf, libc=glibc, march=armv7l}
 Linux armv7l {call_abi=eabihf, libc=glibc, march=neonvfpv4}
 Linux powerpc64le {libc=glibc, march=power8}</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.gcc_version-Tuple{AbstractPlatform, Vector{BinaryBuilderBase.GCCBuild}}" href="#BinaryBuilderBase.gcc_version-Tuple{AbstractPlatform, Vector{BinaryBuilderBase.GCCBuild}}"><code>BinaryBuilderBase.gcc_version</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gcc_version(p::AbstractPlatform, , GCC_builds::Vector{GCCBuild})</code></pre><p>Returns the closest matching GCC version number for the given particular platform, from the given set of options.  The compiler ABI and the microarchitecture of the platform will be taken into account.  If no match is found, returns an empty list.</p><p>This method assumes that the compiler ABI of the platform represents a platform that binaries will be run on, and thus versions are always rounded down; e.g. if the platform supports a <code>libstdc++</code> version that corresponds to <code>GCC 5.1.0</code>, but the only GCC versions available to be picked from are <code>4.8.5</code> and <code>5.2.0</code>, it will return <code>4.8.5</code>, as binaries compiled with that version will run on this platform, whereas binaries compiled with <code>5.2.0</code> may not.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.generate_compiler_wrappers!-Tuple{AbstractPlatform}" href="#BinaryBuilderBase.generate_compiler_wrappers!-Tuple{AbstractPlatform}"><code>BinaryBuilderBase.generate_compiler_wrappers!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_compiler_wrappers!(platform::AbstractPlatform; bin_path::AbstractString,
                            host_platform::AbstractPlatform = Platform(&quot;x86_64&quot;, &quot;linux&quot;; libc = &quot;musl&quot;, cxxstring_abi = &quot;cxx11&quot;),
                            compilers::Vector{Symbol} = [:c],
                            allow_unsafe_flags::Bool = false,
                            lock_microarchitecture::Bool = true)</code></pre><p>We generate a set of compiler wrapper scripts within our build environment to force all build systems to honor the necessary sets of compiler flags to build for our systems. Note that while <code>platform_envs()</code> sets many environment variables, those values are intended to be optional/overridable.  These values, while still overridable by directly invoking a compiler binary directly (e.g. /opt/{target}/bin/{target}-gcc), are much more difficult to override, as the flags embedded in these wrappers are absolutely necessary, and even simple programs will not compile without them.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.generate_per_uid_squashfs" href="#BinaryBuilderBase.generate_per_uid_squashfs"><code>BinaryBuilderBase.generate_per_uid_squashfs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generate_per_uid_squashfs(cs, new_uid = getuid())</code></pre><p>In order for the sandbox to work well, we need to have the uids of the squashfs images match the uid of the current unprivileged user.  Unfortunately there is no mount-time option to do this for us.  Fortunately, squashfs is simple enough that if the ID table is uncompressed, we can just manually patch the uids to be what we need.  This function performs this operation, by rewriting all UIDs and GIDs to the given <code>new_uid</code> (which defaults to the current user&#39;s UID).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.get_concrete_platform-Tuple{AbstractPlatform}" href="#BinaryBuilderBase.get_concrete_platform-Tuple{AbstractPlatform}"><code>BinaryBuilderBase.get_concrete_platform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_concrete_platform(platform::AbstractPlatform;
                      preferred_gcc_version = nothing,
                      preferred_llvm_version = nothing,
                      compilers = nothing)</code></pre><p>Return the concrete platform for the given <code>platform</code> based on the GCC compiler ABI.  The set of shards is chosen by the keyword arguments (see <a href="#BinaryBuilderBase.choose_shards-Tuple{AbstractPlatform}"><code>choose_shards</code></a>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.get_concrete_platform-Tuple{Platform, Vector{CompilerShard}}" href="#BinaryBuilderBase.get_concrete_platform-Tuple{Platform, Vector{CompilerShard}}"><code>BinaryBuilderBase.get_concrete_platform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_concrete_platform(platform::Platform, shards::Vector{CompilerShard})</code></pre><p>Return the concrete platform for the given <code>platform</code> based on the GCC compiler ABI in the <code>shards</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.getgid-Tuple{}" href="#BinaryBuilderBase.getgid-Tuple{}"><code>BinaryBuilderBase.getgid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getgid()</code></pre><p>Wrapper around libc&#39;s <code>getgid()</code> function</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.getuid-Tuple{}" href="#BinaryBuilderBase.getuid-Tuple{}"><code>BinaryBuilderBase.getuid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getuid()</code></pre><p>Wrapper around libc&#39;s <code>getuid()</code> function</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.import_docker_image-Tuple{CompilerShard, String}" href="#BinaryBuilderBase.import_docker_image-Tuple{CompilerShard, String}"><code>BinaryBuilderBase.import_docker_image</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">import_docker_image(rootfs::CompilerShard; verbose::Bool = false)</code></pre><p>Checks to see if the given rootfs has been imported into docker yet; if it hasn&#39;t, then do so so that we can run things like:</p><pre><code class="language-none">docker run -ti binarybuilder_rootfs:v2018.08.27 /bin/bash</code></pre><p>Which, after all, is the foundation upon which this whole doodad is built.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.includedir-Tuple{Prefix}" href="#BinaryBuilderBase.includedir-Tuple{Prefix}"><code>BinaryBuilderBase.includedir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">includedir(prefix::Prefix)</code></pre><p>Returns the include directory for the given <code>prefix</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_build_dependency" href="#BinaryBuilderBase.is_build_dependency"><code>BinaryBuilderBase.is_build_dependency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_build_dependency(dep::AbstractDependency) -&gt; Bool</code></pre><p>Return whether <code>dep</code> is a build-time dependency or not.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_ecryptfs-Tuple{AbstractString}" href="#BinaryBuilderBase.is_ecryptfs-Tuple{AbstractString}"><code>BinaryBuilderBase.is_ecryptfs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_ecryptfs(path::AbstractString; verbose::Bool=false)</code></pre><p>Checks to see if the given <code>path</code> (or any parent directory) is placed upon an <code>ecryptfs</code> mount.  This is known not to work on current kernels, see this bug for more details: https://bugzilla.kernel.org/show_bug.cgi?id=197603</p><p>This method returns whether it is encrypted or not, and what mountpoint it used to make that decision.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_host_dependency" href="#BinaryBuilderBase.is_host_dependency"><code>BinaryBuilderBase.is_host_dependency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_host_dependency(dep::AbstractDependency) -&gt; Bool</code></pre><p>Return whether <code>dep</code> is a dependency of the host platform or not.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_mounted-Tuple{CompilerShard, AbstractString}" href="#BinaryBuilderBase.is_mounted-Tuple{CompilerShard, AbstractString}"><code>BinaryBuilderBase.is_mounted</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_mounted(cs::CompilerShard, build_prefix::String)</code></pre><p>Return true if the given shard is mounted.  Uses <code>run()</code> so will error out if something goes awry.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_runtime_dependency" href="#BinaryBuilderBase.is_runtime_dependency"><code>BinaryBuilderBase.is_runtime_dependency</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_runtime_dependency(dep::AbstractDependency) -&gt; Bool</code></pre><p>Return whether <code>dep</code> is a runtime dependency or not.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.is_target_dependency-Tuple{AbstractDependency}" href="#BinaryBuilderBase.is_target_dependency-Tuple{AbstractDependency}"><code>BinaryBuilderBase.is_target_dependency</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_target_dependency(dep::AbstractDependency) -&gt; Bool</code></pre><p>Return whether <code>dep</code> is a dependency of the target platform or not.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.libdirs" href="#BinaryBuilderBase.libdirs"><code>BinaryBuilderBase.libdirs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">libdirs(prefix::Prefix, platform = HostPlatform())</code></pre><p>Returns the library directories for the given <code>prefix</code> (note that this differs between unix systems and windows systems, and between 32- and 64-bit systems).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.locate-Tuple{ExecutableProduct, Prefix}" href="#BinaryBuilderBase.locate-Tuple{ExecutableProduct, Prefix}"><code>BinaryBuilderBase.locate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">locate(ep::ExecutableProduct, prefix::Prefix;
       platform::AbstractPlatform = HostPlatform(),
       verbose::Bool = false,
       isolate::Bool = false)</code></pre><p>If the given executable file exists and is executable, return its path.</p><p>On all platforms, an <a href="#BinaryBuilderBase.ExecutableProduct"><code>ExecutableProduct</code></a> checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set. On Windows platforms, it will check that the file ends with &quot;.exe&quot;, (adding it on automatically, if it is not already present).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.locate-Tuple{FileProduct, Prefix}" href="#BinaryBuilderBase.locate-Tuple{FileProduct, Prefix}"><code>BinaryBuilderBase.locate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">locate(fp::FileProduct, prefix::Prefix;
       platform::AbstractPlatform = HostPlatform(),
       verbose::Bool = false,
       isolate::Bool = false)</code></pre><p>If the given file exists, return its path.  The <code>platform</code> and <code>isolate</code> arguments are is ignored here, but included for uniformity.  For ease of use, we support a limited number of custom variable expansions such as <code>${target}</code>, and <code>${nbits}</code>, so that the detection of files within target-specific folders named things like <code>/lib32/i686-linux-musl</code> is simpler.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.locate-Tuple{LibraryProduct, Prefix}" href="#BinaryBuilderBase.locate-Tuple{LibraryProduct, Prefix}"><code>BinaryBuilderBase.locate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">locate(lp::LibraryProduct, prefix::Prefix;
       verbose::Bool = false,
       platform::AbstractPlatform = HostPlatform())</code></pre><p>If the given library exists (under any reasonable name) and is <code>dlopen()</code>able, (assuming it was built for the current platform) return its location.  Note that the <code>dlopen()</code> test is only run if the current platform matches the given <code>platform</code> keyword argument, as cross-compiled libraries cannot be <code>dlopen()</code>ed on foreign platforms.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.logdir-Tuple{Prefix}" href="#BinaryBuilderBase.logdir-Tuple{Prefix}"><code>BinaryBuilderBase.logdir</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">logdir(prefix::Prefix)</code></pre><p>Returns the logs directory for the given <code>prefix</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.macos_sdk_already_installed-Tuple{}" href="#BinaryBuilderBase.macos_sdk_already_installed-Tuple{}"><code>BinaryBuilderBase.macos_sdk_already_installed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">macos_sdk_already_installed()</code></pre><p>Returns <code>true</code> if any piece of the MacOS SDK is already installed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.map_target-Tuple{CompilerShard}" href="#BinaryBuilderBase.map_target-Tuple{CompilerShard}"><code>BinaryBuilderBase.map_target</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">map_target(cs::CompilerShard)</code></pre><p>Return the location this compiler shard should be mounted at.  We basically analyze the name and platform of this shard and return a path based on that.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.mount-Tuple{CompilerShard, AbstractString}" href="#BinaryBuilderBase.mount-Tuple{CompilerShard, AbstractString}"><code>BinaryBuilderBase.mount</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mount(cs::CompilerShard, build_prefix::String)</code></pre><p>Mount a compiler shard, if possible.  Uses <code>run()</code> so will error out if something goes awry.  Note that this function only does something when using a <code>.squashfs</code> shard, with a UserNS or Docker runner, on Linux. All other combinations of shard archive type, runner and platform result in a no-op from this function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.package-Tuple{Prefix, AbstractString, VersionNumber}" href="#BinaryBuilderBase.package-Tuple{Prefix, AbstractString, VersionNumber}"><code>BinaryBuilderBase.package</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">package(prefix::Prefix, output_base::AbstractString,
        version::VersionNumber;
        platform::AbstractPlatform = HostPlatform(),
        verbose::Bool = false, force::Bool = false)</code></pre><p>Build a tarball of the <code>prefix</code>, storing the tarball at <code>output_base</code>, appending a version number, a platform-dependent suffix and a file extension. If no platform is given, defaults to current platform. Returns the full path to, the SHA256 hash and the git tree SHA1 of the generated tarball.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.platform_envs-Tuple{AbstractPlatform, AbstractString}" href="#BinaryBuilderBase.platform_envs-Tuple{AbstractPlatform, AbstractString}"><code>BinaryBuilderBase.platform_envs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">platform_envs(platform::AbstractPlatform)</code></pre><p>Given a <code>platform</code>, generate a <code>Dict</code> mapping representing all the environment variables to be set within the build environment to force compiles toward the defined target architecture.  Examples of things set are <code>PATH</code>, <code>CC</code>, <code>RANLIB</code>, as well as nonstandard things like <code>target</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.platform_exeext-Tuple{AbstractPlatform}" href="#BinaryBuilderBase.platform_exeext-Tuple{AbstractPlatform}"><code>BinaryBuilderBase.platform_exeext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">platform_exeext(p::AbstractPlatform)</code></pre><p>Get the executable extension for the given Platform.  Includes the leading <code>.</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.preferred_cxxstring_abi-Tuple{AbstractPlatform, CompilerShard}" href="#BinaryBuilderBase.preferred_cxxstring_abi-Tuple{AbstractPlatform, CompilerShard}"><code>BinaryBuilderBase.preferred_cxxstring_abi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">preferred_cxxstring_abi(platform::AbstractPlatform, shard::CompilerShard;
                        gcc_builds::Vector{GCCBuild} = available_gcc_builds)</code></pre><p>Return the C++ string ABI preferred by the given platform or GCCBootstrap shard.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.preferred_libgfortran_version-Tuple{AbstractPlatform, CompilerShard}" href="#BinaryBuilderBase.preferred_libgfortran_version-Tuple{AbstractPlatform, CompilerShard}"><code>BinaryBuilderBase.preferred_libgfortran_version</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">preferred_libgfortran_version(platform::AbstractPlatform, shard::CompilerShard;
                              gcc_builds::Vector{GCCBuild} = available_gcc_builds)</code></pre><p>Return the libgfortran version preferred by the given platform or GCCBootstrap shard.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.runshell" href="#BinaryBuilderBase.runshell"><code>BinaryBuilderBase.runshell</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">runshell(platform::AbstractPlatform = HostPlatform())</code></pre><p>Launch an interactive shell session within the user namespace, with environment setup to target the given <code>platform</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.satisfied-Tuple{Product, Prefix}" href="#BinaryBuilderBase.satisfied-Tuple{Product, Prefix}"><code>BinaryBuilderBase.satisfied</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">satisfied(p::Product;
          platform::AbstractPlatform = HostPlatform(),
          verbose::Bool = false,
          isolate::Bool = false)</code></pre><p>Given a <a href="#BinaryBuilderBase.Product"><code>Product</code></a>, return <code>true</code> if that <code>Product</code> is satisfied, e.g. whether a file exists that matches all criteria setup for that <code>Product</code>. If <code>isolate</code> is set to <code>true</code>, will isolate all checks from the main Julia process in the event that <code>dlopen()</code>&#39;ing a library might cause issues.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.setup_dependencies-Tuple{Prefix, Vector{Pkg.Types.PackageSpec}, AbstractPlatform}" href="#BinaryBuilderBase.setup_dependencies-Tuple{Prefix, Vector{Pkg.Types.PackageSpec}, AbstractPlatform}"><code>BinaryBuilderBase.setup_dependencies</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setup_dependencies(prefix::Prefix, dependencies::Vector{PackageSpec}, platform::AbstractPlatform; verbose::Bool = false)</code></pre><p>Given a list of JLL package specifiers, install their artifacts into the build prefix. The artifacts are installed into the global artifact store, then copied into a temporary location, then finally symlinked into the build prefix.  This allows us to (a) save download bandwidth by not downloading the same artifacts over and over again, (b) maintain separation in the event of catastrophic containment failure, avoiding hosing the main system if a build script decides to try to modify the dependent artifact files, and (c) keeping a record of what files are a part of dependencies as opposed to the package being built, in the form of symlinks to a specific artifacts directory.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.setup_workspace" href="#BinaryBuilderBase.setup_workspace"><code>BinaryBuilderBase.setup_workspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setup_workspace(build_path::String, sources::Vector{SetupSource};
                verbose::Bool = false)</code></pre><p>Sets up a workspace within <code>build_path</code>, creating the directory structure needed by further steps, unpacking the source within <code>build_path</code>, and defining the environment variables that will be defined within the sandbox environment.</p><p>This method returns the <code>Prefix</code> to install things into, and the runner that can be used to launch commands within this workspace.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.shard_mappings-Tuple{Vector{CompilerShard}}" href="#BinaryBuilderBase.shard_mappings-Tuple{Vector{CompilerShard}}"><code>BinaryBuilderBase.shard_mappings</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shard_mappings(shards::Vector{CompilerShard})</code></pre><p>Return the default mappings for a set of compiler shards</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.shard_path-Tuple{CompilerShard}" href="#BinaryBuilderBase.shard_path-Tuple{CompilerShard}"><code>BinaryBuilderBase.shard_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shard_path(cs::CompilerShard)</code></pre><p>Return the path to this shard on-disk; for unpacked shards, this is a directory. For squashfs shards, this is a file.  This will not cause a shard to be downloaded.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.supported_platforms-Tuple{}" href="#BinaryBuilderBase.supported_platforms-Tuple{}"><code>BinaryBuilderBase.supported_platforms</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">supported_platforms(;exclude::Union{Vector{&lt;:Platform},Function}=x-&gt;false)</code></pre><p>Return the list of supported platforms as an array of <code>Platform</code>s.  These are the platforms we officially support building for, if you see a mapping in <code>get_shard_hash()</code> that isn&#39;t represented here, it&#39;s probably because that platform is still considered &quot;in beta&quot;.</p><p>Platforms can be excluded from the list by specifying an array of platforms to <code>exclude</code> i.e. <code>supported_platforms(exclude=[Platform(&quot;i686&quot;, &quot;windows&quot;), Platform(&quot;x86_64&quot;, &quot;windows&quot;)])</code> or a function that returns true for exclusions i.e.</p><pre><code class="language-none">supported_platforms(exclude=Sys.islinux)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.temp_prefix-Tuple{Function}" href="#BinaryBuilderBase.temp_prefix-Tuple{Function}"><code>BinaryBuilderBase.temp_prefix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">temp_prefix(func::Function)</code></pre><p>Create a temporary prefix, passing the prefix into the user-defined function so that build/packaging operations can occur within the temporary prefix, which is then cleaned up after all operations are finished.  If the path provided exists already, it will be deleted.</p><p>Usage example:</p><pre><code class="language-none">out_path = abspath(&quot;./libfoo&quot;)
temp_prefix() do p
    # &lt;insert build steps here&gt;

    # tarball up the built package
    tarball_path, tarball_hash = package(p, out_path)
end</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.uname-Tuple{}" href="#BinaryBuilderBase.uname-Tuple{}"><code>BinaryBuilderBase.uname</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">uname()</code></pre><p>On Linux systems, return the strings returned by the <code>uname()</code> function in libc</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.unmount-Tuple{CompilerShard, String}" href="#BinaryBuilderBase.unmount-Tuple{CompilerShard, String}"><code>BinaryBuilderBase.unmount</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unmount(cs::CompilerShard, build_prefix::String)</code></pre><p>Unmount a compiler shard from a given build prefix, if possible.  Uses <code>run()</code> so will error out if something goes awry.  Note that this function only does something when using a squashfs shard on Linux.  All other combinations of shard archive type and platform result in a no-op.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.variable_name-Tuple{Product}" href="#BinaryBuilderBase.variable_name-Tuple{Product}"><code>BinaryBuilderBase.variable_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">variable_name(p::Product)</code></pre><p>Return the variable name associated with this <a href="#BinaryBuilderBase.Product"><code>Product</code></a> as a string</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilderBase.versioninfo-Tuple{}" href="#BinaryBuilderBase.versioninfo-Tuple{}"><code>BinaryBuilderBase.versioninfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">versioninfo()</code></pre><p>Helper function to print out some debugging information</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.autobuild-Tuple{AbstractString, AbstractString, VersionNumber, Vector{var&quot;#s224&quot;} where var&quot;#s224&quot;&lt;:AbstractSource, AbstractString, Vector{T} where T, Vector{var&quot;#s223&quot;} where var&quot;#s223&quot;&lt;:Product, Vector{var&quot;#s222&quot;} where var&quot;#s222&quot;&lt;:AbstractDependency}" href="#BinaryBuilder.autobuild-Tuple{AbstractString, AbstractString, VersionNumber, Vector{var&quot;#s224&quot;} where var&quot;#s224&quot;&lt;:AbstractSource, AbstractString, Vector{T} where T, Vector{var&quot;#s223&quot;} where var&quot;#s223&quot;&lt;:Product, Vector{var&quot;#s222&quot;} where var&quot;#s222&quot;&lt;:AbstractDependency}"><code>BinaryBuilder.autobuild</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">autobuild(dir::AbstractString, src_name::AbstractString,
          src_version::VersionNumber, sources::Vector,
          script::AbstractString, platforms::Vector,
          products::Vector, dependencies::Vector;
          verbose = false, debug = false,
          skip_audit = false, ignore_audit_errors = true,
          autofix = true, code_dir = nothing,
          meta_json_file = nothing, require_license = true, kwargs...)</code></pre><p>Runs the boiler plate code to download, build, and package a source package for a list of platforms.  This method takes a veritable truckload of arguments, here are the relevant actors, broken down in brief:</p><ul><li><p><code>dir</code>: the root of the build; products will be placed within <code>dir</code>/products,  and mountpoints will be placed within <code>dir</code>/build/.</p></li><li><p><code>src_name</code>: the name of the source package being built and will set the name  of the built tarballs.</p></li><li><p><code>src_version</code>: the version of the source package.</p></li><li><p><code>platforms</code>: a list of platforms to build for.</p></li><li><p><code>sources</code>: a vector of all sources to download and unpack before building begins, as <a href="#BinaryBuilderBase.AbstractSource"><code>AbstractSource</code></a>s.</p></li><li><p><code>script</code>: a string representing a shell script to run as the build.</p></li><li><p><code>products</code>: the list of <code>Product</code>s which shall be built.</p></li><li><p><code>dependencies</code>: a vector of JLL dependency packages as <a href="#BinaryBuilderBase.AbstractDependency"><code>AbstractDependency</code></a> that should be installed before building begins.</p></li><li><p><code>verbose</code>: Enable verbose mode.  What did you expect?</p></li><li><p><code>debug</code>: cause a failed build to drop into an interactive shell so that  the build can be inspected easily.</p></li><li><p><code>skip_audit</code>: disable the typical audit that occurs at the end of a build.</p></li><li><p><code>ignore_audit_errors</code>: do not kill a build even if a problem is found.</p></li><li><p><code>autofix</code>: give <code>BinaryBuilder</code> permission to automatically fix issues it  finds during audit passes.  Highly recommended.</p></li><li><p><code>code_dir</code>: sets where autogenerated JLL packages will be put.</p></li><li><p><code>require_license</code> enables a special audit pass that requires licenses to be  installed by all packages.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/AutoBuild.jl#L572-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.get_compilers_versions-Tuple{}" href="#BinaryBuilder.get_compilers_versions-Tuple{}"><code>BinaryBuilder.get_compilers_versions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_compilers_versions(; compilers = [:c])</code></pre><p>Return the script string that is used to print the versions of the given <code>compilers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/AutoBuild.jl#L354-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.BinaryPlatforms.detect_cxxstring_abi-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}" href="#Base.BinaryPlatforms.detect_cxxstring_abi-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}"><code>Base.BinaryPlatforms.detect_cxxstring_abi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">detect_cxxstring_abi(oh::ObjectHandle, platform::AbstractPlatform)</code></pre><p>Given an ObjectFile, examine its symbols to discover which (if any) C++11 std::string ABI it&#39;s using.  We do this by scanning the list of exported symbols, triggering off of instances of <code>St7__cxx11</code> or <code>_ZNSs</code> to give evidence toward a constraint on <code>cxx11</code>, <code>cxx03</code> or neither.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/auditor/compiler_abi.jl#L182-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.BinaryPlatforms.detect_libstdcxx_version-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}" href="#Base.BinaryPlatforms.detect_libstdcxx_version-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}"><code>Base.BinaryPlatforms.detect_libstdcxx_version</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">detect_libstdcxx_version(oh::ObjectHandle, platform::AbstractPlatform)</code></pre><p>Given an ObjectFile, examine its dynamic linkage to discover which (if any) <code>libgfortran</code> it&#39;s linked against.  The major SOVERSION will determine which GCC version we&#39;re restricted to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/auditor/compiler_abi.jl#L106-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.analyze_instruction_set-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}" href="#BinaryBuilder.Auditor.analyze_instruction_set-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}"><code>BinaryBuilder.Auditor.analyze_instruction_set</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">analyze_instruction_set(oh::ObjectHandle, platform::AbstractPlatform; verbose::Bool = false)</code></pre><p>Analyze the instructions within the binary located at the given path for which minimum instruction set it requires, taking note of groups of instruction sets used such as <code>avx</code>, <code>sse4.2</code>, <code>i486</code>, etc....</p><p>Some binary files (such as libopenblas) contain multiple versions of functions, internally determining which version to call by using the <code>cpuid</code> instruction to determine processor support.  In an effort to detect this, we make note of any usage of the <code>cpuid</code> instruction, disabling our minimum instruction set calculations if such an instruction is found, and notifying the user of this if <code>verbose</code> is set to <code>true</code>.</p><p>Note that this function only really makes sense for x86/x64 binaries.  Don&#39;t run this on armv7l, aarch64, ppc64le etc... binaries and expect it to work.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/auditor/instruction_set.jl#L122-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.audit" href="#BinaryBuilder.Auditor.audit"><code>BinaryBuilder.Auditor.audit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">audit(prefix::Prefix; platform::AbstractPlatform = HostPlatform();
                      verbose::Bool = false,
                      silent::Bool = false,
                      autofix::Bool = false,
                      require_license::Bool = true)</code></pre><p>Audits a prefix to attempt to find deployability issues with the binary objects that have been installed within.  This auditing will check for relocatability issues such as dependencies on libraries outside of the current <code>prefix</code>, usage of advanced instruction sets such as AVX2 that may not be usable on many platforms, linkage against newer glibc symbols, etc...</p><p>This method is still a work in progress, only some of the above list is actually implemented, be sure to actually inspect <code>Auditor.jl</code> to see what is and is not currently in the realm of fantasy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/Auditor.jl#L26-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.check_license" href="#BinaryBuilder.Auditor.check_license"><code>BinaryBuilder.Auditor.check_license</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">check_license(prefix, src_name; verbose::Bool = false,, silent::Bool = false)</code></pre><p>Check that there are license files for the project called <code>src_name</code> in the <code>prefix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/Auditor.jl#L475-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.collapse_symlinks-Tuple{Vector{String}}" href="#BinaryBuilder.Auditor.collapse_symlinks-Tuple{Vector{String}}"><code>BinaryBuilder.Auditor.collapse_symlinks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">collapse_symlinks(files::Vector{String})</code></pre><p>Given a list of files, prune those that are symlinks pointing to other files within the list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/Auditor.jl#L448-L453">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.collect_files" href="#BinaryBuilder.Auditor.collect_files"><code>BinaryBuilder.Auditor.collect_files</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collect_files(path::AbstractString, predicate::Function = f -&gt; true)</code></pre><p>Find all files that satisfy <code>predicate()</code> when the full path to that file is passed in, returning the list of file paths.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/Auditor.jl#L408-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.compatible_marchs-Tuple{AbstractPlatform}" href="#BinaryBuilder.Auditor.compatible_marchs-Tuple{AbstractPlatform}"><code>BinaryBuilder.Auditor.compatible_marchs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compatible_marchs(p::AbstractPlatform)</code></pre><p>Return a (sorted) list of compatible microarchitectures, starting from the most compatible to the most highly specialized.  If no microarchitecture is specified within <code>p</code>, returns the most generic microarchitecture possible for the given architecture.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/Auditor.jl#L242-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.detect_libgfortran_version-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}" href="#BinaryBuilder.Auditor.detect_libgfortran_version-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}"><code>BinaryBuilder.Auditor.detect_libgfortran_version</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">detect_libgfortran_version(oh::ObjectHandle, platform::AbstractPlatform)</code></pre><p>Given an ObjectFile, examine its dynamic linkage to discover which (if any) <code>libgfortran</code> it&#39;s linked against.  The major SOVERSION will determine which GCC version we&#39;re restricted to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/auditor/compiler_abi.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.instruction_mnemonics-Tuple{AbstractString, AbstractPlatform}" href="#BinaryBuilder.Auditor.instruction_mnemonics-Tuple{AbstractString, AbstractPlatform}"><code>BinaryBuilder.Auditor.instruction_mnemonics</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">instruction_mnemonics(path::AbstractString, platform::AbstractPlatform)</code></pre><p>Dump a binary object with <code>objdump</code>, returning a list of instruction mnemonics for further analysis with <code>analyze_instruction_set()</code>.</p><p>Note that this function only really makes sense for x86/x64 binaries.  Don&#39;t run this on armv7l, aarch64, ppc64le etc... binaries and expect it to work.</p><p>This function returns the list of mnemonics as well as the counts of each, binned by the mapping defined within <code>instruction_categories</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/auditor/instruction_set.jl#L13-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.is_for_platform-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}" href="#BinaryBuilder.Auditor.is_for_platform-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}"><code>BinaryBuilder.Auditor.is_for_platform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_for_platform(h::ObjectHandle, platform::AbstractPlatform)</code></pre><p>Returns <code>true</code> if the given <code>ObjectHandle</code> refers to an object of the given <code>platform</code>; E.g. if the given <code>platform</code> is for AArch64 Linux, then <code>h</code> must be an <code>ELFHandle</code> with <code>h.header.e_machine</code> set to <code>ELF.EM_AARCH64</code>.</p><p>In particular, this method and <a href="#BinaryBuilder.Auditor.platform_for_object-Tuple{ObjectFile.ObjectHandle}"><code>platform_for_object()</code></a> both exist because the latter is not smart enough to deal with <code>:glibc</code> and <code>:musl</code> yet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/auditor/dynamic_linkage.jl#L83-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.is_troublesome_library_link-Tuple{AbstractString, AbstractPlatform}" href="#BinaryBuilder.Auditor.is_troublesome_library_link-Tuple{AbstractString, AbstractPlatform}"><code>BinaryBuilder.Auditor.is_troublesome_library_link</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_troublesome_library_link(libname::AbstractString, platform::AbstractPlatform)</code></pre><p>Return <code>true</code> if depending on <code>libname</code> is known to cause problems at runtime, <code>false</code> otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/auditor/dynamic_linkage.jl#L451-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.minimum_march-Tuple{Dict, AbstractPlatform}" href="#BinaryBuilder.Auditor.minimum_march-Tuple{Dict, AbstractPlatform}"><code>BinaryBuilder.Auditor.minimum_march</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minimum_march(counts::Dict, p::AbstractPlatform)</code></pre><p>This function returns the minimum instruction set required, depending on whether the object file being pointed to is a 32-bit or 64-bit one:</p><ul><li><p>For 32-bit object files, this returns one of [&quot;i686&quot;, &quot;prescott&quot;]</p></li><li><p>For 64-bit object files, this returns one of [&quot;x86_64&quot;, &quot;avx&quot;, &quot;avx2&quot;, &quot;avx512&quot;]</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/auditor/instruction_set.jl#L75-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.platform_for_object-Tuple{ObjectFile.ObjectHandle}" href="#BinaryBuilder.Auditor.platform_for_object-Tuple{ObjectFile.ObjectHandle}"><code>BinaryBuilder.Auditor.platform_for_object</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">platform_for_object(oh::ObjectHandle)</code></pre><p>Returns the platform the given <code>ObjectHandle</code> should run on.  E.g. if the given <code>ObjectHandle</code> is an <code>x86_64</code> Linux ELF object, this function will return <code>Platform(&quot;x86_64&quot;, &quot;linux&quot;)</code>.  This function does not yet distinguish between different libc&#39;s such as <code>:glibc</code> and <code>:musl</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/auditor/dynamic_linkage.jl#L4-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.symlink_soname_lib-Tuple{AbstractString}" href="#BinaryBuilder.Auditor.symlink_soname_lib-Tuple{AbstractString}"><code>BinaryBuilder.Auditor.symlink_soname_lib</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">symlink_soname_lib(path::AbstractString)</code></pre><p>We require that all shared libraries are accessible on disk through their SONAME (if it exists).  While this is almost always true in practice, it doesn&#39;t hurt to make doubly sure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/auditor/soname_matching.jl#L101-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.translate_symlinks-Tuple{AbstractString}" href="#BinaryBuilder.Auditor.translate_symlinks-Tuple{AbstractString}"><code>BinaryBuilder.Auditor.translate_symlinks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translate_symlinks(root::AbstractString; verbose::Bool=false)</code></pre><p>Walks through the root directory given within <code>root</code>, finding all symlinks that point to an absolute path within <code>root</code>, and rewriting them to be a relative symlink instead, increasing relocatability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/auditor/symlink_translator.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.update_linkage-Tuple{Prefix, AbstractPlatform, AbstractString, Any, Any}" href="#BinaryBuilder.Auditor.update_linkage-Tuple{Prefix, AbstractPlatform, AbstractString, Any, Any}"><code>BinaryBuilder.Auditor.update_linkage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_linkage(prefix::Prefix, platform::AbstractPlatform, path::AbstractString,
               old_libpath, new_libpath; verbose::Bool = false)</code></pre><p>Given a binary object located at <code>path</code> within <code>prefix</code>, update its dynamic linkage to point to <code>new_libpath</code> instead of <code>old_libpath</code>.  This is done using a tool within the cross-compilation environment such as <code>install_name_tool</code> on MacOS or <code>patchelf</code> on Linux.  Windows platforms are completely skipped, as they do not encode paths or RPaths within their executables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/auditor/dynamic_linkage.jl#L353-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Auditor.warn_deadlinks-Tuple{AbstractString}" href="#BinaryBuilder.Auditor.warn_deadlinks-Tuple{AbstractString}"><code>BinaryBuilder.Auditor.warn_deadlinks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">warn_deadlinks(root::AbstractString)</code></pre><p>Walks through the given <code>root</code> directory, finding broken symlinks and warning the user about them.  This is used to catch instances such as a build recipe copying a symlink that points to a dependency; by doing so, it implicitly breaks relocatability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/auditor/symlink_translator.jl#L22-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.canonicalize_file_url-Tuple{Any}" href="#BinaryBuilder.Wizard.canonicalize_file_url-Tuple{Any}"><code>BinaryBuilder.Wizard.canonicalize_file_url</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Canonicalize URL to a file within a GitHub repo</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/obtain_source.jl#L22-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.canonicalize_source_url-Tuple{Any}" href="#BinaryBuilder.Wizard.canonicalize_source_url-Tuple{Any}"><code>BinaryBuilder.Wizard.canonicalize_source_url</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Canonicalize a GitHub repository URL</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/obtain_source.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.change_script!-Tuple{Any, Any}" href="#BinaryBuilder.Wizard.change_script!-Tuple{Any, Any}"><code>BinaryBuilder.Wizard.change_script!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Change the script. This will invalidate all platforms to make sure we later
verify that they still build with the new script.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/utils.jl#L204-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.clone-Tuple{String, String}" href="#BinaryBuilder.Wizard.clone-Tuple{String, String}"><code>BinaryBuilder.Wizard.clone</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clone(url::String, source_path::String)</code></pre><p>Clone a git repository hosted at <code>url</code> into <code>source_path</code>, with a progress bar displayed to stdout.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/obtain_source.jl#L62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.download_source-Tuple{BinaryBuilder.Wizard.WizardState}" href="#BinaryBuilder.Wizard.download_source-Tuple{BinaryBuilder.Wizard.WizardState}"><code>BinaryBuilder.Wizard.download_source</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">download_source(state::WizardState)</code></pre><p>Ask the user where the source code is coming from, then download and record the relevant parameters, returning the source <code>url</code>, the local <code>path</code> it is stored at after download, and a <code>hash</code> identifying the version of the code. In the case of a <code>git</code> source URL, the <code>hash</code> will be a git treeish identifying the exact commit used to build the code, in the case of a tarball, it is the <code>sha256</code> hash of the tarball itself.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/obtain_source.jl#L86-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.edit_script-Tuple{BinaryBuilder.Wizard.WizardState, AbstractString}" href="#BinaryBuilder.Wizard.edit_script-Tuple{BinaryBuilder.Wizard.WizardState, AbstractString}"><code>BinaryBuilder.Wizard.edit_script</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">edit_script(state::WizardState, script::AbstractString)</code></pre><p>For consistency (and security), use the sandbox for editing a script, launching <code>vi</code> within an interactive session to edit a buildscript.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/utils.jl#L146-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.filter_object_files-Tuple{Any}" href="#BinaryBuilder.Wizard.filter_object_files-Tuple{Any}"><code>BinaryBuilder.Wizard.filter_object_files</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">filter_object_files(files)</code></pre><p>Given a list of files, filter out any that cannot be opened by <code>readmeta()</code> from <code>ObjectFile</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/utils.jl#L79-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.interactive_build-Tuple{BinaryBuilder.Wizard.WizardState, Prefix, Runner, AbstractString, AbstractPlatform}" href="#BinaryBuilder.Wizard.interactive_build-Tuple{BinaryBuilder.Wizard.WizardState, Prefix, Runner, AbstractString, AbstractPlatform}"><code>BinaryBuilder.Wizard.interactive_build</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interactive_build(state::WizardState, prefix::Prefix,
                  ur::Runner, build_path::AbstractString)

Runs the interactive shell for building, then captures bash history to save
reproducible steps for building this source. Shared between steps 3 and 5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/interactive_build.jl#L298-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.match_files-Tuple{BinaryBuilder.Wizard.WizardState, Prefix, AbstractPlatform, Vector{T} where T}" href="#BinaryBuilder.Wizard.match_files-Tuple{BinaryBuilder.Wizard.WizardState, Prefix, AbstractPlatform, Vector{T} where T}"><code>BinaryBuilder.Wizard.match_files</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">match_files(state::WizardState, prefix::Prefix,
            platform::AbstractPlatform, files::Vector; silent::Bool = false)</code></pre><p>Inspects all binary files within a prefix, matching them with a given list of <code>files</code>, complaining if there are any files that are not properly matched and returning the set of normalized names that were not matched, or an empty set if all names were properly matched.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/utils.jl#L108-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.normalize_name-Tuple{AbstractString}" href="#BinaryBuilder.Wizard.normalize_name-Tuple{AbstractString}"><code>BinaryBuilder.Wizard.normalize_name</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normalize_name(file::AbstractString)</code></pre><p>Given a filename, normalize it, stripping out extensions.  E.g. the file path <code>&quot;foo/libfoo.tar.gz&quot;</code> would get mapped to <code>&quot;libfoo&quot;</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/utils.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.pick_preferred_platform-Tuple{Any}" href="#BinaryBuilder.Wizard.pick_preferred_platform-Tuple{Any}"><code>BinaryBuilder.Wizard.pick_preferred_platform</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Pick the first platform for use to run on. We prefer Linux x86_64 because that&#39;s generally the host platform, so it&#39;s usually easiest. After that we go by the following preferences:</p><ul><li>OS (in order): Linux, Windows, OSX</li><li>Architecture: x86_64, i686, aarch64, powerpc64le, armv7l</li><li>The first remaining after this selection</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/interactive_build.jl#L460-L467">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.print_autoconf_hint-Tuple{BinaryBuilder.Wizard.WizardState}" href="#BinaryBuilder.Wizard.print_autoconf_hint-Tuple{BinaryBuilder.Wizard.WizardState}"><code>BinaryBuilder.Wizard.print_autoconf_hint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">print_autoconf_hint(state::WizardState)</code></pre><p>Print a hint for projects that use autoconf to have a good <code>./configure</code> line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/hints.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.provide_hints-Tuple{BinaryBuilder.Wizard.WizardState, AbstractString}" href="#BinaryBuilder.Wizard.provide_hints-Tuple{BinaryBuilder.Wizard.WizardState, AbstractString}"><code>BinaryBuilder.Wizard.provide_hints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">provide_hints(state::WizardState, path::AbstractString)</code></pre><p>Given an unpacked source directory, provide hints on how a user might go about building the binary bounty they so richly desire.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/hints.jl#L17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.step1-Tuple{BinaryBuilder.Wizard.WizardState}" href="#BinaryBuilder.Wizard.step1-Tuple{BinaryBuilder.Wizard.WizardState}"><code>BinaryBuilder.Wizard.step1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">step1(state::WizardState)</code></pre><p>It all starts with a single step, the unabashed ambition to leave your current stability and engage with the universe on a quest to create something new, beautiful and unforeseen.  It all ends with compiler errors.</p><p>This step selects the relevant platform(s) for the built binaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/obtain_source.jl#L184-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.step2-Tuple{BinaryBuilder.Wizard.WizardState}" href="#BinaryBuilder.Wizard.step2-Tuple{BinaryBuilder.Wizard.WizardState}"><code>BinaryBuilder.Wizard.step2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">step2(state::WizardState)</code></pre><p>This step obtains the source code to be built and required binary dependencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/obtain_source.jl#L409-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.step34-Tuple{BinaryBuilder.Wizard.WizardState}" href="#BinaryBuilder.Wizard.step34-Tuple{BinaryBuilder.Wizard.WizardState}"><code>BinaryBuilder.Wizard.step34</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">step34(state::WizardState)</code></pre><p>Starts initial build for Linux x86_64, which is our initial test target platform.  Sources that build properly for this platform continue on to attempt builds for more complex platforms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/interactive_build.jl#L487-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.step3_audit-Tuple{BinaryBuilder.Wizard.WizardState, AbstractPlatform, String}" href="#BinaryBuilder.Wizard.step3_audit-Tuple{BinaryBuilder.Wizard.WizardState, AbstractPlatform, String}"><code>BinaryBuilder.Wizard.step3_audit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">step3_audit(state::WizardState, platform::AbstractPlatform, prefix::Prefix)</code></pre><p>Audit the <code>prefix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/interactive_build.jl#L156-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.step3_interactive-Tuple{BinaryBuilder.Wizard.WizardState, Prefix, AbstractPlatform, Runner, AbstractString, Vector{String}}" href="#BinaryBuilder.Wizard.step3_interactive-Tuple{BinaryBuilder.Wizard.WizardState, Prefix, AbstractPlatform, Runner, AbstractString, Vector{String}}"><code>BinaryBuilder.Wizard.step3_interactive</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">step3_interactive(state::WizardState, prefix::Prefix, platform::AbstractPlatform,
                  ur::Runner, build_path::AbstractString)</code></pre><p>The interactive portion of step3, moving on to either rebuild with an edited script or proceed to step 4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/interactive_build.jl#L398-L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.step3_retry-Tuple{BinaryBuilder.Wizard.WizardState}" href="#BinaryBuilder.Wizard.step3_retry-Tuple{BinaryBuilder.Wizard.WizardState}"><code>BinaryBuilder.Wizard.step3_retry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">step3_retry(state::WizardState)</code></pre><p>Rebuilds the initial Linux x86_64 build after things like editing the script file manually, etc...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/interactive_build.jl#L422-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.step4-Tuple{BinaryBuilder.Wizard.WizardState, Runner, AbstractPlatform, AbstractString, Prefix}" href="#BinaryBuilder.Wizard.step4-Tuple{BinaryBuilder.Wizard.WizardState, Runner, AbstractPlatform, AbstractString, Prefix}"><code>BinaryBuilder.Wizard.step4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">step4(state::WizardState, ur::Runner, platform::AbstractPlatform,
      build_path::AbstractString, prefix::Prefix)</code></pre><p>The fourth step selects build products after the first build is done</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/interactive_build.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.with_gitcreds-Tuple{Any, AbstractString, AbstractString}" href="#BinaryBuilder.Wizard.with_gitcreds-Tuple{Any, AbstractString, AbstractString}"><code>BinaryBuilder.Wizard.with_gitcreds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">with_gitcreds(f, username::AbstractString, password::AbstractString)</code></pre><p>Calls <code>f</code> with an <code>LibGit2.UserPasswordCredential</code> object as an argument, constructed from the <code>username</code> and <code>password</code> values. <code>with_gitcreds</code> ensures that the credentials object gets properly shredded after it&#39;s no longer necessary. E.g.:</p><p><code>julia with_gitcreds(user, token) do creds     LibGit2.clone(&quot;https://github.com/foo/bar.git&quot;, &quot;bar&quot;; credentials=creds) end</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/utils.jl#L258-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.yggdrasil_build_tarballs_path-Tuple{Any}" href="#BinaryBuilder.Wizard.yggdrasil_build_tarballs_path-Tuple{Any}"><code>BinaryBuilder.Wizard.yggdrasil_build_tarballs_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">yggdrasil_build_tarballs_path(name::String)</code></pre><p>Return the relative path within an Yggdrasil clone where this project (given its name) would be stored.  This is useful for things like generating the <code>build_tarballs.jl</code> file and checking to see if it already exists, etc...</p><p>Note that we do not allow case-ambiguities within Yggdrasil, we check for this using the utility function <code>case_insensitive_file_exists(path)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/yggdrasil.jl#L24-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.yggdrasil_deploy" href="#BinaryBuilder.Wizard.yggdrasil_deploy"><code>BinaryBuilder.Wizard.yggdrasil_deploy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">yggdrasil_deploy(state::WizardState)</code></pre><p>Write out a WizardState to a <code>build_tarballs.jl</code> in an <code>Yggdrasil</code> clone, then open a pull request against <code>Yggdrasil</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/deploy.jl#L124-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.Wizard.yn_prompt" href="#BinaryBuilder.Wizard.yn_prompt"><code>BinaryBuilder.Wizard.yn_prompt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">yn_prompt(state::WizardState, question::AbstractString, default = :y)</code></pre><p>Perform a <code>[Y/n]</code> or <code>[y/N]</code> question loop, using <code>default</code> to choose between the prompt styles, and looping until a proper response (e.g. <code>&quot;y&quot;</code>, <code>&quot;yes&quot;</code>, <code>&quot;n&quot;</code> or <code>&quot;no&quot;</code>) is received.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/wizard/utils.jl#L179-L185">source</a></section></article><h2 id="Command-Line"><a class="docs-heading-anchor" href="#Command-Line">Command Line</a><a id="Command-Line-1"></a><a class="docs-heading-anchor-permalink" href="#Command-Line" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="BinaryBuilder.build_tarballs" href="#BinaryBuilder.build_tarballs"><code>BinaryBuilder.build_tarballs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_tarballs(ARGS, src_name, src_version, sources, script, platforms,
               products, dependencies; kwargs...)</code></pre><p>This should be the top-level function called from a <code>build_tarballs.jl</code> file. It takes in the information baked into a <code>build_tarballs.jl</code> file such as the <code>sources</code> to download, the <code>products</code> to build, etc... and will automatically download, build and package the tarballs, generating a <code>build.jl</code> file when appropriate.</p><p>Generally, <code>ARGS</code> should be the top-level Julia <code>ARGS</code> command-line arguments object.  <code>build_tarballs</code> does some rudimentary parsing of the arguments. To see what it can do, you can call it with <code>--help</code> in the <code>ARGS</code> or see the <a href="#Command-Line">Command Line</a> section in the manual.</p><p>The <code>kwargs</code> are passed on to <a href="#BinaryBuilder.autobuild-Tuple{AbstractString, AbstractString, VersionNumber, Vector{var&quot;#s224&quot;} where var&quot;#s224&quot;&lt;:AbstractSource, AbstractString, Vector{T} where T, Vector{var&quot;#s223&quot;} where var&quot;#s223&quot;&lt;:Product, Vector{var&quot;#s222&quot;} where var&quot;#s222&quot;&lt;:AbstractDependency}"><code>autobuild</code></a>, see there for a list of supported ones. A few additional keyword arguments are accept:</p><ul><li><p><code>julia_compat</code> can be set to a version string which is used to set the supported Julia version in the <code>[compat]</code> section of the <code>Project.toml</code> of the generated JLL package. The default value is <code>&quot;1.0&quot;</code>.</p></li><li><p><code>lazy_artifacts</code> sets whether the artifacts should be lazy.</p></li><li><p><code>init_block</code> may be set to a string containing Julia code; if present, this code will be inserted into the initialization path of the generated JLL package. This can for example be used to invoke an initialization API of a shared library.</p></li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>init_block</code> keyword argument is experimental and may be removed in a future version of this package. Please use it sparingly.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/8b4e44aab3a936eedec63f8dab6ad5cd3a48e9b0/src/AutoBuild.jl#L80-L113">source</a></section></article><p>The <a href="#BinaryBuilder.build_tarballs"><code>build_tarballs</code></a> function also parses command line arguments. The syntax is described in the <code>--help</code> output:</p><pre><code class="language-none">Usage: build_tarballs.jl [target1,target2,...] [--help]
                         [--verbose] [--debug]
                         [--deploy] [--deploy-bin] [--deploy-jll]
                         [--register] [--meta-json]

Options:
    targets             By default `build_tarballs.jl` will build a tarball
                        for every target within the `platforms` variable.
                        To override this, pass in a list of comma-separated
                        target triplets for each target to be built.  Note
                        that this can be used to build for platforms that
                        are not listed in the &#39;default list&#39; of platforms
                        in the build_tarballs.jl script.

    --verbose           This streams compiler output to stdout during the
                        build which can be very helpful for finding bugs.
                        Note that it is colorized if you pass the
                        --color=yes option to julia, see examples below.

    --debug=&lt;mode&gt;      This causes a failed build to drop into an
                        interactive shell for debugging purposes.  `&lt;mode&gt;`
                        can be one of `error`, `begin` or `end`.  `error`
                        drops you into the interactive shell only when there
                        is an error during the build, this is the default
                        when no mode is specified.  `begin` forces an error
                        at the beginning of the build, before any command in
                        the script is run.  `end` forces an error at the end
                        of the build script, useful to debug a successful
                        build for which the auditor would fail.

    --deploy=&lt;repo&gt;     Deploy binaries and JLL wrapper code to a github
                        release of an autogenerated repository.  Uses
                        `github.com/JuliaBinaryWrappers/&lt;name&gt;_jll.jl` by
                        default, unless `&lt;repo&gt;` is set, in which case it
                        should be set as `&lt;owner&gt;/&lt;name&gt;_jll.jl`.  Setting
                        this option is equivalent to setting `--deploy-bin`
                        and `--deploy-jll`.  If `&lt;repo&gt;` is set to &quot;local&quot;
                        then nothing will be uploaded, but JLL packages
                        will still be written out to `~/.julia/dev/`.

    --deploy-bin=&lt;repo&gt; Deploy just the built binaries

    --deploy-jll=&lt;repo&gt; Deploy just the JLL code wrappers

    --register=&lt;depot&gt;  Register into the given depot.  If no path is
                        given, defaults to `~/.julia`.  Registration
                        requires deployment of the JLL wrapper code, so
                        so using `--register` without `--deploy` or the
                        more specific `--deploy-jll` is an error.

    --meta-json         Output a JSON representation of the given build
                        instead of actually building.  Note that this can
                        (and often does) output multiple JSON objects for
                        multiple platforms, multi-stage builds, etc...

    --help              Print out this message.

Examples:
    julia --color=yes build_tarballs.jl --verbose
        This builds all tarballs, with colorized output.

    julia build_tarballs.jl x86_64-linux-gnu,i686-linux-gnu
        This builds two tarballs for the two platforms given, with a
        minimum of output messages.
</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tricksy_gotchas/">« Tricksy Gotchas</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 15 May 2021 23:26">Saturday 15 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
