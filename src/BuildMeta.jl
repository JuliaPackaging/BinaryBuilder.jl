using Test

export BuildMeta

const BUILD_HELP = (
    """
    Usage: build_tarballs.jl [target1,target2,...] [--help]
                             [--verbose] [--debug=mode]
                             [--deploy=repo] [--deploy-bin=repo] [--deploy-jll=repo]
                             [--register] [--meta-json]

    Options:
        targets             By default `build_tarballs.jl` will build a tarball for every
                            target within the `platforms` variable.  To override this,
                            pass in a list of comma-separated target triplets for each
                            target to be built.  Note that this can be used to build for
                            platforms that are not listed in the 'default list' of
                            platforms in the `build_tarballs.jl` script.

        --verbose           This streams compiler and setup code output to `stdout`
                            during the build, which can help track down issues in your
                            build script.

        --debug=<mode>      This causes a failed build to drop into an interactive shell
                            for debugging purposes.  `<mode>` can be one of:
                              - `error` drops you into the interactive shell only when
                                there is an error during the build, this is the default
                                when no mode is specified.
                              - `begin` stops the build at the beginning before any
                                command in the script is run.
                              - `end` stops the build at the end of the build script,
                                useful to inspect a successful build for which the
                                auditor or some other packaging step would fail.

        --deploy=<repo>     Deploy binaries and JLL wrapper code to a github release of
                            an autogenerated repository.  `repo` should be of the form
                            `"JuliaBinaryWrappers/Foo_jll.jl"`.  The default behavior
                            of deploying to the local `~/.julia/dev` directory only can
                            be explicitly requested by setting `<repo>` to `"local"`.
                            Note there is no way to _not_ deploy; a JLL package will
                            always be generated.  For testing, local deployment is
                            sufficient as the artifacts the generated JLL will reference
                            are already existent on the build machine, as they were just
                            built by BinaryBuilder.

        --register=<depot>  Register into the given depot.  By default, registers into
                            the first entry of `JULIA_DEPOT_PATH`, which is typically 
                            `~/.julia`.  Registration requires deployment to a non-
                            local target, as it must embed the URL that the deployed
                            JLL package is available at within the registry.

        --meta-json         Output a JSON representation of the given build instead of
                            actually building.  Note that this can (and often does)
                            output multiple JSON objects for multiple platforms, multi-
                            stage builds, etc...

        --help              Print out this message.

    Examples:
        julia --color=yes build_tarballs.jl --verbose
            This builds all tarballs, with colorized output.

        julia build_tarballs.jl x86_64-linux-gnu,i686-linux-gnu
            This builds two tarballs for the two platforms given, with a
            minimum of output messages.
    """
)

"""
    parse_build_tarballs_args(ARGS::Vector{String})

Parse the arguments passed in to a `build_tarballs.jl` into a dictionary that can be
splatted into `BuildMeta()`.
"""
function parse_build_tarballs_args(ARGS::Vector{String})
    parsed_kwargs = Dict{Symbol,Any}()

    if check_flag!(ARGS, "--help")
        println(BUILD_HELP)
        exit(0)
    end

    # --verbose; simple boolean
    parsed_kwargs[:verbose] = check_flag!(ARGS, "--verbose")

    # This sets whether we drop into a debug shell on failure or not
    debug, debug_mode = extract_flag!(ARGS, "--debug", "error")
    if debug
        if debug_mode ∉ ("error", "begin", "end")
            throw(ArgumentError("Invalid choice for `debug_mode`: \"$(debug_mode)\""))
        end
        parsed_kwargs[:debug] = debug_mode
    end

    # Are we skipping building and just outputting JSON?
    meta_json, meta_json_file = extract_flag!(ARGS, "--meta-json")
    if meta_json
        if meta_json_file === nothing
            parsed_kwargs[:json_output] = stdout
        else
            parsed_kwargs[:json_output] = meta_json_file
        end
    end

    # There is no option to not deploy, so ignore the first return value
    _, deploy_target = extract_flag!(ARGS, "--deploy", "local")
    parsed_kwargs[:deploy_target] = deploy_target

    # The depot we will register into
    register, register_path = extract_flag!(ARGS, "--register", Pkg.depots1())
    if register
        parsed_kwargs[:register_depot] = register_path
    end

    # Slurp up the last argument as platforms
    if length(ARGS) == 1
        parse_platform(p::AbstractString) = p == "any" ? AnyPlatform() : parse(Platform, p; validate_strict=true)
        parsed_kwargs[:target_list] = parse_platform.(split(ARGS[1], ","))
    elseif length(ARGS) > 1
        throw(ArgumentError("Extraneous arguments to `build_tarballs.jl`: $(join([string("\"", x, "\"") for x in ARGS[2:end]], " "))"))
    end

    return parsed_kwargs
end



"""
    BuildConfig

This structure holds all of the inputs that are needed to generate a build of a software
project in the build environment.  Things such as the project name, the list of sources,
the build script, the dependencies, etc... are all listed within this structure.  Once
the user calls `build!()`, each `BuildConfig` will get a `BuildResult` packed into the
overall `BuildMeta` object.
"""
struct BuildConfig
    # The name of the package being built.  This is exported as an environment variable during build
    # so that internal tooling such as "install_license" can install into intelligent paths.
    src_name::String

    # The source version; this may not be what the resultant JLL gets published under, but it will
    # be recorded as metadata in the JLL itself.
    src_version::VersionNumber

    # Sources that we will build from (Git repositories, tarballs, directories on-disk, etc...)
    sources::Vector{<:AbstractSource}

    # Dependencies that must be installed in the build environment.
    # Contains host and target dependencies.
    dependencies::Vector{<:AbstractDependency}

    # The compiler packages to mount within the rootfs.  In a future update, this will be
    # merged into `dependencies`, once we are properly constructing our build environment
    # through things like `GCC_jll` and `Clang_jll`, instead of special compiler shards.
    compilers::Vector{Symbol}
    shards::Vector{BinaryBuilderBase.CompilerShard}

    # Flags that influence the build environment and the generated compiler wrappers
    allow_unsafe_flags::Bool
    lock_microarchitecture::Bool

    # This contains a fine-grained list of audit actions that should be skipped for this
    # build.  If the special value `:all` exists wtihin this Vector, auditing is skipped
    # completely.
    audit_action_blocklist::Vector{Symbol}

    # Bash script that will perform the actual build itself
    script::String

    # The platform this build will target, both the user-requested
    # (possibly not-fully-concretized) as well as the fully-concretized
    # due to compiler ABI constraints.
    target::AbstractPlatform
    concrete_target::AbstractPlatofrm
end

function BuildConfig(src_name::AbstractString,
                     sources::Vector{<:AbstractSource},
                     dependencies::Vector{<:AbstractDependency},
                     script::AbstractString,
                     target::AbstractPlatform;
                     # For GCC, default to oldest version for compatibility
                     preferred_gcc_version::VersionNumber = BinaryBuilderBase.getversion(BinaryBuilderBase.available_gcc_builds[1]),
                     # LLVM doesn't have the compatibility issues that GCC does, so default to the latest and greatest
                     preferred_llvm_version::VersionNumber = BinaryBuilderBase.getversion(BinaryBuilderBase.available_llvm_builds[end]),
                     allow_unsafe_flags::Bool = false,
                     lock_microarchitecture::Bool = true,
                     # By default, only provide C/C++/Fortran compilers
                     compilers::Vector{Symbol} = [:c],
                     audit_action_blocklist::Vector{Symbol} = Symbol[],
                     )
    shards = choose_shards(target; preferred_gcc_version, preferred_llvm_version, compilers)
    # Now that we know which compilers we're building with, let's figure out our actual
    # platform that we will use to construct the build environment (this will strictly be
    # a valid sub-platform of the `target` given here).
    concrete_target = BinaryBuilderBase.get_concrete_platform(target, shards)
    return BuildConfig(
        String(src_name),
        sources,
        dependencies,
        compilers,
        shards,
        allow_unsafe_flags,
        lock_microarchitecture,
        audit_action_blocklist,
        String(script),
        target,
        concrete_target,
    )
end

"""
    BuildResult

A `BuildResult` represents a constructed build prefix; it contains the paths to the
binaries (typically within an artifact directory) as well as some metadata about the
audit passes and whatnot that ran upon the files.
"""
struct BuildResult
    # The config that this result was built from
    config::BuildConfig

    # The overall status of the build; e.g. `:complete`.
    status::Symbol

    # The location of the build prefix on-disk (typically an artifact directory)
    prefix::String

    # Logs that are generated from build invocations and audit passes.
    # Key name is an identifier for the operation, value is the log content.
    # Example: ("audit-libfoo-relink_to_rpath").
    logs::Dict{String,String}

    # These are `@info`/`@warn`/`@error` messages that get emitted during the build/audit
    # we may eventually want to make this more structured, e.g. organize them by audit
    # pass and whatnot.  These messages are not written out to disk during packaging.
    #msgs::Vector{Test.LogRecord}

    ## TODO: merge `logs` and `msgs` with a better, more structured logging facility?
end

function BuildResult(config::BuildConfig,
                     status::Symbol,
                     prefix::AbstractString,
                     logs::Dict{AbstractString,AbstractString})
                     #msgs::Vector{Test.LogRecord})
    return BuildResult(
        config,
        status,
        String(prefix),
        Dict(String(k) => String(v) for (k, v) in logs),
        #msgs,
    )
end

# TODO: construct helper to reconstruct BuildResult objects from S3-saved tarballs


"""
    PackageConfig

This structure holds all the inputs needed to package a new JLL release.  It requires a
set of `BuildResult`s that it will then package up into a new JLL, optionally deploying
the build results onto GitHub releases, etc...
"""
struct PackageConfig
    # The build results we're packaging up
    builds::Vector{BuildResult}

    # The extraction script that we're using to copy build results out into our artifacts
    script::String

    # The products that this package will ensure are available
    products::Vector{<:Product}
end

function PackageConfig(builds::Vector{BuildResult},
                       script::AbstractString,
                       products::Vector{Product})
    names = [br.name for br in builds]
    if !all(names .== names[1])
        error("Can only package builds with the same source name!")
    end
    return PackageConfig(
        builds,
        String(script),
        products,
    )
end

struct PackageResult
    # Link back to the originating Package Config
    config::PackageConfig

    # The version number this package result is getting published under (may disagree with `src_version`)
    published_version::VersionNumber

    # Treehashes that represent the packaged outputs for this JLL release
    artifacts::Vector{Base.SHA1}

    # The location the code was all written out to
    code_dir::String

    # The location the code/binaries were deployed to (or `nothing`, if it was not deployed)
    deploy_target::Union{String,Nothing}
end

function PackageResult(config::PackageConfig,
                       published_version::VersionNumber,
                       artifacts::Vector{Base.SHA1},
                       code_dir::AbstractString,
                       deploy_target::Union{AbstractString,Nothing})
    stringify(x::AbstractString) = String(x)
    stringify(::Nothing) = nothing
    return PackageResult(
        config,
        published_version,
        artifacts,
        String(code_dir),
        stringify(deploy_target),
    )
end

"""
    BuildMeta

This structure holds the metadata of a BinaryBuilder session including:

 - All build inputs as `BuildConfig` objects
 - All generated artifacts as `BuildResults` objects
 - All build outputs as `PackageConfig` objects
 - All generated JLLs as `PackageResult` objects

When constructed, global options (most commonly passed in on the command line through
`ARGS`) can be passed to the `BuildMeta` through a `BuildMeta(ARGS::Vector{String})`
parsing method, or directly through keyword arguments in the constructor.
"""
struct BuildMeta
    # Contains a list of builds; when you run build!() with arguments, it records
    # what the metadata for that build was in here.
    builds::Dict{BuildConfig,Union{Nothing,BuildResult}}

    # Contains a list of JLL packages; when you run `package!()` with arguments, it
    # records the pieces that were generated here.
    packages::Dict{PackageConfig,Union{Nothing,PackageResult}}

    ## Options that get toggled by the user through `ARGS`; see `BUILD_HELP`
    # `target_list` overrides a build recipe's built-in target specification.
    # An empty list does no overriding.
    target_list::Vector{Platform}
    verbose::Bool
    debug::Union{Nothing,String}

    # Most steps have a JSON representation that they can output, to allow us to
    # "trace" through a build and see what steps were run.  On Yggdrasil, we combine
    # this with the "dry run" mode, to allow us to generate a series of jobs.
    dry_run::Bool
    json_output::Union{Nothing,IO}
    deploy_target::String
    register_depot::Union{Nothing,String}

    # Metadata about the version of BB used to build this thing
    bb_metadata::Dict

    function BuildMeta(;target_list::Vector{Platform} = Platform[],
                        verbose::Bool = false,
                        debug::Union{Nothing,AbstractString} = nothing,
                        json_output::Union{Nothing,AbstractString,IO} = nothing,
                        dry_run::Bool = false,
                        deploy_target::AbstractString = "local",
                        register_depot::Union{Nothing,AbstractString} = nothing,
                       )
        if debug !== nothing
            if debug ∉ ("begin", "end", "error")
                throw(ArgumentError("If `debug` is specified, it must be one of \"begin\", \"end\" or \"error\""))
            end
        end

        if deploy_target != "local" && (isempty(dirname(deploy_target)) || isempty(basename(deploy_target)))
            throw(ArgumentError("`deploy` must be of the form \"GithubUser/RepoName\", or \"local\""))
        end

        if isa(json_output, AbstractString)
            json_output = open(json_output, write=true)
        end

        if register_depot !== nothing
            if deploy_target == "local"
                throw(ArgumentError("Cannot register with a local deployment!"))
            end
        end

        # Helper to convert SubStrings to Strings, but only if they're not `nothing`
        stringify(x::AbstractString) = String(x)
        stringify(::Nothing) = nothing
        return new(
            Dict{BuildConfig,BuildResult}(),
            Dict{BuildResult,PackageResult}(),
            target_list,
            verbose,
            stringify(debug),
            dry_run,
            json_output,
            stringify(deploy_target),
            stringify(register_depot),
            Dict{String,String}("bb_version" => get_bb_version())
        )
    end
end

"""
    BuildMeta(ARGS::Vector{String})

Convenience constructor that calls `parse_build_tarballs_args()` on `ARGS`.
"""
BuildMeta(ARGS::Vector{String}) = BuildMeta(;parse_build_tarballs_args(ARGS)...)

# TODO: Add serialization tools for all of these structures
