var documenterSearchIndex = {"docs":
[{"location":"build_tips/#Tips-for-Building-Packages-1","page":"Building Packages","title":"Tips for Building Packages","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"BinaryBuilder provides a convenient environment to enable cross-platform building. But, many libraries have complicated build scripts that may need to be adapted to support all of the BinaryBuilder targets.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"If your build fails with some errors, look at the Build Troubleshooting page.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"If you have additional tips, please submit a PR with suggestions.","category":"page"},{"location":"build_tips/#Initiating-different-shell-commands-based-on-target-1","page":"Building Packages","title":"Initiating different shell commands based on target","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Sometimes, you need to adapt build scripts based on the target platform. This can be done within the shell script. Here is an example from staticfloat/OpenBLASBuilder:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"# Set BINARY=32 on i686 platforms and armv7l\nif [[ ${nbits} == 32 ]]; then\n    flags=\"${flags} BINARY=32\"\nfi","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Here are other examples of scripts with target-specific checks:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"XZ - Custom windows installation\nSundials - 32-bit check","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"It is also possible to run quite different scripts for each target by running different build scripts for different sets of targets. Here is an example where windows builds are separated from other targets:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Git","category":"page"},{"location":"build_tips/#Autoconfigure-builds-1","page":"Building Packages","title":"Autoconfigure builds","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Autoconfigure builds are generally quite straightforward. Here is a typical approach:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"./configure --prefix=$prefix --build=${MACHTYPE} --host=${target}\nmake -j${nproc}\nmake install","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Here are examples of autoconfigure build scripts:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Patchelf\nLibCURL","category":"page"},{"location":"build_tips/#CMake-builds-1","page":"Building Packages","title":"CMake builds","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"For CMake, the wizard will suggest a template for running CMake. Typically, this will look like:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"cmake -DCMAKE_INSTALL_PREFIX=${prefix} -DCMAKE_TOOLCHAIN_FILE=${CMAKE_TARGET_TOOLCHAIN} -DCMAKE_BUILD_TYPE=Release","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"The toolchain file sets up several CMake environment variables for better cross-platform support, such as CMAKE_SYSROOT, CMAKE_C_COMPILER, etc...  Examples of builds that include CMake parts include:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"JpegTurbo\nSundials\nNeeds -DSUNDIALS_INDEX_TYPE=int32_t on 32-bit targets (Sundials-specific way to specify integer size)\nNeeds to copy *.dll files from destdir/lib to destdir/bin for windows; this also removes symlinks by using cp -L\nNeeds -DCMAKE_FIND_ROOT_PATH=\"$WORKSPACE/destdir\", so CMake's find_library can find libraries from KLU","category":"page"},{"location":"build_tips/#Meson-builds-1","page":"Building Packages","title":"Meson builds","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"BinaryBuilder supports also building with Meson.  Since this is going to be a cross-compilation, you have to specify a Meson cross file:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"meson --cross-file=\"${MESON_TARGET_TOOLCHAIN}\"","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"After configuring the project with meson, you can then build and install it with","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"ninja -j${nproc}\nninja install","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"The wizard automatically suggests using Meson if the meson.build file is present.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Examples of builds performed with Meson include:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"gdk-pixbuf\nHere meson uses platform-dependent options\nlibepoxy\nThis script modifies c_args in the Meson cross file in order to add an include directory\nxkbcommon","category":"page"},{"location":"build_tips/#Builds-with-binary-dependencies-1","page":"Building Packages","title":"Builds with binary dependencies","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"A build script can depend on binaries generated by another builder. A builder specifies dependencies in the form of previously-built JLL packages:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"# Dependencies of Xorg_xkbcomp\ndependencies = [\n    Dependency(\"Xorg_libxkbfile_jll\"),\n    BuildDependency(\"Xorg_util_macros_jll)\",\n]","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Dependency specify a JLL package that is necessary to build and load the current builder;\nBuildDependency is a JLL package necessary only to build the current package, but not to load it.  This dependency will not be added to the list of the dependencies of the generated JLL package.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"In the wizard, dependencies can be specified with the prompt: Do you require any (binary) dependencies?  [y/N].","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Examples of builders that depend on other binaries include:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"ImageMagick depends on Zlib, libpng, JpegTurbo and Libtiff.","category":"page"},{"location":"build_tips/#Building-a-platform-independent-package-1","page":"Building Packages","title":"Building a platform-independent package","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"BinaryBuilder.jl is particularly useful to build packages involving shared libraries and binary executables.  There is little benefit in using this package to build a package that would be platform-independent, for example to install a dataset to be used in a Julia package on the user's machine.  For this purpose a simple Artifacts.toml file generated with create_artifact would do exactly the same job.  Nevertheless, there are cases where a platform-independent JLL package would still be useful, for example to build a package containing only header files that will be used as dependency of other packages.  To build a platform-independent package you can use the special platform AnyPlatform:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"platforms = [AnyPlatform()]","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Within the build environment, an AnyPlatform looks like x86_64-linux-musl, but this shouldn't affect your build in any way.  Note that when building a package for AnyPlatform you can only have products of type FileProduct, as all other types are platform-dependent.  The JLL package generated for an AnyPlatform is platform-independent and can thus be installed on any machine.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Example of builders using AnyPlatform:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"OpenCL_Headers;\nSPIRV_Headers.","category":"page"},{"location":"build_tips/#Editing-files-in-the-wizard-1","page":"Building Packages","title":"Editing files in the wizard","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"In the wizard, the vim editor is available for editing files. But, it doesn't leave any record in the build script. One generally needs to provide patch files or use something like sed. If a file needs patching, we suggest using git to add the entire worktree to a new repo, make the changes you need, then use git diff -p to output a patch that can be included alongside your build recipe.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"You can include local files like patches very easily by placing them within a bundled/patches nested directory, and then providing \"./bundled\" as one of the sources for your build.  See, for example, OpenBLAS.","category":"page"},{"location":"build_tips/#Automatic-environment-variables-1","page":"Building Packages","title":"Automatic environment variables","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"The following environment variables are automatically set in the build environment and should be used to build the project.  Occasionally, you may need to tweak them (e.g., when Using GCC on macOS and FreeBSD).","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"CC: the C cross compiler\nCXX: the C++ cross compiler\nFC: the Fortran cross compiler\nOBJC: the Objective-C cross compiler","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"The above variables point to utilities for the target environment.  To reference the utilities for the host environment either prepend HOST or append _HOST.  For example, HOSTCC and CC_HOST point to the native C compiler.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"These are other environment variables that you may occasionally need to set during a build","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"CFLAGS: options for the C compiler\nCXXFLAGS: options for the C++ compiler\nCPPFLAGS: options for the C pre-processor\nLDFLAGS: options for the linker\nPKG_CONFIG_PATH: a colon-separated list of directories to search for .pc files\nPKG_CONFIG_SYSROOT_DIR: modifies -I and -L to use the directories located in target sysroot","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"The following variables are useful to control the build script over different target systems, but are not intended to be modified by the users:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"prefix: the path to the top-directory of where all the products should be installed.  This will be the top-directory of the generated tarball\nlibdir: the path to the directory where the shared libraries should be installed.  This is ${prefix}/bin when building for Windows, ${prefix}/lib for all other platforms\nbindir: the path to the directory where the executables should be installed.  This is equivalent to ${prefix}/bin\nincludedir: the path to the directory where the header files should be installed.  This is equivalent to ${prefix}/include\ntarget: the target platform\nbb_full_target: the full target platform, containing things like libstdc++ string ABI platform tags, and libgfortran version\nnproc: the number of processors of the host machine, useful for parallel building (e.g., make -j${nproc})\nnbits: number of bits of the target architecture (usually it is either 32 or 64)\nproc_family: target processor family (e.g., \"intel\", \"power\", or \"arm\")\ndlext: extension of the shared library on the target system.  It is \"dll\" for Windows, \"dylib\" for macOS, and \"so\" for the other Unix systems\nexeext: extension of the executable on the target system, including the dot if present.  It is \".exe\" for Windows and the empty string \"\" for all the other target platforms\nSRC_NAME: name of the project being built","category":"page"},{"location":"build_tips/#Using-GCC-on-macOS-and-FreeBSD-1","page":"Building Packages","title":"Using GCC on macOS and FreeBSD","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"For these target systems Clang is the default compiler, however some programs may not be compatible with Clang.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"For programs built with CMake (see the CMake build section) you can use the GCC toolchain file that is in ${CMAKE_TARGET_TOOLCHAIN%.*}_gcc.cmake.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"If the project that you want to build uses the GNU Build System (also knows as the Autotools), there isn't an automatic switch to use GCC, but you have to set the appropriate variables.  For example, this setting can be used to build most C/C++ programs with GCC for FreeBSD and macOS:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"if [[ \"${target}\" == *-freebsd* ]] || [[ \"${target}\" == *-apple-* ]]; then\n    CC=gcc\n    CXX=g++\nfi","category":"page"},{"location":"build_tips/#Installing-the-license-file-1","page":"Building Packages","title":"Installing the license file","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"Generated tarballs should come with the license of the library that you want to install.  If at the end of a successful build there is only one directory inside ${WORKSPACE}/srcdir, BinaryBuilder will look into it for files with typical names for license (like LICENSE, COPYRIGHT, etc... with some combinations of extensions) and automatically install them to ${prefix}/share/licenses/${SRC_NAME}/.  If in the final tarball there are no files in this directory a warning will be issued, to remind you to provide a license file.","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"If the license file is not automatically installed (for example because there is more than one directory in ${WORKSPACE}/srcdir or because the file name doesn't match the expected pattern) you have to manually install the file.  In the build script you can use the install_license command.  See the Utilities in the build environment section below.","category":"page"},{"location":"build_tips/#Utilities-in-the-build-environment-1","page":"Building Packages","title":"Utilities in the build environment","text":"","category":"section"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"In addition to the standard Unix tools, in the build environment there are some extra commands provided by BinaryBuilder.  Here is a list of some of these commands:","category":"page"},{"location":"build_tips/#","page":"Building Packages","title":"Building Packages","text":"atomic_patch: utility to apply patches.  It is similar to the standard patch, but it fails gracefully when a patch cannot be applied:\natomic_patch -p1 /path/to/file.patch\nflagon: utility to translate some compiler-flags to the one required on the current platform.  For example, to build a shared library from a static archive:\ncc -o \"${libdir}/libfoo.${dlext}\" -Wl,$(flagon --whole-archive) libfoo.a -Wl,$(flagon --no-whole-archive) -lm\nThe currently supported flags are:\n--whole-archive;\n--no-whole-archive;\n--relative-rpath-link.\ninstall_license: utility to install a file to ${prefix}/share/licenses/${SRC_NAME}:\ninstall_license ${WORKSPACE}/srcdir/THIS_IS_THE_LICENSE.md\nupdate_configure_scripts: utility to update autoconfigure scripts.  Sometimes libraries come with out-of-date autoconfigure scripts (e.g., old configure.guess can't recognise aarch64 platforms of systems using Musl C library).  Just run\nupdate_configure_scripts\nto get a newer version.  With the --reconf flag, it also runs autoreconf -i -f afterwards:\nupdate_configure_scripts --reconf","category":"page"},{"location":"rootfs/#RootFS-1","page":"RootFS","title":"RootFS","text":"","category":"section"},{"location":"rootfs/#","page":"RootFS","title":"RootFS","text":"The execution environment that all BinaryBuilder.jl builds are executed within is referred to as the \"root filesystem\" or RootFS.  This RootFS is built using the builder scripts contained within the 0_Rootfs directory within Yggdrasil.  The rootfs image is based upon the alpine docker image, and is used to build compilers for every target platform we support.  The target platform compiler toolchains are stored within /opt/${triplet}, so the 64-bit Linux (using glibc as the backing libc) compilers would be found in /opt/x86_64-linux-gnu/bin.","category":"page"},{"location":"rootfs/#","page":"RootFS","title":"RootFS","text":"Each compiler \"shard\" is packaged separately, so that users do not have to download a multi-GB tarball just to build for a single platform.  There is an overall \"root\" shard, along with platform support shards, GCC shards, an LLVM shard, Rust shards, etc... These are all embedded within the bundled Artifacts.toml file, and BinaryBuilder.jl downloads them on-demand as necessary, making use of the new Pkg.Artifacts system within Julia 1.3+.","category":"page"},{"location":"rootfs/#","page":"RootFS","title":"RootFS","text":"Each shard is made available both as an unpacked directory tree, and as a .squashfs image.  .squashfs images take up significantly less disk space, however they unfortunately require root privileges on the host machine, and only work on Linux.  This will hopefully be fixed in a future Linux kernel release, but if you have sudo privileges, it is often desirable to use the .squashfs files to save network bandwidth and disk space.  See the Environment Variables for instructions on how to do that.","category":"page"},{"location":"rootfs/#","page":"RootFS","title":"RootFS","text":"When launching a process within the RootFS image, BinaryBuilder.jl sets up a set of environment variables to enable a target-specific compiler toolchain, among other niceties.  See the Build Tips doc page for more details on that, along with the src/Runner.jl file within this repository for the implementation.","category":"page"},{"location":"environment_variables/#Environment-Variables-1","page":"Environment Variables","title":"Environment Variables","text":"","category":"section"},{"location":"environment_variables/#","page":"Environment Variables","title":"Environment Variables","text":"BinaryBuilder.jl supports multiple environment variables to modify its behavior globally:","category":"page"},{"location":"environment_variables/#","page":"Environment Variables","title":"Environment Variables","text":"BINARYBUILDER_AUTOMATIC_APPLE: when set to true, this automatically agrees to the Apple macOS SDK license agreement, enabling the building of binary objects for macOS systems.\nBINARYBUILDER_USE_SQUASHFS: when set to true, this uses .squashfs images instead of tarballs to download cross-compiler shards.  This consumes significantly less space on-disk and boasts a modest reduction in download size as well, but requires sudo on the local machine to mount the .squashfs images.  This is the default when using the \"privileged\" runner.\nBINARYBUILDER_RUNNER: When set to a runner string, alters the execution engine that BinaryBuilder.jl will use to wrap the build process in a sandbox.  Valid values are one of \"userns\", \"privileged\" and \"docker\".  If not given, BinaryBuilder.jl will do its best to guess.\nBINARYBUILDER_ALLOW_ECRYPTFS: When set to true, this allows the mounting of rootfs/shard/workspace directories from within encrypted mounts.  This is disabled by default, as at the time of writing, this triggers kernel bugs.  To avoid these kernel bugs on a system where e.g. the home directory has been encrypted, set the BINARYBUILDER_ROOTFS_DIR and BINARYBUILDER_SHARDS_DIR environment variables to a path outside of the encrypted home directory.\nBINARYBUILDER_USE_CCACHE: When set to true, this causes a /root/.ccache volume to be mounted within the build environment, and for the CC, CXX and FC environment variables to have ccache prepended to them.  This can significantly accelerate rebuilds of the same package on the same host.  Note that ccache will, by default, store 5G of cached data.\nBINARYBUILDER_NPROC: Overrides the value of the environment variable ${nproc} set during a build, see Automatic environment variables.","category":"page"},{"location":"FAQ/#Frequently-Asked-Questions-1","page":"FAQ","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"FAQ/#I'm-having-trouble-compiling-project-name-here-1","page":"FAQ","title":"I'm having trouble compiling <project name here>","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"First, make sure that you can compile that project natively on whatever platform you're attempting to compile it on.  Once you are assured of that, search around the internet to see if anyone else has run into issues cross-compiling that project for that platform.  In particular, most smaller projects should be just fine, but larger projects (and especially anything that does any kind of bootstrapping) may need some extra smarts smacked into their build system to support cross-compiling.  Finally, if you're still stuck, try reaching out for help on the #binarybuilder channel in the JuliaLang slack.","category":"page"},{"location":"FAQ/#How-do-I-use-this-to-compile-my-Julia-code?-1","page":"FAQ","title":"How do I use this to compile my Julia code?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"This package does not compile Julia code; it compiles C/C++/Fortran dependencies.  Think about that time you wanted to use IJulia and you needed to download/install libnettle.  The purpose of this package is to make generated tarballs that can be downloaded/installed painlessly as possible.","category":"page"},{"location":"FAQ/#What-is-this-I-hear-about-the-macOS-SDK-license-agreement?-1","page":"FAQ","title":"What is this I hear about the macOS SDK license agreement?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Apple restricts distribution and usage of the macOS SDK, a necessary component to build software for macOS targets.  Please read the Apple and Xcode SDK agreement for more information on the restrictions and legal terms you agree to when using the SDK to build software for Apple operating systems.  As usual, you should not take legal advice from FAQs on the internet, but in an effort to distill that large document down a bit, it is a breach of the license agreement to use the SDK to compile macOS binaries on a machine that is itself not a macOS machine.  Although this toolkit is designed to primarily run on Linux machines, it would not be breaking the license agreement to run this toolkit within a virtualized environment on a macOS machine, whereas it would be breaking the license agreement to run this toolkit on, for example, an Amazon AWS machine running Linux.  The Docker runner implements the virtualization approach on macOS machines.  BinaryBuilder.jl, by default, will not automatically download or use the macOS SDK on non-apple host operating systems, unless the BINARYBUILDER_AUTOMATIC_APPLE environment variable is set to true.","category":"page"},{"location":"FAQ/#Are-there-other-environment-variables-I-can-use?-1","page":"FAQ","title":"Are there other environment variables I can use?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Yes, take a look.","category":"page"},{"location":"FAQ/#Hey,-this-is-cool,-can-I-use-this-for-my-non-Julia-related-project?-1","page":"FAQ","title":"Hey, this is cool, can I use this for my non-Julia related project?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Absolutely!  There's nothing Julia-specific about the binaries generated by the cross-compilers used by BinaryBuilder.jl.  Although the best interface for interacting with this software will always be the Julia interface defined within this package, you are free to use these software tools for other projects as well.  Note that the cross-compiler image is built through a multistage bootstrapping process, see this repository for more information.  Further note the macOS SDK license agreement tidbit above.","category":"page"},{"location":"FAQ/#What-platforms-are-supported?-1","page":"FAQ","title":"What platforms are supported?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"At the time of writing, we support Linux (x86_64, i686, armv7l, aarch64, ppc64le), Windows (x86_64, i686), macOS (x86_64) and FreeBSD (x86_64).","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"You can get the list of the supported platforms and their associated triplets by using the functions supported_platforms and triplet:","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"using BinaryBuilder\nfor p in supported_platforms()\n    println(\"Platform: $(p); triplet: $(triplet(p))\")\nend","category":"page"},{"location":"FAQ/#At-line-XXX,-ABORTED-(Operation-not-permitted)!-1","page":"FAQ","title":"At line XXX, ABORTED (Operation not permitted)!","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Some linux distributions have a bug in their overlayfs implementation that prevents us from mounting overlay filesystems within user namespaces.  See this Ubuntu kernel bug report for a description of the situation and how Ubuntu has patched it in their kernels.  To work around this, you can launch BinaryBuilder.jl in \"privileged container\" mode.  BinaryBuilder should auto-detect this situation, however if the autodetection is not working or you want to silence the warning, you can set the BINARYBUILDER_RUNNER environment variable to privileged.  Unfortunately, this involves running sudo every time you launch into a BinaryBuilder session, but on the other hand, this successfully works around the issue on distributions such as Arch linux.","category":"page"},{"location":"FAQ/#I-have-to-build-a-very-small-project-without-a-Makefile,-what-do-I-have-to-do?-1","page":"FAQ","title":"I have to build a very small project without a Makefile, what do I have to do?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"What BinaryBuilder needs is to find the relevant file (shared libraries, or executables, etc...) organised under the $prefix directory: libraries should go to ${libdir}, executables to ${bindir}.  You may need to create those directories.  You are free to choose whether to create a simple Makefile to build the project or to do everything within the build_tarballs.jl script. When the script completes, BinaryBuilder expects to find at least one artifact built for the expected architecture in either ${libdir} or ${bindir}. Remember also that you should use the standard environment variables like CC, CXX, CFLAGS, LDFLAGS as appropriate in order to cross compile.  See the list of variables in the Tips for Building Packages section.","category":"page"},{"location":"FAQ/#I-love-the-wizard,-but-now-I-want-to-break-free:-can-I-build-the-tarballs-without-it?-1","page":"FAQ","title":"I love the wizard, but now I want to break free: can I build the tarballs without it?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"The build_tarballs.jl script can be used as a command line utility, it takes a few options and as argument the list of triplets of the targets.  You can find more information about the syntax of the script with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"julia build_tarballs.jl --help","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Instead of using the wizard, you can adapt for a new library a build_tarballs.jl script originally written for another library.  Then, you can build the tarballs with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"julia --color=yes build_tarballs.jl --debug --verbose","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"The --debug option will drop you into the BinaryBuilder interactive shell if an error occurs.  If the build fails, after finding out the steps needed to fix the build you have to manually update the script in build_tarballs.jl.  You should run again the above command to make sure that everything is actually working.","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Since build_tarballs.jl takes as argument the comma-separated list of targets for which to build the tarballs, you can select only a few of them.  For example, with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"julia --color=yes build_tarballs.jl --debug --verbose aarch64-linux-musl,arm-linux-musleabihf","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"you'll run the build script only for the aarch64-linux-musl and arm-linux-musleabihf targets.","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"If you decide to use this workflow, however, you will need to manually open pull requests for Yggdrasil.","category":"page"},{"location":"FAQ/#Can-I-open-a-shell-in-a-particular-build-environment-for-doing-some-quick-tests?-1","page":"FAQ","title":"Can I open a shell in a particular build environment for doing some quick tests?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Yes!  You can use BinaryBuilder.runshell(platform) to quickly start a shell in the current directory, without having to set up a working build_tarballs.jl script.  For example,","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"julia -e 'using BinaryBuilder; BinaryBuilder.runshell(Windows(:i686))'","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"will open a shell in a Windows 32-bit build environment, without any source loaded.  The current working directory of your system will be mounted on ${WORKSPACE} within this BinaryBuilder environment.","category":"page"},{"location":"FAQ/#Can-I-publish-a-JLL-package-locally-without-going-through-Yggdrasil?-1","page":"FAQ","title":"Can I publish a JLL package locally without going through Yggdrasil?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"You can always build a JLL package on your machine with the --deploy flag to the build_tarballs.jl script.  Read the help (--help) for more information.","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"A common use case is that you want to build a JLL package for, say, Libfoo, that will be used as dependency to build Quxlib, and you want to make sure that building both Libfoo and Quxlib will work before submitting all the pull requests to Yggdrasil.  You can prepare the build_tarballs.jl script for Libfoo and then build and deploy it with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"julia --color=yes build_tarballs.jl --debug --verbose --deploy=\"MY_USERNAME/Libfoo_jll.jl\"","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"replacing MY_USERNAME with your GitHub username: this will build the tarballs for all the platforms requested and upload them to a release of the MY_USERNAME/Libfoo_jll.jl, where the JLL package will also be created.  As explained above, you can pass argument the list of triplets of the platforms for you which you want to build the tarballs, in case you want to compile only some of them.  In the Julia REPL, you can install this package as any unregistered package with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"]add https://github.com/MY_USERNAME/Libfoo_jll.jl.git","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"or develop it with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"]dev https://github.com/MY_USERNAME/Libfoo_jll.jl.git","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Since this package is unregistered, you have to use the full PackageSpec specification to add it as dependency of the local builder for Quxlib:","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"    Dependency(PackageSpec(; name = \"Libfoo_jll\",  uuid = \"...\", url = \"https://github.com/MY_USERNAME/Libfoo_jll.jl.git\"))","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"You can of course in turn build and deply this package with","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"julia --color=yes build_tarballs.jl --debug --verbose --deploy=\"MY_USERNAME/Quxlib_jll.jl\"","category":"page"},{"location":"FAQ/#Can-I-install-packages-in-the-build-environment?-1","page":"FAQ","title":"Can I install packages in the build environment?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"Yes, but it's unlikely that you'll need to.  The build environment is based on Alpine Linux (triplet: x86_64-linux-musl) so you can use apk to install packages in it.  However, if you need runtime libraries or programs for the target system these packages won't help you.  The package manager is useful only to install utilities, tools or libraries that are needed exclusively at compile time on the build system.","category":"page"},{"location":"FAQ/#What-are-those-numbers-in-the-list-of-sources?-How-do-I-get-them?-1","page":"FAQ","title":"What are those numbers in the list of sources?  How do I get them?","text":"","category":"section"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"The list of sources is a vector of BinaryBuilder.AbstractSources.  What the hash is depends on what the source is:","category":"page"},{"location":"FAQ/#","page":"FAQ","title":"FAQ","text":"For a FileSource or an ArchiveSource, the hash is a 64-character SHA256 checksum.  If you have a copy of that file, you can compute the hash in Julia with\nusing SHA\nopen(path_to_the_file, \"r\") do f\n     bytes2hex(sha256(f))\nend\nwhere path_to_the_file is a string with the path to the file.  Alternatively, you can use the command line utilities curl and shasum to compute the hash of a remote file:\n$ curl -L http://example.org/file.tar.gz | shasum -a 256\nreplacing http://example.org/file.tar.gz with the actual URL of the file you want to download.\nFor a GitSource, the hash is the 40-character SHA1 hash of the revision you want to checkout.  For reproducibility you must indicate a specific revision, and not a branch or tag name, which are moving targets.","category":"page"},{"location":"jll/#JLL-packages-1","page":"JLL packages","title":"JLL packages","text":"","category":"section"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"BinaryBuilder.jl is designed to produce tarballs that can be used in any environment, but so far their main use has been to provide pre-built libraries and executables to be readily used in Julia packages.  This is accomplished by JLL packages (a pun on \"Dynamic-Link Library\", with the J standing for Julia). They can be installed like any other Julia packages with the Julia package manager in the REPL with","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"]add NAME_jll","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"and then loaded with","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"using NAME_jll","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"However, most users will not ever need to do these steps on their own, JLL packages are usually only used as dependencies of packages wrapping binary libraries or executables.","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"Most JLL packages live under the JuliaBinaryWrappers organization on GitHub, and the builders to generate them are maintaned in Yggdrasil, the community build tree.  BinaryBuilder.jl allows anyone to create their own JLL package and publish them to a GitHub repository of their choice without using Yggdrasil, see the Frequently Asked Questions.","category":"page"},{"location":"jll/#Anatomy-of-a-JLL-package-1","page":"JLL packages","title":"Anatomy of a JLL package","text":"","category":"section"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"A somewhat popular misconception is that JLL packages are \"special\".  Instead, they are simple Julia packages with a common structure, as they are generated automatically.  This is the typical tree of a JLL package, called in this example NAME_jll.jl:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"NAME_jll\n├── Artifacts.toml\n├── LICENSE\n├── Project.toml\n├── README.md\n└── src/\n    ├── NAME_jll.jl\n    └── wrappers/\n        ├── aarch64-linux-gnu.jl\n        ├── aarch64-linux-musl.jl\n        ├── armv7l-linux-gnueabihf.jl\n        ├── armv7l-linux-musleabihf.jl\n        ├── i686-linux-gnu.jl\n        ├── i686-linux-musl.jl\n        ├── i686-w64-mingw32.jl\n        ├── powerpc64le-linux-gnu.jl\n        ├── x86_64-apple-darwin14.jl\n        ├── x86_64-linux-gnu.jl\n        ├── x86_64-linux-musl.jl\n        ├── x86_64-unknown-freebsd11.1.jl\n        └── x86_64-w64-mingw32.jl","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"These are the main ingredients of a JLL package:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"LICENSE, a file stating the license of the JLL package.  Note that this may differ from the license of the library it wraps, which is instead shipped inside the tarballs;\na README.md file providing some information about the content of the wrapper, like the list of \"products\" provided by the package;\nthe Artifacts.toml file contains the information about all the available tarballs for the given package.  The tarballs are uploaded to GitHub releases;\nthe Project.toml file describes the packages dependencies and their compatibilities;\nthe main entry point of the package is the file called src/NAME_jll.jl. This is what is executed when you issue the command\nusing NAME_jll\nThis file reads the list of tarballs available in Artifacts.toml and choose the platform matching the current platform.  Some JLL packages are not built for all supported platforms.  If the current platform is one of those platform not supported by the JLL package, this is the end of the package.  Instead, if the current platform is supported, the corresponding wrapper in the src/wrappers/ directory will be included;\nthe wrappers/ directory contains a file for each of the supported platforms.  They are actually mostly identical, with some small differences due to platfomr-specific details.  The wrappers are analyzed in more details in the following section.","category":"page"},{"location":"jll/#The-wrappers-1","page":"JLL packages","title":"The wrappers","text":"","category":"section"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"The files in the src/wrappers/ directory are very thin automatically-generated wrappers around the binary package provided by the JLL package.  They load all the JLL packages that are dependencies of the current JLL package and export the names of the products listed in the build_tarballs.jl script that produced the current JLL package.  Among others, they also define the following unexported variables:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"artifact_dir: the absolute path to where the artifact for the current platform has been installed;\nPATH: the value of the PATH environment variable needed to run executables in the current JLL package, if any;\nPATH_list: the list of directories in PATH as a vector of Strings;\nLIBPATH: the value of the environment variable that holds the list of directories in which to search shared libraries.  This has the correct value for the libraries provided by the current JLL package;\nLIBPATH_list: the list of directories in LIBPATH as a vector of Strings;\nLIBPATH_env: the name of the environment variable of the search paths of the shared libraries for the current platform.  This is equal to LD_LIBRARY_PATH on Linux and FreeBSD, DYLD_FALLBACK_LIBRARY_PATH on macOS, and PATH on Windows;","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"The wrapper files for each platform also define the __init__() function of the JLL package, the code that is executed every time the package is loaded.  The __init__() function will populate most of the variables mentioned above and automatically open the shared libraries, if any, listed in the products of the build_tarballs.jl script that generated the JLL package.","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"The rest of the code in the wrappers is specific to each of the products of the JLL package and detailed below.  If you want to see a concrete example of a package providing all the main three products, have a look at Fontconfig_jll.jl.","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"In what follows, we will use as an example a builder that has these products:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"products = [\n    FileProduct(\"src/data.txt\", :data_txt),\n    LibraryProduct(\"libdataproc\", :libdataproc),\n    ExecutableProduct(\"mungify\", :mungify_exe),\n]","category":"page"},{"location":"jll/#LibraryProduct-1","page":"JLL packages","title":"LibraryProduct","text":"","category":"section"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"A LibraryProduct is a shared library that can be ccalled from Julia.  Assuming that the product is called libdataproc, the wrapper defines the following variables:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"libdataproc: this is the exported const variable that should be used in ccall:\nnum_chars = ccall((:count_characters, libdataproc), Cint,\n                  (Cstring, Cint), data_lines[1], length(data_lines[1]))\nRoughly speaking, the value of this variable is the basename of the shared library, not its full absolute path;\nlibdataproc_splitpath: the path of the shared library, relative to artifact_dir, as returned by splitpath;\nlibdataproc_path: the full absolute path of the shared library.  Note that this is not const, thus it can't be used in ccall;\nlibdataproc_handle: the address in memory of the shared library after it has been loaded at initialization time.","category":"page"},{"location":"jll/#ExecutableProduct-1","page":"JLL packages","title":"ExecutableProduct","text":"","category":"section"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"An ExecutableProduct is a binary executable that can be run on the current platform.  If, for example, the ExecutableProduct has been called mungify_exe, the wrapper defines an exported function named mungify_exe that should run by the user in the following way:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"mungify_exe() do exe\n    run(`$exe $arguments`)\nend","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"Note that in this example exe can be replaced with any name of your choice: with the do-block syntax you are defining the name of the variable that will be used to actually call the binary with run.","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"A common point of confusion about ExecutableProducts in JLL packages is why this function is needed: while in principle you could directly run the executable directly by using its absolute path in run, this wrapper function ensures that the executable will find all shared libraries it needs while running.","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"In addition to the function called mungify_exe, for this product there will be the following unexported variables:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"mungify_exe_splitpath: the path of the executable, relative to artifact_dir, as returned by splitpath;\nmungify_exe_path: the full absolute path of the executable;","category":"page"},{"location":"jll/#FileProduct-1","page":"JLL packages","title":"FileProduct","text":"","category":"section"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"A FileProduct is a simple file with no special treatment.  If, for example, the FileProduct has been called data_txt, the only variables defined for it are:","category":"page"},{"location":"jll/#","page":"JLL packages","title":"JLL packages","text":"data_txt: this exported variable has the absolute path to the mentioned file:\ndata_lines = open(data_txt, \"r\") do io\n    readlines(io)\nend\ndata_txt_path: this unexported variable is actually equal to data_txt, but is kept for consistency with all other product types.","category":"page"},{"location":"reference/#API-reference-1","page":"Reference","title":"API reference","text":"","category":"section"},{"location":"reference/#Types-1","page":"Reference","title":"Types","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [BinaryBuilder]\nOrder = [:type]","category":"page"},{"location":"reference/#BinaryBuilder.AnyPlatform","page":"Reference","title":"BinaryBuilder.AnyPlatform","text":"AnyPlatform()\n\nA special platform to be used to build platform-independent tarballs, like those containing only header files.  FileProduct is the only product type allowed with this platform.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.ArchiveSource","page":"Reference","title":"BinaryBuilder.ArchiveSource","text":"ArchiveSource(url::String, hash::String; unpack_target::String = \"\")\n\nSpecify a remote archive in one of the supported archive formats (e.g., TAR or ZIP balls) to be downloaded from the Internet from url.  hash is the 64-character SHA256 checksum of the file.\n\nIn the builder environment, the archive will be automatically unpacked to ${WORKSPACE}/srcdir, or in its subdirectory pointed to by the optional keyword unpack_target, if provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.BuildDependency","page":"Reference","title":"BinaryBuilder.BuildDependency","text":"BuildDependency(dep::Union{PackageSpec,String})\n\nDefine a binary dependency that is necessary only to build the package.  The argument can be either a string with the name of the JLL package or a Pkg.PackageSpec.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.Dependency","page":"Reference","title":"BinaryBuilder.Dependency","text":"Dependency(dep::Union{PackageSpec,String})\n\nDefine a binary dependency that is necessary to build the package and load the generated JLL package.  The argument can be either a string with the name of the JLL package or a Pkg.PackageSpec.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.DirectorySource","page":"Reference","title":"BinaryBuilder.DirectorySource","text":"DirectorySource(path::String; target::String = basename(path))\n\nSpecify a local directory to mount from path.\n\nThe content of the directory will be mounted in ${WORKSPACE}/srcdir, or in its subdirectory pointed to by the optional keyword target, if provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.ExecutableProduct","page":"Reference","title":"BinaryBuilder.ExecutableProduct","text":"An ExecutableProduct is a Product that represents an executable file.\n\nOn all platforms, an ExecutableProduct checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set.  On Windows platforms, it will check that the file ends with \".exe\", (adding it on automatically, if it is not already present).\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.FileProduct","page":"Reference","title":"BinaryBuilder.FileProduct","text":"FileProduct(path::AbstractString, varname::Symbol, dir_path = nothing)\n\nDeclares a FileProduct that points to a file located relative to the root of a Prefix, must simply exist to be satisfied.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.FileSource","page":"Reference","title":"BinaryBuilder.FileSource","text":"FileSource(url::String, hash::String; filename::String = basename(url))\n\nSpecify a remote file to be downloaded from the Internet from url.  hash is the 64-character SHA256 checksum of the file.\n\nIn the builder environment, the file will be saved under ${WORKSPACE}/srcdir with the same name as the basename of the originating URL, unless the the keyword argument filename is specified.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.FrameworkProduct","page":"Reference","title":"BinaryBuilder.FrameworkProduct","text":"A FrameworkProduct is a  Product that encapsulates a macOS Framework. It behaves mostly as a LibraryProduct for now, but is a distinct type. This implies that for cross-platform builds where a library is provided as a Framework on macOS and as a normal library on other platforms, two calls to build_tarballs are needed: one with the LibraryProduct and all non-macOS platforms, and one with the FrameworkProduct and the MacOS platforms.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.GitSource","page":"Reference","title":"BinaryBuilder.GitSource","text":"GitSource(url::String, hash::String; unpack_target::String = \"\")\n\nSpecify a remote Git repository to clone form url.  hash is the 40-character SHA1 revision to checkout after cloning.\n\nThe repository will be cloned in ${WORKSPACE}/srcdir, or in its subdirectory pointed to by the optional keyword unpack_target, if provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.LibraryProduct","page":"Reference","title":"BinaryBuilder.LibraryProduct","text":"A LibraryProduct is a special kind of Product that not only needs to exist, but needs to be dlopen()'able.  You must know which directory the library will be installed to, and its name, e.g. to build a LibraryProduct that refers to \"/lib/libnettle.so\", the \"directory\" would be \"/lib\", and the \"libname\" would be \"libnettle\".  Note that a LibraryProduct can support multiple libnames, as some software projects change the libname based on the build configuration.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.OutputCollector","page":"Reference","title":"BinaryBuilder.OutputCollector","text":"OutputCollector\n\nA run() wrapper class that captures subprocess stdout and stderr streams independently, resynthesizing and colorizing the streams appropriately.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.OutputCollector-Tuple{Base.AbstractCmd}","page":"Reference","title":"BinaryBuilder.OutputCollector","text":"OutputCollector(cmd::AbstractCmd; verbose::Bool = false)\n\nRun cmd, and collect the output such that stdout and stderr are captured independently, but with the time of each line recorded such that they can be stored/analyzed independently, but replayed synchronously.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Product","page":"Reference","title":"BinaryBuilder.Product","text":"A Product is an expected result after building or installation of a package.\n\nExamples of Products include LibraryProduct, FrameworkProduct, ExecutableProduct and FileProduct. All Product types must define the following minimum set of functionality:\n\nlocate(::Product): given a Product, locate it within the wrapped Prefix returning its location as a string\nsatisfied(::Product): given a Product, determine whether it has been successfully satisfied (e.g. it is locateable and it passes all callbacks)\nvariable_name(::Product): return the variable name assigned to a Product\nrepr(::Product): Return a representation of this Product, useful for auto-generating source code that constructs Products, if that's your thing.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.AbstractDependency","page":"Reference","title":"BinaryBuilder.AbstractDependency","text":"An AbstractDependency is a binary dependency of the JLL package.  Dependencies are installed to ${prefix} in the build environment.\n\nConcrete subtypes of AbstractDependency are\n\nDependency: a JLL package that is necessary for to build the package and to load the generated JLL package.\nBuildDependency: a JLL package that is necessary only to build the package.  This will not be a dependency of the generated JLL package.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.AbstractSource","page":"Reference","title":"BinaryBuilder.AbstractSource","text":"An AbstractSource is something used as source to build the package.  Sources are installed to ${WORKSPACE}/srcdir in the build environment.\n\nConcrete subtypes of AbstractSource are:\n\nArchiveSource: a remote archive to download from the Internet;\nFileSource: a remote file to download from the Internet;\nGitSource: a remote Git repository to clone;\nDirectorySource: a local directory to mount.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.DockerRunner","page":"Reference","title":"BinaryBuilder.DockerRunner","text":"DockerRunner\n\nUse docker as an execution engine; a reasonable backup for platforms that do not have user namespaces (e.g. MacOS, Windows).\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.LineStream-Tuple{Pipe,Base.GenericCondition{Base.AlwaysLockedST}}","page":"Reference","title":"BinaryBuilder.LineStream","text":"LineStream(pipe::Pipe)\n\nGiven a Pipe that has been initialized by spawn(), create an async Task to read in lines as they come in and annotate the time the line was captured for later replay/merging with other simultaneously captured streams.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.UserNSRunner","page":"Reference","title":"BinaryBuilder.UserNSRunner","text":"UserNSRunner\n\nA UserNSRunner represents an \"execution context\", an object that bundles all necessary information to run commands within the container that contains our crossbuild environment.  Use run() to actually run commands within the UserNSRunner, and runshell() as a quick way to get an interactive shell within the crossbuild environment.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.WizardState","page":"Reference","title":"BinaryBuilder.WizardState","text":"WizardState\n\nBuilding large dependencies can take a lot of time. This state object captures all relevant state of this function. It can be passed back to the function to resume where we left off. This can aid debugging when code changes are necessary.  It also holds all necessary metadata such as input/output streams.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Functions-1","page":"Reference","title":"Functions","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [BinaryBuilder]\nOrder = [:function]","category":"page"},{"location":"reference/#Base.merge-Tuple{OutputCollector}","page":"Reference","title":"Base.merge","text":"merge(collector::OutputCollector; colored::Bool = false)\n\nMerge the stdout and stderr streams of the OutputCollector on a per-line basis, returning a single string containing all collected lines, interleaved by capture time.  If colored is set to true, embeds terminal color codes to print stderr in red.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.audit","page":"Reference","title":"BinaryBuilder.audit","text":"audit(prefix::Prefix; platform::Platform = platform_key_abi();\n                      verbose::Bool = false,\n                      silent::Bool = false,\n                      autofix::Bool = false,\n                      require_license::Bool = true)\n\nAudits a prefix to attempt to find deployability issues with the binary objects that have been installed within.  This auditing will check for relocatability issues such as dependencies on libraries outside of the current prefix, usage of advanced instruction sets such as AVX2 that may not be usable on many platforms, linkage against newer glibc symbols, etc...\n\nThis method is still a work in progress, only some of the above list is actually implemented, be sure to actually inspect Auditor.jl to see what is and is not currently in the realm of fantasy.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.autobuild-Tuple{AbstractString,AbstractString,VersionNumber,Array{#s297,1} where #s297<:BinaryBuilder.AbstractSource,AbstractString,Array{T,1} where T,Array{#s296,1} where #s296<:Product,Array{#s295,1} where #s295<:BinaryBuilder.AbstractDependency}","page":"Reference","title":"BinaryBuilder.autobuild","text":"autobuild(dir::AbstractString, src_name::AbstractString,\n          src_version::VersionNumber, sources::Vector,\n          script::AbstractString, platforms::Vector,\n          products::Vector, dependencies::Vector;\n          verbose = false, debug = false,\n          skip_audit = false, ignore_audit_errors = true,\n          autofix = true, code_dir = nothing,\n          meta_json_file = nothing, require_license = true, kwargs...)\n\nRuns the boiler plate code to download, build, and package a source package for a list of platforms.  This method takes a veritable truckload of arguments, here are the relevant actors, broken down in brief:\n\ndir: the root of the build; products will be placed within dir/products,  and mountpoints will be placed within dir/build/.\nsrc_name: the name of the source package being built and will set the name  of the built tarballs.\nsrc_version: the version of the source package.\nplatforms: a list of platforms to build for.\nsources: a vector of all sources to download and unpack before building begins, as AbstractSources.\nscript: a string representing a shell script to run as the build.\nproducts: the list of Products which shall be built.\ndependencies: a vector of JLL dependency packages as AbstractDependency that should be installed before building begins.\nverbose: Enable verbose mode.  What did you expect?\ndebug: cause a failed build to drop into an interactive shell so that  the build can be inspected easily.\nskip_audit: disable the typical audit that occurs at the end of a build.\nignore_audit_errors: do not kill a build even if a problem is found.\nautofix: give BinaryBuilder permission to automatically fix issues it  finds during audit passes.  Highly recommended.\ncode_dir: sets where autogenerated JLL packages will be put.\nrequire_license enables a special audit pass that requires licenses to be  installed by all packages.\nlazy_artifacts sets whether the artifacts should be lazy.\nmeta_json_stream: If this is set to an IOStream, do not actually build, just  output a JSON representation of all the metadata about this build to the stream.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.bindir-Tuple{Prefix}","page":"Reference","title":"BinaryBuilder.bindir","text":"bindir(prefix::Prefix)\n\nReturns the binary directory for the given prefix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.build_tarballs-NTuple{8,Any}","page":"Reference","title":"BinaryBuilder.build_tarballs","text":"build_tarballs(ARGS, src_name, src_version, sources, script, platforms,\n               products, dependencies; kwargs...)\n\nThis should be the top-level function called from a build_tarballs.jl file. It takes in the information baked into a build_tarballs.jl file such as the sources to download, the products to build, etc... and will automatically download, build and package the tarballs, generating a build.jl file when appropriate.  Note that ARGS should be the top-level Julia ARGS command- line arguments object.  This function does some rudimentary parsing of the ARGS, call it with --help in the ARGS to see what it can do.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.collapse_symlinks-Tuple{Array{String,1}}","page":"Reference","title":"BinaryBuilder.collapse_symlinks","text":"collapse_symlinks(files::Vector{String})\n\nGiven a list of files, prune those that are symlinks pointing to other files within the list.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.collect_files","page":"Reference","title":"BinaryBuilder.collect_files","text":"collect_files(path::AbstractString, predicate::Function = f -> true)\n\nFind all files that satisfy predicate() when the full path to that file is passed in, returning the list of file paths.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.collect_stderr-Tuple{OutputCollector}","page":"Reference","title":"BinaryBuilder.collect_stderr","text":"collect_stderr(collector::OutputCollector)\n\nReturns all stderr lines collected by this collector so far.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.collect_stdout-Tuple{OutputCollector}","page":"Reference","title":"BinaryBuilder.collect_stdout","text":"collect_stdout(collector::OutputCollector)\n\nReturns all stdout lines collected by this collector so far.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.expand_cxxstring_abis-Tuple{Platform}","page":"Reference","title":"BinaryBuilder.expand_cxxstring_abis","text":"expand_cxxstring_abis(p::Platform)\n\nGiven a Platform, returns an array of Platforms with a spread of identical entries with the exception of the cxxstring_abi member of the CompilerABI struct within the Platform.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.  If the given Platform already specifies a GCC version (as opposed to nothing) only that Platform is returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.expand_gfortran_versions-Tuple{Platform}","page":"Reference","title":"BinaryBuilder.expand_gfortran_versions","text":"expand_gfortran_versions(p::Platform)\n\nGiven a Platform, returns an array of Platforms with a spread of identical entries with the exception of the gcc_version member of the CompilerABI struct within the Platform.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.  If the given Platform already specifies a GCC version (as opposed to nothing) only that Platform is returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.includedir-Tuple{Prefix}","page":"Reference","title":"BinaryBuilder.includedir","text":"includedir(prefix::Prefix)\n\nReturns the include directory for the given prefix\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.libdirs","page":"Reference","title":"BinaryBuilder.libdirs","text":"libdirs(prefix::Prefix, platform = platform_key_abi())\n\nReturns the library directories for the given prefix (note that this differs between unix systems and windows systems, and between 32- and 64-bit systems).\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.locate-Tuple{ExecutableProduct,Prefix}","page":"Reference","title":"BinaryBuilder.locate","text":"locate(ep::ExecutableProduct, prefix::Prefix;\n       platform::Platform = platform_key_abi(),\n       verbose::Bool = false,\n       isolate::Bool = false)\n\nIf the given executable file exists and is executable, return its path.\n\nOn all platforms, an ExecutableProduct checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set. On Windows platforms, it will check that the file ends with \".exe\", (adding it on automatically, if it is not already present).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.locate-Tuple{FileProduct,Prefix}","page":"Reference","title":"BinaryBuilder.locate","text":"locate(fp::FileProduct, prefix::Prefix;\n       platform::Platform = platform_key_abi(),\n       verbose::Bool = false,\n       isolate::Bool = false)\n\nIf the given file exists, return its path.  The platform and isolate arguments are is ignored here, but included for uniformity.  For ease of use, we support a limited number of custom variable expansions such as ${target}, and ${nbits}, so that the detection of files within target-specific folders named things like /lib32/i686-linux-musl is simpler.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.locate-Tuple{LibraryProduct,Prefix}","page":"Reference","title":"BinaryBuilder.locate","text":"locate(lp::LibraryProduct, prefix::Prefix;\n       verbose::Bool = false,\n       platform::Platform = platform_key_abi())\n\nIf the given library exists (under any reasonable name) and is dlopen()able, (assuming it was built for the current platform) return its location.  Note that the dlopen() test is only run if the current platform matches the given platform keyword argument, as cross-compiled libraries cannot be dlopen()ed on foreign platforms.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.logdir-Tuple{Prefix}","page":"Reference","title":"BinaryBuilder.logdir","text":"logdir(prefix::Prefix)\n\nReturns the logs directory for the given prefix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.satisfied-Tuple{Product,Prefix}","page":"Reference","title":"BinaryBuilder.satisfied","text":"satisfied(p::Product;\n          platform::Platform = platform_key_abi(),\n          verbose::Bool = false,\n          isolate::Bool = false)\n\nGiven a Product, return true if that Product is satisfied, e.g. whether a file exists that matches all criteria setup for that Product. If isolate is set to true, will isolate all checks from the main Julia process in the event that dlopen()'ing a library might cause issues.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.supported_platforms-Tuple{}","page":"Reference","title":"BinaryBuilder.supported_platforms","text":"supported_platforms(;exclude::Union{Vector{<:Platform},Function}=x->false)\n\nReturn the list of supported platforms as an array of Platforms.  These are the platforms we officially support building for, if you see a mapping in get_shard_hash() that isn't represented here, it's probably because that platform is still considered \"in beta\".\n\nPlatforms can be excluded from the list by specifying an array of platforms to exclude i.e. supported_platforms(exclude=[Windows(:i686),Windows(:x86_64)]) or a function that returns true for exclusions i.e.\n\nislin(x) = typeof(x) == Linux\nsupported_platforms(exclude=islin)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.tail-Tuple{OutputCollector}","page":"Reference","title":"BinaryBuilder.tail","text":"tail(collector::OutputCollector; len::Int = 100, colored::Bool = false)\n\nWrite out the last len lines, optionally writing colored lines.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.tee-Tuple{OutputCollector}","page":"Reference","title":"BinaryBuilder.tee","text":"tee(c::OutputCollector; colored::Bool = false, stream::IO = stdout)\n\nSpawn a background task to incrementally output lines from collector to the standard output, optionally colored.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.temp_prefix-Tuple{Function}","page":"Reference","title":"BinaryBuilder.temp_prefix","text":"temp_prefix(func::Function)\n\nCreate a temporary prefix, passing the prefix into the user-defined function so that build/packaging operations can occur within the temporary prefix, which is then cleaned up after all operations are finished.  If the path provided exists already, it will be deleted.\n\nUsage example:\n\nout_path = abspath(\"./libfoo\")\ntemp_prefix() do p\n    # <insert build steps here>\n\n    # tarball up the built package\n    tarball_path, tarball_hash = package(p, out_path)\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.variable_name-Tuple{Product}","page":"Reference","title":"BinaryBuilder.variable_name","text":"variable_name(p::Product)\n\nReturn the variable name associated with this Product as a string\n\n\n\n\n\n","category":"method"},{"location":"reference/#Pkg.BinaryPlatforms.detect_cxxstring_abi-Tuple{ObjectFile.ObjectHandle,Platform}","page":"Reference","title":"Pkg.BinaryPlatforms.detect_cxxstring_abi","text":"detect_cxxstring_abi(oh::ObjectHandle, platform::Platform)\n\nGiven an ObjectFile, examine its symbols to discover which (if any) C++11 std::string ABI it's using.  We do this by scanning the list of exported symbols, triggering off of instances of St7__cxx11 or _ZNSs to give evidence toward a constraint on cxx11, cxx03 or neither.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Pkg.BinaryPlatforms.detect_libgfortran_version-Tuple{ObjectFile.ObjectHandle,Platform}","page":"Reference","title":"Pkg.BinaryPlatforms.detect_libgfortran_version","text":"detect_libgfortran_version(oh::ObjectHandle, platform::Platform)\n\nGiven an ObjectFile, examine its dynamic linkage to discover which (if any) libgfortran it's linked against.  The major SOVERSION will determine which GCC version we're restricted to.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Pkg.BinaryPlatforms.detect_libstdcxx_version-Tuple{ObjectFile.ObjectHandle,Platform}","page":"Reference","title":"Pkg.BinaryPlatforms.detect_libstdcxx_version","text":"detect_libstdcxx_version(oh::ObjectHandle, platform::Platform)\n\nGiven an ObjectFile, examine its dynamic linkage to discover which (if any) libgfortran it's linked against.  The major SOVERSION will determine which GCC version we're restricted to.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.wait-Tuple{OutputCollector}","page":"Reference","title":"Base.wait","text":"wait(collector::OutputCollector)\n\nWait for the command and all line streams within an OutputCollector to finish their respective tasks and be ready for full merging.  Return the success of the underlying process.  Prints out the last 10 lines of the process if it does not complete successfully unless the OutputCollector was created as verbose.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.abi_agnostic-Union{Tuple{P}, Tuple{P}} where P<:Platform","page":"Reference","title":"BinaryBuilder.abi_agnostic","text":"abi_agnostic(p::Platform)\n\nStrip out the CompilerABI portion of a Platform, making it \"ABI agnostic\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.accept_apple_sdk-Tuple{IO,IO}","page":"Reference","title":"BinaryBuilder.accept_apple_sdk","text":"accept_apple_sdk(ins::IO, outs::IO) -> Bool\n\nAsk the user whether they accept the terms of the macOS SDK, and return a boolean with their choice.  Write messages to outs, read input from ins.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.alive-Tuple{BinaryBuilder.LineStream}","page":"Reference","title":"BinaryBuilder.alive","text":"alive(s::LineStream)\n\nReturns true if the task owned by this LineStream is still processing output from an underlying Pipe.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.analyze_instruction_set-Tuple{ObjectFile.ObjectHandle,Platform}","page":"Reference","title":"BinaryBuilder.analyze_instruction_set","text":"analyze_instruction_set(oh::ObjectHandle, platform::Platform; verbose::Bool = false)\n\nAnalyze the instructions within the binary located at the given path for which minimum instruction set it requires, taking note of groups of instruction sets used such as avx, sse4.2, i486, etc....\n\nSome binary files (such as libopenblas) contain multiple versions of functions, internally determining which version to call by using the cpuid instruction to determine processor support.  In an effort to detect this, we make note of any usage of the cpuid instruction, disabling our minimum instruction set calculations if such an instruction is found, and notifying the user of this if verbose is set to true.\n\nNote that this function only really makes sense for x86/x64 binaries.  Don't run this on armv7l, aarch64, ppc64le etc... binaries and expect it to work.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.artifact_name-Tuple{BinaryBuilder.CompilerShard}","page":"Reference","title":"BinaryBuilder.artifact_name","text":"artifact_name(cs::CompilerShard)\n\nReturn the bound artifact name for a particular shard.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.canonicalize_file_url-Tuple{Any}","page":"Reference","title":"BinaryBuilder.canonicalize_file_url","text":"Canonicalize URL to a file within a GitHub repo\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.canonicalize_source_url-Tuple{Any}","page":"Reference","title":"BinaryBuilder.canonicalize_source_url","text":"Canonicalize a GitHub repository URL\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.change_script!-Tuple{Any,Any}","page":"Reference","title":"BinaryBuilder.change_script!","text":"Change the script. This will invalidate all platforms to make sure we later\nverify that they still build with the new script.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.check_license","page":"Reference","title":"BinaryBuilder.check_license","text":"check_license(prefix, src_name; verbose::Bool = false,, silent::Bool = false)\n\nCheck that there are license files for the project called src_name in the prefix.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.choose_shards-Tuple{Platform}","page":"Reference","title":"BinaryBuilder.choose_shards","text":"choose_shards(p::Platform; rootfs_build, ps_build, GCC_builds,\n                           LLVM_builds, archive_type)\n\nThis method chooses, given a Platform, which shards to download, extract and mount, returning a list of CompilerShard objects.  At the moment, this always consists of four shards, but that may not always be the case.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.chown_cleanup-Tuple{BinaryBuilder.DockerRunner}","page":"Reference","title":"BinaryBuilder.chown_cleanup","text":"chown_cleanup(dr::DockerRunner)\n\nOn Linux, the user id inside of the docker container doesn't correspond to ours on the outside, so permissions get all kinds of screwed up.  To fix this, we have to chown -R $(id -u):$(id -g) $prefix, which really sucks, but is still better than nothing.  This is why we prefer the UserNSRunner on Linux.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.clone-Tuple{String,String}","page":"Reference","title":"BinaryBuilder.clone","text":"clone(url::String, source_path::String)\n\nClone a git repository hosted at url into source_path, with a progress bar displayed to stdout.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.compress_dir-Tuple{AbstractString}","page":"Reference","title":"BinaryBuilder.compress_dir","text":"compress_dir(dir::AbstractString;\n             compressor_stream = GzipCompressorStream,\n             level::Int = 9,\n             extension::AbstractString = \".gz\",\n             verbose::Bool = false)\n\nCompress all files in dir using the specified compressor_stream with compression level equal to level, appending extension to the filenames. Remove the original uncompressed files at the end.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.create_and_bind_mutable_artifact!-Tuple{Function,String}","page":"Reference","title":"BinaryBuilder.create_and_bind_mutable_artifact!","text":"create_and_bind_mutable_artifact!(f::Function, art_name::String)\n\nCreate (and bind) an artifact to MutableArtifacts.toml in one fell swoop. Used in things like .squashfs UID remapping and BB wizard state serialization.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.download_all_artifacts-Tuple{}","page":"Reference","title":"BinaryBuilder.download_all_artifacts","text":"download_all_shards(; verbose::Bool=false)\n\nHelper function to download all shards/helper binaries so that no matter what happens, you don't need an internet connection to build your precious, precious binaries.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.download_source","page":"Reference","title":"BinaryBuilder.download_source","text":"download_source(source::AbstractSource; verbose::Bool = false)\n\nDownload the given source.  All downloads are cached within the BinaryBuilder downloads storage directory.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.download_source-Tuple{BinaryBuilder.WizardState}","page":"Reference","title":"BinaryBuilder.download_source","text":"download_source(state::WizardState)\n\nAsk the user where the source code is coming from, then download and record the relevant parameters, returning the source url, the local path it is stored at after download, and a hash identifying the version of the code. In the case of a git source URL, the hash will be a git treeish identifying the exact commit used to build the code, in the case of a tarball, it is the sha256 hash of the tarball itself.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.edit_script-Tuple{BinaryBuilder.WizardState,AbstractString}","page":"Reference","title":"BinaryBuilder.edit_script","text":"edit_script(state::WizardState, script::AbstractString)\n\nFor consistency (and security), use the sandbox for editing a script, launching vi within an interactive session to edit a buildscript.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.filter_object_files-Tuple{Any}","page":"Reference","title":"BinaryBuilder.filter_object_files","text":"filter_object_files(files)\n\nGiven a list of files, filter out any that cannot be opened by readmeta() from ObjectFile.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.gcc_version-Tuple{CompilerABI,Array{BinaryBuilder.GCCBuild,1}}","page":"Reference","title":"BinaryBuilder.gcc_version","text":"gcc_version(cabi::CompilerABI, GCC_builds::Vector{GCCBuild})\n\nReturns the closest matching GCC version number for the given CompilerABI representing a particular platform, from the given set of options.  If no match is found, returns an empty list.  This method assumes that cabi represents a platform that binaries will be run on, and thus versions are always rounded down; e.g. if the platform supports a libstdc++ version that corresponds to GCC 5.1.0, but the only GCC versions available to be picked from are 4.8.5 and 5.2.0, it will return 4.8.5, as binaries compiled with that version will run on this platform, whereas binaries compiled with 5.2.0 may not.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.generate_compiler_wrappers!-Tuple{Platform}","page":"Reference","title":"BinaryBuilder.generate_compiler_wrappers!","text":"generate_compiler_wrappers!(platform::Platform; bin_path::AbstractString,\n                            host_platform::Platform = Linux(:x86_64; libc=:musl),\n                            rust_platform::Platform = Linux(:x86_64; libc=:glibc),\n                            compilers::Vector{Symbol} = [:c],\n                            allow_unsafe_flags::Bool = false)\n\nWe generate a set of compiler wrapper scripts within our build environment to force all build systems to honor the necessary sets of compiler flags to build for our systems. Note that while platform_envs() sets many environment variables, those values are intended to be optional/overridable.  These values, while still overridable by directly invoking a compiler binary directly (e.g. /opt/{target}/bin/{target}-gcc), are much more difficult to override, as the flags embedded in these wrappers are absolutely necessary, and even simple programs will not compile without them.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.generate_per_uid_squashfs","page":"Reference","title":"BinaryBuilder.generate_per_uid_squashfs","text":"generate_per_uid_squashfs(cs, new_uid = getuid())\n\nIn order for the sandbox to work well, we need to have the uids of the squashfs images match the uid of the current unprivileged user.  Unfortunately there is no mount-time option to do this for us.  Fortunately, squashfs is simple enough that if the ID table is uncompressed, we can just manually patch the uids to be what we need.  This function performs this operation, by rewriting all UIDs and GIDs to the given new_uid (which defaults to the current user's UID)..\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.get_compilers_versions-Tuple{}","page":"Reference","title":"BinaryBuilder.get_compilers_versions","text":"get_compilers_versions(; compilers = [:c])\n\nReturn the script string that is used to print the versions of the given compilers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.get_concrete_platform-Tuple{Platform,Array{BinaryBuilder.CompilerShard,1}}","page":"Reference","title":"BinaryBuilder.get_concrete_platform","text":"get_concrete_platform(platform::Platform, shards::Vector{CompilerShard})\n\nReturn the concrete platform for the given platform based on the GCC compiler ABI in the shards.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.get_concrete_platform-Tuple{Platform}","page":"Reference","title":"BinaryBuilder.get_concrete_platform","text":"get_concrete_platform(platform::Platform;\n                      preferred_gcc_version = nothing,\n                      preferred_llvm_version = nothing,\n                      compilers = nothing)\n\nReturn the concrete platform for the given platform based on the GCC compiler ABI.  The set of shards is chosen by the keyword arguments (see choose_shards).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.get_mutable_artifact_path-Tuple{String}","page":"Reference","title":"BinaryBuilder.get_mutable_artifact_path","text":"get_mutable_artifact_path(art_name::String)\n\nConvenience wrapper to get an artifact bound within MutableArtifacts.toml. Returns nothing if artifact not bound yet.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.getgid-Tuple{}","page":"Reference","title":"BinaryBuilder.getgid","text":"getgid()\n\nWrapper around libc's getgid() function\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.getuid-Tuple{}","page":"Reference","title":"BinaryBuilder.getuid","text":"getuid()\n\nWrapper around libc's getuid() function\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.import_docker_image-Tuple{BinaryBuilder.CompilerShard,String}","page":"Reference","title":"BinaryBuilder.import_docker_image","text":"import_docker_image(rootfs::CompilerShard; verbose::Bool = false)\n\nChecks to see if the given rootfs has been imported into docker yet; if it hasn't, then do so so that we can run things like:\n\ndocker run -ti binarybuilder_rootfs:v2018.08.27 /bin/bash\n\nWhich, after all, is the foundation upon which this whole doodad is built.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.instruction_mnemonics-Tuple{AbstractString,Platform}","page":"Reference","title":"BinaryBuilder.instruction_mnemonics","text":"instruction_mnemonics(path::AbstractString, platform::Platform)\n\nDump a binary object with objdump, returning a list of instruction mnemonics for further analysis with analyze_instruction_set().\n\nNote that this function only really makes sense for x86/x64 binaries.  Don't run this on armv7l, aarch64, ppc64le etc... binaries and expect it to work.\n\nThis function returns the list of mnemonics as well as the counts of each, binned by the mapping defined within instruction_categories.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.interactive_build-Tuple{BinaryBuilder.WizardState,Prefix,BinaryBuilder.Runner,AbstractString,Platform}","page":"Reference","title":"BinaryBuilder.interactive_build","text":"interactive_build(state::WizardState, prefix::Prefix,\n                  ur::Runner, build_path::AbstractString)\n\nRuns the interactive shell for building, then captures bash history to save\nreproducible steps for building this source. Shared between steps 3 and 5\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.is_ecryptfs-Tuple{AbstractString}","page":"Reference","title":"BinaryBuilder.is_ecryptfs","text":"is_ecryptfs(path::AbstractString; verbose::Bool=false)\n\nChecks to see if the given path (or any parent directory) is placed upon an ecryptfs mount.  This is known not to work on current kernels, see this bug for more details: https://bugzilla.kernel.org/show_bug.cgi?id=197603\n\nThis method returns whether it is encrypted or not, and what mountpoint it used to make that decision.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.is_for_platform-Tuple{ObjectFile.ObjectHandle,Platform}","page":"Reference","title":"BinaryBuilder.is_for_platform","text":"is_for_platform(h::ObjectHandle, platform::Platform)\n\nReturns true if the given ObjectHandle refers to an object of the given platform; E.g. if the given platform is for AArch64 Linux, then h must be an ELFHandle with h.header.e_machine set to ELF.EM_AARCH64.\n\nIn particular, this method and platform_for_object() both exist because the latter is not smart enough to deal with :glibc and :musl yet.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.is_mounted-Tuple{BinaryBuilder.CompilerShard,AbstractString}","page":"Reference","title":"BinaryBuilder.is_mounted","text":"is_mounted(cs::CompilerShard, build_prefix::String)\n\nReturn true if the given shard is mounted.  Uses run() so will error out if something goes awry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.is_troublesome_library_link-Tuple{AbstractString,Platform}","page":"Reference","title":"BinaryBuilder.is_troublesome_library_link","text":"is_troublesome_library_link(libname::AbstractString, platform::Platform)\n\nReturn true if depending on libname is known to cause problems at runtime, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.macos_sdk_already_installed-Tuple{}","page":"Reference","title":"BinaryBuilder.macos_sdk_already_installed","text":"macos_sdk_already_installed()\n\nReturns true if any piece of the MacOS SDK is already installed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.map_target-Tuple{BinaryBuilder.CompilerShard}","page":"Reference","title":"BinaryBuilder.map_target","text":"map_target(cs::CompilerShard)\n\nReturn the location this compiler shard should be mounted at.  We basically analyze the name and platform of this shard and return a path based on that.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.match_files-Tuple{BinaryBuilder.WizardState,Prefix,Platform,Array{T,1} where T}","page":"Reference","title":"BinaryBuilder.match_files","text":"match_files(state::WizardState, prefix::Prefix,\n            platform::Platform, files::Vector; silent::Bool = false)\n\nInspects all binary files within a prefix, matching them with a given list of files, complaining if there are any files that are not properly matched and returning the set of normalized names that were not matched, or an empty set if all names were properly matched.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.minimum_instruction_set-Tuple{Dict,Bool}","page":"Reference","title":"BinaryBuilder.minimum_instruction_set","text":"minimum_instruction_set(counts::Dict, is_64bit::Bool)\n\nThis function returns the minimum instruction set required, depending on whether the object file being pointed to is a 32-bit or 64-bit one:\n\nFor 32-bit object files, this returns one of [:pentium4, :prescott]\nFor 64-bit object files, this returns one of [:core2, :sandybridge, :haswell]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.mount-Tuple{BinaryBuilder.CompilerShard,AbstractString}","page":"Reference","title":"BinaryBuilder.mount","text":"mount(cs::CompilerShard, build_prefix::String)\n\nMount a compiler shard, if possible.  Uses run() so will error out if something goes awry.  Note that this function only does something when using a .squashfs shard, with a UserNS or Docker runner, on Linux. All other combinations of shard archive type, runner and platform result in a no-op from this function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.normalize_name-Tuple{AbstractString}","page":"Reference","title":"BinaryBuilder.normalize_name","text":"normalize_name(file::AbstractString)\n\nGiven a filename, normalize it, stripping out extensions.  E.g. the file path \"foo/libfoo.tar.gz\" would get mapped to \"libfoo\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.pick_preferred_platform-Tuple{Any}","page":"Reference","title":"BinaryBuilder.pick_preferred_platform","text":"Pick the first platform for use to run on. We prefer Linux x86_64 because that's generally the host platform, so it's usually easiest. After that we go by the following preferences:\n\nOS (in order): Linux, Windows, OSX\nArchitecture: x86_64, i686, aarch64, powerpc64le, armv7l\nThe first remaining after this selection\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.platform_envs-Tuple{Platform,AbstractString}","page":"Reference","title":"BinaryBuilder.platform_envs","text":"platform_envs(platform::Platform)\n\nGiven a platform, generate a Dict mapping representing all the environment variables to be set within the build environment to force compiles toward the defined target architecture.  Examples of things set are PATH, CC, RANLIB, as well as nonstandard things like target.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.platform_for_object-Tuple{ObjectFile.ObjectHandle}","page":"Reference","title":"BinaryBuilder.platform_for_object","text":"platform_for_object(oh::ObjectHandle)\n\nReturns the platform the given ObjectHandle should run on.  E.g. if the given ObjectHandle is an x86_64 Linux ELF object, this function will return Linux(:x86_64).  This function does not yet distinguish between different libc's such as :glibc and :musl.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.preferred_cxxstring_abi-Tuple{Platform,BinaryBuilder.CompilerShard}","page":"Reference","title":"BinaryBuilder.preferred_cxxstring_abi","text":"preferred_cxxstring_abi(platform::Platform, shard::CompilerShard;\n                        gcc_builds::Vector{GCCBuild} = available_gcc_builds)\n\nReturn the C++ string ABI preferred by the given platform or GCCBootstrap shard.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.preferred_libgfortran_version-Tuple{Platform,BinaryBuilder.CompilerShard}","page":"Reference","title":"BinaryBuilder.preferred_libgfortran_version","text":"preferred_libgfortran_version(platform::Platform, shard::CompilerShard;\n                              gcc_builds::Vector{GCCBuild} = available_gcc_builds)\n\nReturn the libgfortran version preferred by the given platform or GCCBootstrap shard.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.print_autoconf_hint-Tuple{BinaryBuilder.WizardState}","page":"Reference","title":"BinaryBuilder.print_autoconf_hint","text":"print_autoconf_hint(state::WizardState)\n\nPrint a hint for projects that use autoconf to have a good ./configure line.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.provide_hints-Tuple{BinaryBuilder.WizardState,AbstractString}","page":"Reference","title":"BinaryBuilder.provide_hints","text":"provide_hints(state::WizardState, path::AbstractString)\n\nGiven an unpacked source directory, provide hints on how a user might go about building the binary bounty they so richly desire.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.readuntil_many-Tuple{IO,Any}","page":"Reference","title":"BinaryBuilder.readuntil_many","text":"readuntil_many(s::IO, delims)\n\nGiven a collection of delimiter characters, read from s until one of those delimiters is reached, or we reach the end of s.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.runshell","page":"Reference","title":"BinaryBuilder.runshell","text":"runshell(platform::Platform = platform_key_abi())\n\nLaunch an interactive shell session within the user namespace, with environment setup to target the given platform.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.setup_dependencies-Tuple{Prefix,Array{Pkg.Types.PackageSpec,1},Platform}","page":"Reference","title":"BinaryBuilder.setup_dependencies","text":"setup_dependencies(prefix::Prefix, dependencies::Vector{PackageSpec})\n\nGiven a list of JLL package specifiers, install their artifacts into the build prefix. The artifacts are installed into the global artifact store, then copied into a temporary location, then finally symlinked into the build prefix.  This allows us to (a) save download bandwidth by not downloading the same artifacts over and over again, (b) maintain separation in the event of catastrophic containment failure, avoiding hosing the main system if a build script decides to try to modify the dependent artifact files, and (c) keeping a record of what files are a part of dependencies as opposed to the package being built, in the form of symlinks to a specific artifacts directory.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.setup_workspace-Tuple{AbstractString,Array{T,1} where T}","page":"Reference","title":"BinaryBuilder.setup_workspace","text":"setup_workspace(build_path::String, sources::Vector{SetupSource};\n                verbose::Bool = false)\n\nSets up a workspace within build_path, creating the directory structure needed by further steps, unpacking the source within build_path, and defining the environment variables that will be defined within the sandbox environment.\n\nThis method returns the Prefix to install things into, and the runner that can be used to launch commands within this workspace.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.shard_mappings-Tuple{Array{BinaryBuilder.CompilerShard,1}}","page":"Reference","title":"BinaryBuilder.shard_mappings","text":"shard_mappings(shards::Vector{CompilerShard})\n\nReturn the default mappings for a set of compiler shards\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.shard_path-Tuple{BinaryBuilder.CompilerShard}","page":"Reference","title":"BinaryBuilder.shard_path","text":"shard_path(cs::CompilerShard)\n\nReturn the path to this shard on-disk; for unpacked shards, this is a directory. For squashfs shards, this is a file.  This will not cause a shard to be downloaded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.step1-Tuple{BinaryBuilder.WizardState}","page":"Reference","title":"BinaryBuilder.step1","text":"step1(state::WizardState)\n\nIt all starts with a single step, the unabashed ambition to leave your current stability and engage with the universe on a quest to create something new, beautiful and unforeseen.  It all ends with compiler errors.\n\nThis step selects the relevant platform(s) for the built binaries.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.step2-Tuple{BinaryBuilder.WizardState}","page":"Reference","title":"BinaryBuilder.step2","text":"step2(state::WizardState)\n\nThis step obtains the source code to be built and required binary dependencies.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.step34-Tuple{BinaryBuilder.WizardState}","page":"Reference","title":"BinaryBuilder.step34","text":"step34(state::WizardState)\n\nStarts initial build for Linux x86_64, which is our initial test target platform.  Sources that build properly for this platform continue on to attempt builds for more complex platforms.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.step3_audit-Tuple{BinaryBuilder.WizardState,Platform,String}","page":"Reference","title":"BinaryBuilder.step3_audit","text":"step3_audit(state::WizardState, platform::Platform, prefix::Prefix)\n\nAudit the prefix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.step3_interactive-Tuple{BinaryBuilder.WizardState,Prefix,Platform,BinaryBuilder.Runner,AbstractString,Array{String,1}}","page":"Reference","title":"BinaryBuilder.step3_interactive","text":"step3_interactive(state::WizardState, prefix::Prefix, platform::Platform,\n                  ur::Runner, build_path::AbstractString)\n\nThe interactive portion of step3, moving on to either rebuild with an edited script or proceed to step 4.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.step3_retry-Tuple{BinaryBuilder.WizardState}","page":"Reference","title":"BinaryBuilder.step3_retry","text":"step3_retry(state::WizardState)\n\nRebuilds the initial Linux x86_64 build after things like editing the script file manually, etc...\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.step4-Tuple{BinaryBuilder.WizardState,BinaryBuilder.Runner,Platform,AbstractString,Prefix}","page":"Reference","title":"BinaryBuilder.step4","text":"step4(state::WizardState, ur::Runner, platform::Platform,\n      build_path::AbstractString, prefix::Prefix)\n\nThe fourth step selects build products after the first build is done\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.symlink_soname_lib-Tuple{AbstractString}","page":"Reference","title":"BinaryBuilder.symlink_soname_lib","text":"symlink_soname_lib(path::AbstractString)\n\nWe require that all shared libraries are accessible on disk through their SONAME (if it exists).  While this is almost always true in practice, it doesn't hurt to make doubly sure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.translate_symlinks-Tuple{AbstractString}","page":"Reference","title":"BinaryBuilder.translate_symlinks","text":"translate_symlinks(root::AbstractString; verbose::Bool=false)\n\nWalks through the root directory given within root, finding all symlinks that point to an absolute path within root, and rewriting them to be a relative symlink instead, increasing relocatability.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.uname-Tuple{}","page":"Reference","title":"BinaryBuilder.uname","text":"uname()\n\nOn Linux systems, return the strings returned by the uname() function in libc\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.unmount-Tuple{BinaryBuilder.CompilerShard,String}","page":"Reference","title":"BinaryBuilder.unmount","text":"unmount(cs::CompilerShard, build_prefix::String)\n\nUnmount a compiler shard from a given build prefix, if possible.  Uses run() so will error out if something goes awry.  Note that this function only does something when using a squashfs shard on Linux.  All other combinations of shard archive type and platform result in a no-op.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.update_linkage-Tuple{Prefix,Platform,AbstractString,Any,Any}","page":"Reference","title":"BinaryBuilder.update_linkage","text":"update_linkage(prefix::Prefix, platform::Platform, path::AbstractString,\n               old_libpath, new_libpath; verbose::Bool = false)\n\nGiven a binary object located at path within prefix, update its dynamic linkage to point to new_libpath instead of old_libpath.  This is done using a tool within the cross-compilation environment such as install_name_tool on MacOS or patchelf on Linux.  Windows platforms are completely skipped, as they do not encode paths or RPaths within their executables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.versioninfo-Tuple{}","page":"Reference","title":"BinaryBuilder.versioninfo","text":"versioninfo()\n\nHelper function to print out some debugging information\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.warn_deadlinks-Tuple{AbstractString}","page":"Reference","title":"BinaryBuilder.warn_deadlinks","text":"warn_deadlinks(root::AbstractString)\n\nWalks through the given root directory, finding broken symlinks and warning the user about them.  This is used to catch instances such as a build recipe copying a symlink that points to a dependency; by doing so, it implicitly breaks relocatability.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.yggdrasil_build_tarballs_path-Tuple{Any}","page":"Reference","title":"BinaryBuilder.yggdrasil_build_tarballs_path","text":"yggdrasil_build_tarballs_path(name::String)\n\nReturn the relative path within an Yggdrasil clone where this project (given its name) would be stored.  This is useful for things like generating the build_tarballs.jl file and checking to see if it already exists, etc...\n\nNote that we do not allow case-ambiguities within Yggdrasil, we check for this using the utility function case_insensitive_file_exists(path).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.yggdrasil_deploy","page":"Reference","title":"BinaryBuilder.yggdrasil_deploy","text":"yggdrasil_deploy(state::WizardState)\n\nWrite out a WizardState to a build_tarballs.jl in an Yggdrasil clone, then open a pull request against Yggdrasil.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.yn_prompt","page":"Reference","title":"BinaryBuilder.yn_prompt","text":"yn_prompt(state::WizardState, question::AbstractString, default = :y)\n\nPerform a [Y/n] or [y/N] question loop, using default to choose between the prompt styles, and looping until a proper response (e.g. \"y\", \"yes\", \"n\" or \"no\") is received.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Pkg.PlatformEngines.package-Tuple{Prefix,AbstractString,VersionNumber}","page":"Reference","title":"Pkg.PlatformEngines.package","text":"package(prefix::Prefix, output_base::AbstractString,\n        version::VersionNumber;\n        platform::Platform = platform_key_abi(),\n        verbose::Bool = false, force::Bool = false)\n\nBuild a tarball of the prefix, storing the tarball at output_base, appending a version number, a platform-dependent suffix and a file extension. If no platform is given, defaults to current platform. Runs an audit() on the prefix, to ensure that libraries can be dlopen()'ed, that all dependencies are located within the prefix, etc... See the audit() documentation for a full list of the audit steps.  Returns the full path to and hash of the generated tarball.\n\n\n\n\n\n","category":"method"},{"location":"troubleshooting/#Build-Troubleshooting-1","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"This page collects some known build errors and trick how to fix them.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"If you have additional tips, please submit a PR with suggestions.","category":"page"},{"location":"troubleshooting/#All-platforms-1","page":"Build Troubleshooting","title":"All platforms","text":"","category":"section"},{"location":"troubleshooting/#Header-files-of-the-dependencies-can't-be-found-1","page":"Build Troubleshooting","title":"Header files of the dependencies can't be found","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Sometimes the build system can't find the header files of the dependencies, even if they're properly installed.  When this happens, you have to inform the C/C++ preprocessor where the files are.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"For example, if the project uses Autotools you can set the CPPFLAGS environment variable:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"export CPPFLAGS=\"-I${prefix}/include\"\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs}\nmake install","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"See for example Cairo build script.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"If instead the project uses CMake you'll need to use a different environment variable, since CMake ignores CPPFLAGS.  If the compiler that can't find the header file is the C one, you need to add the path to the CFLAGS variable (e.g., CFLAGS=\"-I${prefix}/include\"), in case it's the C++ one you have to set the CXXFLAGS variable (e.g., CXXFLAGS=\"-I${prefix}/include\").","category":"page"},{"location":"troubleshooting/#Libraries-of-the-dependencies-can't-be-found-1","page":"Build Troubleshooting","title":"Libraries of the dependencies can't be found","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Like in the section above, it may happen that the build system fails to find the libraries of the dependencies, even when they're installed to the right place.  In these case, you have to inform the linker where the libraries are by setting the LDFLAGS environment variable:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"export LDFLAGS=\"-L${libdir}\"\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs}\nmake install","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"See for example libwebp build script (in this case this was needed only when building for FreeBSD).","category":"page"},{"location":"troubleshooting/#Old-Autoconf-helper-scripts-1","page":"Build Troubleshooting","title":"Old Autoconf helper scripts","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Packages using Autoconf come with some helper scripts – like config.sub and config.guess – that the upstream developers need to keep up-to-date in order to get the latest improvements.  Some packages ship very old copies of these scripts, that for example don't know about the Musl C library.  In that case, after running ./configure you may get an error like","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"checking build system type... Invalid configuration `x86_64-linux-musl': system `musl' not recognized\nconfigure: error: /bin/sh ./config.sub x86_64-linux-musl failed","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"The BinaryBuilder environment provides the utility update_configure_scripts to automatically update these scripts, call it before ./configure:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"update_configure_scripts\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nproc}\nmake install","category":"page"},{"location":"troubleshooting/#Building-with-an-old-GCC-version-a-library-that-has-dependencies-built-with-newer-GCC-versions-1","page":"Build Troubleshooting","title":"Building with an old GCC version a library that has dependencies built with newer GCC versions","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"The keyword argument preferred_gcc_version to the build_tarballs function allows you to select a newer compiler to build a library, if needed.  Pure C libraries have good compatibility so that a library built with a newer compiler should be able to run on a system using an older GCC version without problems.  However, keep in mind that each GCC version in BinaryBuilder.jl comes bundled with a specific version of binutils  – which provides the ld linker – see this table.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"ld is quite picky and a given version of this tool doesn't like to link a library linked with a newer version: this means that if you build a library with, say, GCC v6, you'll need to build all libraries depending on it with GCC >= v6.  If you fail to do so, you'll get a cryptic error like this:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"/opt/x86_64-linux-gnu/bin/../lib/gcc/x86_64-linux-gnu/4.8.5/../../../../x86_64-linux-gnu/bin/ld: /workspace/destdir/lib/libvpx.a(vp8_cx_iface.c.o): unrecognized relocation (0x2a) in section `.text'\n/opt/x86_64-linux-gnu/bin/../lib/gcc/x86_64-linux-gnu/4.8.5/../../../../x86_64-linux-gnu/bin/ld: final link failed: Bad value","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"The solution is to build the downstream libraries with at least the maximum of the GCC versions used by the dependencies:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"build_tarballs(ARGS, name, version, sources, script, platforms, products, dependencies; preferred_gcc_version=v\"8\")","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"For instance, FFMPEG has to be built with GCC v8 because LibVPX requires GCC v8.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Generally speaking, we try to build with the as old as possible version of GCC (v4.8.5 being the oldest one currently available), for maximum compatibility.","category":"page"},{"location":"troubleshooting/#Running-foreign-executables-1","page":"Build Troubleshooting","title":"Running foreign executables","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"The build environment provided by BinaryBuilder is a x86_64-linux-musl, and it can run executables for the following platforms: x86_64-linux-musl, x86_64-linux-gnu, i686-linux-gnu.  For all other platforms, if the build system tries to run a foreign executable you'll get an error, usually something like","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"./foreign.exe: line 1: ELF��\n                       @@xG@8@@@@@@���@�@@����A�A����A�A���@�@: not found\n./foreign.exe: line 1: syntax error: unexpected end of file (expecting \")\")","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"This is one of worst cases when cross-compiling, and there isn't a simple solution.  You have to look into the build process to see if running the executable can be skipped (see for example the patch to not run dot in #351), or replaced by something else.  If the executable is a compile-time only utility, try to build it with the native compiler (see for example the patch to build a native mkdefs in #351)","category":"page"},{"location":"troubleshooting/#PowerPC-Linux-1","page":"Build Troubleshooting","title":"PowerPC Linux","text":"","category":"section"},{"location":"troubleshooting/#Shared-library-not-built-1","page":"Build Troubleshooting","title":"Shared library not built","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Sometimes the shared library for powerpc64le-linux-gnu is not built after a successful compilation, and audit fails because only the static library has been compiled.  If the build uses Autotools, this most likely happens because the configure script was generated with a very old version of Autotools, which didn't know how to build shared libraries for this system.  The trick here is to regenerate the configure script with autoreconf:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"autoreconf -vi\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nproc}\nmake install","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"See for example the builder for Giflib.  If you need to regenerate configure, you'll probably need to run update_configure_scripts to make other platforms work as well.","category":"page"},{"location":"troubleshooting/#FreeBSD-1","page":"Build Troubleshooting","title":"FreeBSD","text":"","category":"section"},{"location":"troubleshooting/#undefined-reference-to-backtrace_symbols'-1","page":"Build Troubleshooting","title":"undefined reference to `backtrace_symbols'","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"If compilation fails because of the following errors","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"undefined reference to `backtrace_symbols'\nundefined reference to `backtrace'","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"then you need to link to execinfo:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"if [[ \"${target}\" == *-freebsd* ]]; then\n    export LDFLAGS=\"-lexecinfo\"\nfi\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs}\nmake install","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"See for example #354 and #982.","category":"page"},{"location":"troubleshooting/#Windows-1","page":"Build Troubleshooting","title":"Windows","text":"","category":"section"},{"location":"troubleshooting/#Libtool-refuses-to-build-shared-library-because-of-undefined-symbols-1","page":"Build Troubleshooting","title":"Libtool refuses to build shared library because of undefined symbols","text":"","category":"section"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"When building for Windows, sometimes libtool refuses to build the shared library because of undefined symbols.  When this happens, compilation is successful but BinaryBuilder's audit can't find the expected LibraryProducts.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"In the log of compilation you can usually find messages like","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"libtool: warning: undefined symbols not allowed in i686-w64-mingw32 shared libraries; building static only","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"or","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"libtool:   error: can't build i686-w64-mingw32 shared library unless -no-undefined is specified","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"In these cases you have to pass the -no-undefined option to the linker, as explicitly suggested by the second message.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"A proper fix requires to add the -no-undefined flag to the LDFLAGS of the corresponding libtool archive in the Makefile.am file.  For example, this is done in CALCEPH, ERFA, and libsharp2.","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"A quick and dirty alternative to patching the Makefile.am file is to pass LDFLAGS=-no-undefined only to make:","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"FLAGS=()\nif [[ \"${target}\" == *-mingw* ]]; then\n    FLAGS+=(LDFLAGS=\"-no-undefined\")\nfi\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs} \"${FLAGS[@]}\"\nmake install","category":"page"},{"location":"troubleshooting/#","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Note that setting LDFLAGS=-no-undefined before ./configure would make this fail because it would run a command like cc -no-undefined conftest.c, which upsets the compiler).  See for example #170, #354.","category":"page"},{"location":"#BinaryBuilder.jl-1","page":"Home","title":"BinaryBuilder.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The purpose of the BinaryBuilder.jl Julia package is to provide a system for compiling 3rd-party binary dependencies that should work anywhere the official Julia distribution does.  In particular, using this package you will be able to compile your large pre-existing codebases of C, C++, Fortran, Rust, Go, etc... software into binaries that can be downloaded and loaded/run on a very wide range of machines.  As it is difficult (and often expensive) to natively compile software packages across the growing number of platforms that this package will need to support, we focus on providing a set of Linux-hosted cross-compilers.  This package will therefore set up an environment to perform cross-compilation for all of the major platforms, and will do its best to make the compilation process as painless as possible.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Note that at this time, BinaryBuilder itself runs on Linux x86_64 and macOS x86_64 systems only, with Windows support under active development.  On macOS and Windows, you must have docker installed as the backing virtualization engine.  Note that Docker Desktop is the recommended version; if you have Docker Machine installed it may not work correctly or may need additional configuration.","category":"page"},{"location":"#Project-flow-1","page":"Home","title":"Project flow","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Suppose that you have a Julia package Foo.jl which wants to use a compiled libfoo shared library.  As your first step in writing Foo.jl, you may compile libfoo locally on your own machine with your system compiler, then using Libdl.dlopen() to open the library, and ccall() to call into the exported functions.  Once you have written your C bindings in Julia, you will naturally desire to share the fruits of your labor with the rest of the world, and this is where BinaryBuilder can help you.  Not only will BinaryBuilder aid you in constructing compiled versions of all your dependencies, but it will also build a wrapper Julia package (referred to as a JLL package) to aid in installation, versioning, and build product localization.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The first step in the BinaryBuilder journey is to create a build recipe, usually named build_tarballs.jl.  The Julia community curates a tree of build recipes, Yggdrasil, that already contains many examples of how to write a build_tarballs.jl file.  These files contain information such as the name, version and source locations for a particular build, as well as the actual steps (in the form of a bash script) and the products that should be generated by the build.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The result of a successful build is an autogenerated JLL package, typically uploaded to the JuliaBinaryWrappers github organization.  Binaries for each version of every build are uploaded to the GitHub releases page of the relevant JLL package.  Finally, a registration request is opened against the General Julia registry, so that packages such as the aforementioned Foo.jl can simply pkg> add libfoo_jll to download the binary artifacts as well as the autogenerated Julia wrapper code.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To generate a build_tarballs.jl file (explained in greater detail below), one can clone Yggdrasil, copy an existing build recipe, modify it, and submit a new PR, or use the BinaryBuilder Wizard to do all of that automatically.  See also the FAQ, build tips, and tricksy gotchas for help with common problems.","category":"page"},{"location":"#Build-scripts-1","page":"Home","title":"Build scripts","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A BinaryBuilder.jl build script (what is often referred to as a build_tarballs.jl file) looks something like this:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using BinaryBuilder\n\nname = \"libfoo\"\nversion = v\"1.0.1\"\nsources = [\n    ArchiveSource(\"<url to source tarball>\", \"sha256 hash\"),\n]\n\nscript = raw\"\"\"\ncd ${WORKSPACE}/srcdir/libfoo-*\nmake -j${nproc}\nmake install\n\"\"\"\n\nplatforms = supported_platforms()\n\nproducts = [\n    LibraryProduct(\"libfoo\", :libfoo),\n    ExecutableProduct(\"fooifier\", :fooifier),\n]\n\ndependencies = [\n    Dependency(\"Zlib_jll\"),\n]\n\nbuild_tarballs(ARGS, name, version, sources, script, platforms, products, dependencies)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This bare-bones snippet first identifies the sources to download and compile (there can be multiple sources listed here), then lists the bash commands to actually build this particular project.  Next, the products are defined, which are the files that must exist at the end of the build, and which are wrapped in the eventual JLL package.  Finally, we pass this information off to build_tarballs(), which takes it all in and runs the builds, placing output tarballs into the ./products directory.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The bash commands contained within script will be executed for each platform that is passed in, so if there are platform differences that need to be addressed in the build script, using if statements and the $target environment variable can be a powerful tool.  See the OpenBLASBuilder build script for an example showcasing this.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"While constructing your own build script is certainly possible, BinaryBuilder.jl supports a more interactive method for building the binary dependencies and capturing the commands used to build it into a build_tarballs.jl file; the Wizard interface.","category":"page"},{"location":"#Wizard-interface-1","page":"Home","title":"Wizard interface","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BinaryBuilder.jl contains a wizard interface that will walk you through constructing a build_tarballs.jl file.  To launch it, run BinaryBuilder.run_wizard(), and follow the instructions on-screen.","category":"page"},{"location":"#How-does-this-all-work?-1","page":"Home","title":"How does this all work?","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"BinaryBuilder.jl wraps a root filesystem that has been carefully constructed so as to provide the set of cross-compilers needed to support the wide array of platforms that Julia runs on.  This RootFS is then used as the chroot jail for a sandboxed process which runs within the RootFS as if that were the whole world.  The workspace containing input source code and (eventually) output binaries is mounted within the RootFS and environment variables are setup such that the appropriate compilers for a particular target platform are used by build tools.","category":"page"},{"location":"tricksy_gotchas/#Tricksy-Gotchas-1","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"","category":"section"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"There are a plethora of gotchas when it comes to binary compilation and distribution that must be appropriately addressed, or the binaries will only work on certain machines and not others.  Here is an incomplete list of things that BinaryBuilder.jl takes care of for you:","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Uniform compiler interface","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"No need to worry about invoking compilers through weird names; just run gcc within the proper environment and you'll get the appropriate cross-compiler.  Triplet-prefixed names (such as x86_64-linux-gnu-gcc) are, of course, also available, and the same version of gcc, g++ and gfortran is used across all platforms.","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"glibc versioning","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"On Linux platforms that use glibc as the C runtime library (at the time of writing, this is the great majority of most desktop and server distros), it is necessary to compile code against a version of glibc that is older than any glibc version it will be run on.  E.g. if your code is compiled against glibc v2.5, it will run on glibc v2.6, but it will not run on glibc v2.4.  Therefore, to maximize compatibility, all code should be compiled against as old a version of glibc as possible.","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"gfortran versioning","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"When compiling FORTRAN code, the gfortran compiler has broken ABI compatibility in the 6.X -> 7.X transition, and the 7.X -> 8.X transition.  This means that code built with gfortran 6.X cannot be linked against code built with gfortran 7.X.  We therefore compile all gfortran code against multiple different gfortran versions, then at runtime decide which to download based upon the currently running process' existing linkage.","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"cxx11 string ABI","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"When switching from the cxx03 standard to cxx11 in GCC 5, the internal layout of std::string objects changed.  This causes incompatibility between C++ code passing strings back and forth across the public interface if they are not built with the same C++ string ABI.  We therefore detect when std::string objects are being passed around, and warn that you need to build two different versions, one with cxx03-style strings (doable by setting -D_GLIBCXX_USE_CXX11_ABI=0 for newer GCC versions) and one with cxx11-style strings.","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Library Dependencies","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"A large source of problems in binary distribution is improper library linkage.  When building a binary object that depends upon another binary object, some operating systems (such as macOS) bake the absolute path to the dependee library into the dependent, whereas others rely on the library being present within a default search path.  BinaryBuilder.jl takes care of this by automatically discovering these errors and fixing them by using the RPATH/RUNPATH semantics of whichever platform it is targeting.  Note that this is technically a build system error, and although we will fix it automatically, it will raise a nice yellow warning during build prefix audit time.","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Embedded absolute paths","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Similar to library dependencies, plain files (and even symlinks) can have the absolute location of files embedded within them.  BinaryBuilder.jl will automatically transform symlinks to files within the build prefix to be the equivalent relative path, and will alert you if any files within the prefix contain absolute paths to the build prefix within them.  While the latter cannot be automatically fixed, it may help in tracking down problems with the software later on.","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Instruction Set Differences","category":"page"},{"location":"tricksy_gotchas/#","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"When compiling for architectures that have evolved over time (such as x86_64), it is important to target the correct instruction set, otherwise a binary may contain instructions that will run on the computer it was compiled on, but will fail rather ungracefully when run on a machine that does not have as new a processor.  BinaryBuilder.jl will automatically disassemble every built binary object and inspect the instructions used, warning the user if a binary is found that does not conform to the agreed-upon minimum instruction set architecture.  It will also notice if the binary contains a cpuid instruction, which is a good sign that the binary is aware of this issue and will internally switch itself to use only available instructions.","category":"page"}]
}
