var documenterSearchIndex = {"docs":
[{"location":"build_tips/#Tips-for-Building-Packages","page":"Build Tips","title":"Tips for Building Packages","text":"","category":"section"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"BinaryBuilder provides a convenient environment to enable cross-platform building. But, many libraries have complicated build scripts that may need to be adapted to support all of the BinaryBuilder targets.","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"If your build fails with some errors, look at the Build Troubleshooting page.","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"If you have additional tips, please submit a PR with suggestions.","category":"page"},{"location":"build_tips/#Initiating-different-shell-commands-based-on-target","page":"Build Tips","title":"Initiating different shell commands based on target","text":"","category":"section"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"Sometimes, you need to adapt build scripts based on the target platform. This can be done within the shell script. Here is an example from OpenBLAS:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"# Set BINARY=32 on i686 platforms and armv7l\nif [[ ${nbits} == 32 ]]; then\n    flags=\"${flags} BINARY=32\"\nfi","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"Here are other examples of scripts with target-specific checks:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"Kaleido - Different steps for Windows and macOS\nLibical - 32-bit check","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"It is also possible to run quite different scripts for each target by running different build scripts for different sets of targets. Here is an example where windows builds are separated from other targets:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"Git","category":"page"},{"location":"build_tips/#Autoconfigure-builds","page":"Build Tips","title":"Autoconfigure builds","text":"","category":"section"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"Autoconfigure builds are generally quite straightforward. Here is a typical approach:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"./configure --prefix=$prefix --build=${MACHTYPE} --host=${target}\nmake -j${nproc}\nmake install","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"Here are examples of autoconfigure build scripts:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"Patchelf\nLibCURL","category":"page"},{"location":"build_tips/#CMake-builds","page":"Build Tips","title":"CMake builds","text":"","category":"section"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"For CMake, the wizard will suggest a template for running CMake. Typically, this will look like:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"cmake -DCMAKE_INSTALL_PREFIX=${prefix} -DCMAKE_TOOLCHAIN_FILE=${CMAKE_TARGET_TOOLCHAIN} -DCMAKE_BUILD_TYPE=Release","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"The toolchain file sets up several CMake environment variables for better cross-platform support, such as CMAKE_SYSROOT, CMAKE_C_COMPILER, etc...  Examples of builds that include CMake parts include:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"JpegTurbo\nSundials\nNeeds to copy *.dll files from ${prefix}/lib to ${libdir} for Windows\nNeeds KLU_LIBRARY_DIR=\"$libdir\", so CMake's find_library can find libraries from KLU","category":"page"},{"location":"build_tips/#Meson-builds","page":"Build Tips","title":"Meson builds","text":"","category":"section"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"BinaryBuilder supports also building with Meson.  Since this is going to be a cross-compilation, you have to specify a Meson cross file:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"meson --cross-file=\"${MESON_TARGET_TOOLCHAIN}\" --buildtype=release","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"After configuring the project with meson, you can then build and install it with","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"ninja -j${nproc}\nninja install","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"The wizard automatically suggests using Meson if the meson.build file is present.","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"Examples of builds performed with Meson include:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"gdk-pixbuf: here meson uses platform-dependent options;\nlibepoxy: this script modifies c_args in the Meson cross file in order to add an include directory;\nxkbcommon.","category":"page"},{"location":"build_tips/#Go-builds","page":"Build Tips","title":"Go builds","text":"","category":"section"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"The Go toolchain provided by BinaryBuilder can be requested by adding :go to the compilers keyword argument to build_tarballs: compilers=[:c, :go].  Go-based packages can usually be built and installed with go:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"go build -o ${bindir}","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"The Go toolchain provided by BinaryBuilder automatically selects the appropriate target.","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"Example of packages using Go:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"pprof: it uses go build to compile the program and manually moves the executable to ${bindir}.","category":"page"},{"location":"build_tips/#Rust-builds","page":"Build Tips","title":"Rust builds","text":"","category":"section"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"The Rust toolchain provided by BinaryBuilder can be requested by adding :rust to the compilers keyword argument to build_tarballs: compilers=[:c, :rust].  Rust-based packages can usually be built with cargo:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"cargo build --release","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"The Rust toolchain provided by BinaryBuilder automatically selects the appropriate target and number of parallel jobs to be used.  Note, however, that you may have to manually install the product in the ${prefix}.  Read the installation instructions of the package in case they recommend a different build procedure.","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"Example of packages using Rust:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"Tokei: it uses cargo build to compile the program and manually moves the executable to ${bindir};\nLibrsvg: it uses a build system based on Autoconf which would internally call cargo build, but the user has to follow the ./configure + make + make install sequence.","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"warn: Warn\nThe Rust toolchain currently used does not work with the i686-w64-mingw32 (32-bit Windows) platform.","category":"page"},{"location":"build_tips/#Editing-files-in-the-wizard","page":"Build Tips","title":"Editing files in the wizard","text":"","category":"section"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"In the wizard, the vim editor is available for editing files. But, it doesn't leave any record in the build script. One generally needs to provide patch files or use something like sed. If a file needs patching, we suggest using git to add the entire worktree to a new repo, make the changes you need, then use git diff -p to output a patch that can be included alongside your build recipe.","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"You can include local files like patches very easily by placing them within a bundled/patches nested directory, and then providing \"./bundled\" as one of the sources for your build.  See, for example, OpenBLAS.","category":"page"},{"location":"build_tips/#Automatic-environment-variables","page":"Build Tips","title":"Automatic environment variables","text":"","category":"section"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"The following environment variables are automatically set in the build environment and should be used to build the project.  Occasionally, you may need to tweak them (e.g., when Using GCC on macOS and FreeBSD).","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"CC: the C cross compiler\nCXX: the C++ cross compiler\nFC: the Fortran cross compiler","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"The above variables point to utilities for the target environment.  To reference the utilities for the host environment either prepend HOST or append _HOST.  For example, HOSTCC and CC_HOST point to the native C compiler.","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"These are other environment variables that you may occasionally need to set during a build","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"CFLAGS: options for the C compiler\nCXXFLAGS: options for the C++ compiler\nCPPFLAGS: options for the C pre-processor\nLDFLAGS: options for the linker\nPKG_CONFIG_PATH: a colon-separated list of directories to search for .pc files\nPKG_CONFIG_SYSROOT_DIR: modifies -I and -L to use the directories located in target sysroot","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"The following variables are useful to control the build script over different target systems, but are not intended to be modified by the users:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"prefix: the path to the top-directory of where all the products should be installed.  This will be the top-directory of the generated tarball\nlibdir: the path to the directory where the shared libraries should be installed.  This is ${prefix}/bin when building for Windows, ${prefix}/lib for all other platforms\nbindir: the path to the directory where the executables should be installed.  This is equivalent to ${prefix}/bin\nincludedir: the path to the directory where the header files should be installed.  This is equivalent to ${prefix}/include\nsimilar variables, with analogous meaning, exist for the host prefix (where HostBuildDependency are installed): ${host_prefix}, ${host_bindir}, ${host_libdir}, ${host_includedir}\ntarget: the target platform\nbb_full_target: the full target platform, containing things like libstdc++ string ABI platform tags, and libgfortran version\nMACHTYPE: the triplet of the host platform\nnproc: the number of processors of the host machine, useful for parallel building (e.g., make -j${nproc})\nnbits: number of bits of the target architecture (usually it is either 32 or 64)\nproc_family: target processor family (e.g., \"intel\", \"power\", or \"arm\")\ndlext: extension of the shared library on the target system.  It is \"dll\" for Windows, \"dylib\" for macOS, and \"so\" for the other Unix systems\nexeext: extension of the executable on the target system, including the dot if present.  It is \".exe\" for Windows and the empty string \"\" for all the other target platforms\nSRC_NAME: name of the project being built","category":"page"},{"location":"build_tips/#Using-GCC-on-macOS-and-FreeBSD","page":"Build Tips","title":"Using GCC on macOS and FreeBSD","text":"","category":"section"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"For these target systems Clang is the default compiler, however some programs may not be compatible with Clang.","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"For programs built with CMake (see the CMake build section) you can use the GCC toolchain file that is in ${CMAKE_TARGET_TOOLCHAIN%.*}_gcc.cmake.","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"If the project that you want to build uses the GNU Build System (also known as the Autotools), there isn't an automatic switch to use GCC, but you have to set the appropriate variables.  For example, this setting can be used to build most C/C++ programs with GCC for FreeBSD and macOS:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"if [[ \"${target}\" == *-freebsd* ]] || [[ \"${target}\" == *-apple-* ]]; then\n    CC=gcc\n    CXX=g++\nfi","category":"page"},{"location":"build_tips/#Dependencies-for-the-target-system-vs-host-system","page":"Build Tips","title":"Dependencies for the target system vs host system","text":"","category":"section"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"BinaryBuilder provides a cross-compilation environment, which means that in general there is a distinction between the target platform (where the build binaries will eventually run) and the host platform (where compilation is currently happening).  In particular, inside the build environment in general you cannot run binary executables built for the target platform.","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"For a build to work there may be different kinds of dependencies, for example:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"binary libraries that the final product of the current build (binary executables or other libraries) will need to link to.  These libraries must have been built for the target platform.  You can install this type of dependency as Dependency, which will also be a dependency of the generated JLL package.  This is the most common class of dependencies;\nbinary libraries or non-binary executables (usually shell scripts that can actually be run inside the build environment) for the target platform that are exclusively needed during the build process, but not for the final product of the build to run on the target system.  You can install this type of dependency as BuildDependency.  Remember they will not be added as dependency of the generated JLL package;\nbinary executables that are exclusively needed to be run during the build process.  They cannot generally have been built for the target platform, so they cannot be installed as Dependency or BuildDependency.  However you have two options:\nif they are available in a JLL package for the x86_64-linux-musl platform, you can install them as HostBuildDependency.  In order to keep binaries for the target platform separated from those for the host system, these dependencies will be installed under ${host_prefix}, in particular executables will be present under ${host_bindir} which is automatically added to the ${PATH} environment variable;\nif they are present in Alpine Linux repositories, you can install them with the system package manager apk.\nRemember that this class of dependencies is built for the host platform: if the library you want to build for the target platform requires another binary library to link to, installing it as HostBuildDepency or with apk will not help.","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"You need to understand the build process of package you want to compile in order to know what of these classes a dependency belongs to.","category":"page"},{"location":"build_tips/#Installing-the-license-file","page":"Build Tips","title":"Installing the license file","text":"","category":"section"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"Generated tarballs should come with the license of the library that you want to install.  If at the end of a successful build there is only one directory inside ${WORKSPACE}/srcdir, BinaryBuilder will look into it for files with typical names for license (like LICENSE, COPYRIGHT, etc... with some combinations of extensions) and automatically install them to ${prefix}/share/licenses/${SRC_NAME}/.  If in the final tarball there are no files in this directory a warning will be issued, to remind you to provide a license file.","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"If the license file is not automatically installed (for example because there is more than one directory in ${WORKSPACE}/srcdir or because the file name doesn't match the expected pattern) you have to manually install the file.  In the build script you can use the install_license command.  See the Utilities in the build environment section below.","category":"page"},{"location":"build_tips/#Utilities-in-the-build-environment","page":"Build Tips","title":"Utilities in the build environment","text":"","category":"section"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"In addition to the standard Unix tools, in the build environment there are some extra commands provided by BinaryBuilder.  Here is a list of some of these commands:","category":"page"},{"location":"build_tips/","page":"Build Tips","title":"Build Tips","text":"atomic_patch: utility to apply patches.  It is similar to the standard patch, but it fails gracefully when a patch cannot be applied:\natomic_patch -p1 /path/to/file.patch\nflagon: utility to translate some compiler-flags to the one required on the current platform.  For example, to build a shared library from a static archive:\ncc -o \"${libdir}/libfoo.${dlext}\" -Wl,$(flagon --whole-archive) libfoo.a -Wl,$(flagon --no-whole-archive) -lm\nThe currently supported flags are:\n--whole-archive;\n--no-whole-archive;\n--relative-rpath-link.\ninstall_license: utility to install a file to ${prefix}/share/licenses/${SRC_NAME}:\ninstall_license ${WORKSPACE}/srcdir/THIS_IS_THE_LICENSE.md\nupdate_configure_scripts: utility to update autoconfigure scripts.  Sometimes libraries come with out-of-date autoconfigure scripts (e.g., old configure.sub can't recognise aarch64 platforms or systems using Musl C library).  Just run\nupdate_configure_scripts\nto get a newer version.  With the --reconf flag, it also runs autoreconf -i -f afterwards:\nupdate_configure_scripts --reconf","category":"page"},{"location":"rootfs/#RootFS","page":"RootFS","title":"RootFS","text":"","category":"section"},{"location":"rootfs/","page":"RootFS","title":"RootFS","text":"The execution environment that all BinaryBuilder.jl builds are executed within is referred to as the \"root filesystem\" or RootFS.  This RootFS is built using the builder scripts contained within the 0_Rootfs directory within Yggdrasil.  The rootfs image is based upon the alpine docker image, and is used to build compilers for every target platform we support.  The target platform compiler toolchains are stored within /opt/${triplet}, so the 64-bit Linux (using glibc as the backing libc) compilers would be found in /opt/x86_64-linux-gnu/bin.","category":"page"},{"location":"rootfs/","page":"RootFS","title":"RootFS","text":"Each compiler \"shard\" is packaged separately, so that users do not have to download a multi-GB tarball just to build for a single platform.  There is an overall \"root\" shard, along with platform support shards, GCC shards, an LLVM shard, Rust shards, etc... These are all embedded within the bundled Artifacts.toml file, and BinaryBuilder.jl downloads them on-demand as necessary, making use of the new Pkg.Artifacts system within Julia 1.3+.","category":"page"},{"location":"rootfs/","page":"RootFS","title":"RootFS","text":"Each shard is made available both as an unpacked directory tree, and as a .squashfs image.  .squashfs images take up significantly less disk space, however they unfortunately require root privileges on the host machine, and only work on Linux.  This will hopefully be fixed in a future Linux kernel release, but if you have sudo privileges, it is often desirable to use the .squashfs files to save network bandwidth and disk space.  See the Environment Variables for instructions on how to do that.","category":"page"},{"location":"rootfs/","page":"RootFS","title":"RootFS","text":"When launching a process within the RootFS image, BinaryBuilder.jl sets up a set of environment variables to enable a target-specific compiler toolchain, among other niceties.  See the Build Tips doc page for more details on that, along with the src/Runner.jl file within this repository for the implementation.","category":"page"},{"location":"environment_variables/#Environment-Variables","page":"Environment Variables","title":"Environment Variables","text":"","category":"section"},{"location":"environment_variables/","page":"Environment Variables","title":"Environment Variables","text":"BinaryBuilder.jl supports multiple environment variables to modify its behavior globally:","category":"page"},{"location":"environment_variables/","page":"Environment Variables","title":"Environment Variables","text":"BINARYBUILDER_AUTOMATIC_APPLE: when set to true, this automatically agrees to the Apple macOS SDK license agreement, enabling the building of binary objects for macOS systems.\nBINARYBUILDER_USE_SQUASHFS: when set to true, this uses .squashfs images instead of tarballs to download cross-compiler shards.  This consumes significantly less space on-disk and boasts a modest reduction in download size as well, but requires sudo on the local machine to mount the .squashfs images.  This is the default when using the \"privileged\" runner.\nBINARYBUILDER_RUNNER: When set to a runner string, alters the execution engine that BinaryBuilder.jl will use to wrap the build process in a sandbox.  Valid values are one of \"userns\", \"privileged\" and \"docker\".  If not given, BinaryBuilder.jl will do its best to guess.\nBINARYBUILDER_ALLOW_ECRYPTFS: When set to true, this allows the mounting of rootfs/shard/workspace directories from within encrypted mounts.  This is disabled by default, as at the time of writing, this triggers kernel bugs.  To avoid these kernel bugs on a system where e.g. the home directory has been encrypted, set the BINARYBUILDER_ROOTFS_DIR and BINARYBUILDER_SHARDS_DIR environment variables to a path outside of the encrypted home directory.\nBINARYBUILDER_USE_CCACHE: When set to true, this causes a /root/.ccache volume to be mounted within the build environment, and for the CC, CXX and FC environment variables to have ccache prepended to them.  This can significantly accelerate rebuilds of the same package on the same host.  Note that ccache will, by default, store 5G of cached data.\nBINARYBUILDER_NPROC: Overrides the value of the environment variable ${nproc} set during a build, see Automatic environment variables.","category":"page"},{"location":"FAQ/#Frequently-Asked-Questions","page":"FAQ","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"FAQ/#I'm-having-trouble-compiling-project-name-here","page":"FAQ","title":"I'm having trouble compiling <project name here>","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"First, make sure that you can compile that project natively on whatever platform you're attempting to compile it on.  Once you are assured of that, search around the internet to see if anyone else has run into issues cross-compiling that project for that platform.  In particular, most smaller projects should be just fine, but larger projects (and especially anything that does any kind of bootstrapping) may need some extra smarts smacked into their build system to support cross-compiling.  Finally, if you're still stuck, try reaching out for help on the #binarybuilder channel in the JuliaLang slack.","category":"page"},{"location":"FAQ/#How-do-I-use-this-to-compile-my-Julia-code?","page":"FAQ","title":"How do I use this to compile my Julia code?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"This package does not compile Julia code; it compiles C/C++/Fortran dependencies.  Think about that time you wanted to use IJulia and you needed to download/install libnettle.  The purpose of this package is to make generated tarballs that can be downloaded/installed painlessly as possible.","category":"page"},{"location":"FAQ/#What-is-this-I-hear-about-the-macOS-SDK-license-agreement?","page":"FAQ","title":"What is this I hear about the macOS SDK license agreement?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"Apple restricts distribution and usage of the macOS SDK, a necessary component to build software for macOS targets.  Please read the Apple and Xcode SDK agreement for more information on the restrictions and legal terms you agree to when using the SDK to build software for Apple operating systems. Copyright law is a complex area and you should not take legal advice from FAQs on the internet. This toolkit is designed to primarily run on Linux, though it can of course be used within a virtualized environment on a macOS machine or directly by running Linux Apple hardware. The Docker runner implements the virtualization approach on macOS machines.  BinaryBuilder.jl, by default, will not automatically download or use the macOS SDK on non-apple host operating systems, unless the BINARYBUILDER_AUTOMATIC_APPLE environment variable is set to true.","category":"page"},{"location":"FAQ/#Are-there-other-environment-variables-I-can-use?","page":"FAQ","title":"Are there other environment variables I can use?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"Yes, take a look.","category":"page"},{"location":"FAQ/#Hey,-this-is-cool,-can-I-use-this-for-my-non-Julia-related-project?","page":"FAQ","title":"Hey, this is cool, can I use this for my non-Julia related project?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"Absolutely!  There's nothing Julia-specific about the binaries generated by the cross-compilers used by BinaryBuilder.jl.  Although the best interface for interacting with this software will always be the Julia interface defined within this package, you are free to use these software tools for other projects as well.  Note that the cross-compiler image is built through a multistage bootstrapping process, see this repository for more information.  Further note the macOS SDK license agreement tidbit above.","category":"page"},{"location":"FAQ/#At-line-XXX,-ABORTED-(Operation-not-permitted)!","page":"FAQ","title":"At line XXX, ABORTED (Operation not permitted)!","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"Some linux distributions have a bug in their overlayfs implementation that prevents us from mounting overlay filesystems within user namespaces.  See this Ubuntu kernel bug report for a description of the situation and how Ubuntu has patched it in their kernels.  To work around this, you can launch BinaryBuilder.jl in \"privileged container\" mode.  BinaryBuilder should auto-detect this situation, however if the autodetection is not working or you want to silence the warning, you can set the BINARYBUILDER_RUNNER environment variable to privileged.  Unfortunately, this involves running sudo every time you launch into a BinaryBuilder session, but on the other hand, this successfully works around the issue on distributions such as Arch linux.","category":"page"},{"location":"FAQ/#I-have-to-build-a-very-small-project-without-a-Makefile,-what-do-I-have-to-do?","page":"FAQ","title":"I have to build a very small project without a Makefile, what do I have to do?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"What BinaryBuilder needs is to find the relevant file (shared libraries, or executables, etc...) organised under the $prefix directory: libraries should go to ${libdir}, executables to ${bindir}.  You may need to create those directories.  You are free to choose whether to create a simple Makefile to build the project or to do everything within the build_tarballs.jl script. When the script completes, BinaryBuilder expects to find at least one artifact built for the expected architecture in either ${libdir} or ${bindir}. Remember also that you should use the standard environment variables like CC, CXX, CFLAGS, LDFLAGS as appropriate in order to cross compile.  See the list of variables in the Tips for Building Packages section.","category":"page"},{"location":"FAQ/#Can-I-open-a-shell-in-a-particular-build-environment-for-doing-some-quick-tests?","page":"FAQ","title":"Can I open a shell in a particular build environment for doing some quick tests?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"Yes!  You can use BinaryBuilder.runshell(platform) to quickly start a shell in the current directory, without having to set up a working build_tarballs.jl script.  For example,","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"julia -e 'using BinaryBuilder; BinaryBuilder.runshell(Platform(\"i686\", \"windows\"))'","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"will open a shell in a Windows 32-bit build environment, without any source loaded.  The current working directory of your system will be mounted on ${WORKSPACE} within this BinaryBuilder environment.","category":"page"},{"location":"FAQ/#Can-I-publish-a-JLL-package-locally-without-going-through-Yggdrasil?","page":"FAQ","title":"Can I publish a JLL package locally without going through Yggdrasil?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"You can always build a JLL package on your machine with the --deploy flag to the build_tarballs.jl script.  Read the help (--help) for more information.","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"A common use case is that you want to build a JLL package for, say, Libfoo, that will be used as dependency to build Quxlib, and you want to make sure that building both Libfoo and Quxlib will work before submitting all the pull requests to Yggdrasil.  You can prepare the build_tarballs.jl script for Libfoo and then build and deploy it with","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"julia build_tarballs.jl --debug --verbose --deploy=\"MY_USERNAME/Libfoo_jll.jl\"","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"replacing MY_USERNAME with your GitHub username: this will build the tarballs for all the platforms requested and upload them to a release of the MY_USERNAME/Libfoo_jll.jl, where the JLL package will also be created.  As explained above, you can pass argument the list of triplets of the platforms for you which you want to build the tarballs, in case you want to compile only some of them.  In the Julia REPL, you can install this package as any unregistered package with","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"]add https://github.com/MY_USERNAME/Libfoo_jll.jl.git","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"or develop it with","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"]dev https://github.com/MY_USERNAME/Libfoo_jll.jl.git","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"Since this package is unregistered, you have to use the full PackageSpec specification to add it as dependency of the local builder for Quxlib:","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"    Dependency(PackageSpec(; name = \"Libfoo_jll\",  uuid = \"...\", url = \"https://github.com/MY_USERNAME/Libfoo_jll.jl.git\"))","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"You can of course in turn build and deploy this package with","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"julia build_tarballs.jl --debug --verbose --deploy=\"MY_USERNAME/Quxlib_jll.jl\"","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"Note that PackageSpec can also point to a local path: e.g., PackageSpec(; name=\"Libfoo_jll\", uuid=\"...\", path=\"/home/myname/.julia/dev/Libfoo_jll\").  This is particularly useful when Building a custom JLL package locally, instead of deploying it to a remote Git repository.","category":"page"},{"location":"FAQ/#What-are-those-numbers-in-the-list-of-sources?-How-do-I-get-them?","page":"FAQ","title":"What are those numbers in the list of sources?  How do I get them?","text":"","category":"section"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"The list of sources is a vector of BinaryBuilder.AbstractSources.  What the hash is depends on what the source is:","category":"page"},{"location":"FAQ/","page":"FAQ","title":"FAQ","text":"For a FileSource or an ArchiveSource, the hash is a 64-character SHA256 checksum.  If you have a copy of that file, you can compute the hash in Julia with\nusing SHA\nopen(path_to_the_file, \"r\") do f\n     bytes2hex(sha256(f))\nend\nwhere path_to_the_file is a string with the path to the file.  Alternatively, you can use the command line utilities curl and shasum to compute the hash of a remote file:\n$ curl -L http://example.org/file.tar.gz | shasum -a 256\nreplacing http://example.org/file.tar.gz with the actual URL of the file you want to download.\nFor a GitSource, the hash is the 40-character SHA1 hash of the revision you want to checkout.  For reproducibility you must indicate a specific revision, and not a branch or tag name, which are moving targets.","category":"page"},{"location":"jll/#JLL-packages","page":"JLL packages","title":"JLL packages","text":"","category":"section"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"BinaryBuilder.jl is designed to produce tarballs that can be used in any environment, but so far their main use has been to provide pre-built libraries and executables to be readily used in Julia packages.  This is accomplished by JLL packages (a pun on \"Dynamic-Link Library\", with the J standing for Julia). They can be installed like any other Julia packages with the Julia package manager in the REPL with","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"]add NAME_jll","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"and then loaded with","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"using NAME_jll","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"However, most users will not ever need to do these steps on their own, JLL packages are usually only used as dependencies of packages wrapping binary libraries or executables.","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"Most JLL packages live under the JuliaBinaryWrappers organization on GitHub, and the builders to generate them are maintaned in Yggdrasil, the community build tree.  BinaryBuilder.jl allows anyone to create their own JLL package and publish them to a GitHub repository of their choice without using Yggdrasil, see the Frequently Asked Questions.","category":"page"},{"location":"jll/#Anatomy-of-a-JLL-package","page":"JLL packages","title":"Anatomy of a JLL package","text":"","category":"section"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"A somewhat popular misconception is that JLL packages are \"special\".  Instead, they are simple Julia packages with a common structure, as they are generated automatically.  This is the typical tree of a JLL package, called in this example NAME_jll.jl:","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"NAME_jll\n├── Artifacts.toml\n├── LICENSE\n├── Project.toml\n├── README.md\n└── src/\n    ├── NAME_jll.jl\n    └── wrappers/\n        ├── aarch64-linux-gnu.jl\n        ├── aarch64-linux-musl.jl\n        ├── armv7l-linux-gnueabihf.jl\n        ├── armv7l-linux-musleabihf.jl\n        ├── i686-linux-gnu.jl\n        ├── i686-linux-musl.jl\n        ├── i686-w64-mingw32.jl\n        ├── powerpc64le-linux-gnu.jl\n        ├── x86_64-apple-darwin14.jl\n        ├── x86_64-linux-gnu.jl\n        ├── x86_64-linux-musl.jl\n        ├── x86_64-unknown-freebsd11.1.jl\n        └── x86_64-w64-mingw32.jl","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"These are the main ingredients of a JLL package:","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"LICENSE, a file stating the license of the JLL package.  Note that this may differ from the license of the library it wraps, which is instead shipped inside the tarballs;\na README.md file providing some information about the content of the wrapper, like the list of \"products\" provided by the package;\nthe Artifacts.toml file contains the information about all the available tarballs for the given package.  The tarballs are uploaded to GitHub releases;\nthe Project.toml file describes the packages dependencies and their compatibilities;\nthe main entry point of the package is the file called src/NAME_jll.jl. This is what is executed when you issue the command\nusing NAME_jll\nThis file reads the list of tarballs available in Artifacts.toml and choose the platform matching the current platform.  Some JLL packages are not built for all supported platforms.  If the current platform is one of those platform not supported by the JLL package, this is the end of the package.  Instead, if the current platform is supported, the corresponding wrapper in the src/wrappers/ directory will be included;\nthe wrappers/ directory contains a file for each of the supported platforms.  They are actually mostly identical, with some small differences due to platform-specific details.  The wrappers are analyzed in more details in the following section.","category":"page"},{"location":"jll/#The-wrappers","page":"JLL packages","title":"The wrappers","text":"","category":"section"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"The files in the src/wrappers/ directory are very thin automatically-generated wrappers around the binary package provided by the JLL package.  They load all the JLL packages that are dependencies of the current JLL package and export the names of the products listed in the build_tarballs.jl script that produced the current JLL package.  Among others, they also define the following unexported variables:","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"artifact_dir: the absolute path to where the artifact for the current platform has been installed.  This is the \"prefix\" where the binaries/libraries/files are placed;\nPATH: the value of the PATH environment variable needed to run executables in the current JLL package, if any;\nPATH_list: the list of directories in PATH as a vector of Strings;\nLIBPATH: the value of the environment variable that holds the list of directories in which to search shared libraries.  This has the correct value for the libraries provided by the current JLL package;\nLIBPATH_list: the list of directories in LIBPATH as a vector of Strings.","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"The wrapper files for each platform also define the __init__() function of the JLL package, the code that is executed every time the package is loaded.  The __init__() function will populate most of the variables mentioned above and automatically open the shared libraries, if any, listed in the products of the build_tarballs.jl script that generated the JLL package.","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"The rest of the code in the wrappers is specific to each of the products of the JLL package and detailed below.  If you want to see a concrete example of a package providing all the main three products, have a look at Fontconfig_jll.jl.","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"In addition to the variables defined above by each JLL wrapper, the package JLLWrappers defines an additional unexported variable:","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"LIBPATH_env: the name of the environment variable of the search paths of the shared libraries for the current platform.  This is equal to LD_LIBRARY_PATH on Linux and FreeBSD, DYLD_FALLBACK_LIBRARY_PATH on macOS, and PATH on Windows.","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"In what follows, we will use as an example a builder that has these products:","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"products = [\n    FileProduct(\"src/data.txt\", :data_txt),\n    LibraryProduct(\"libdataproc\", :libdataproc),\n    ExecutableProduct(\"mungify\", :mungify_exe),\n]","category":"page"},{"location":"jll/#LibraryProduct","page":"JLL packages","title":"LibraryProduct","text":"","category":"section"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"A LibraryProduct is a shared library that can be ccalled from Julia.  Assuming that the product is called libdataproc, the wrapper defines the following variables:","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"libdataproc: this is the exported const variable that should be used in ccall:\nnum_chars = ccall((:count_characters, libdataproc), Cint,\n                  (Cstring, Cint), data_lines[1], length(data_lines[1]))\nRoughly speaking, the value of this variable is the basename of the shared library, not its full absolute path;\nlibdataproc_splitpath: the path of the shared library, relative to artifact_dir, as returned by splitpath;\nlibdataproc_path: the full absolute path of the shared library.  Note that this is not const, thus it can't be used in ccall;\nlibdataproc_handle: the address in memory of the shared library after it has been loaded at initialization time.","category":"page"},{"location":"jll/#ExecutableProduct","page":"JLL packages","title":"ExecutableProduct","text":"","category":"section"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"An ExecutableProduct is a binary executable that can be run on the current platform.  If, for example, the ExecutableProduct has been called mungify_exe, the wrapper defines an exported function named mungify_exe that should run by the user in one the following ways: versions:","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"# Only available in Julia v1.6+\nrun(`$(mungify_exe()) $arguments`)","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"mungify_exe() do exe\n    run(`$exe $arguments`)\nend","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"Note that in the latter form exe can be replaced with any name of your choice: with the do-block syntax you are defining the name of the variable that will be used to actually call the binary with run.","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"The former form is only available when using Julia v1.6, but should be preferred going forward, as it is thread-safe and generally more flexible.","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"A common point of confusion about ExecutableProducts in JLL packages is why these function wrappers are needed: while in principle you could run the executable directly by using its absolute path in run, these functions ensure that the executable will find all shared libraries it needs while running.","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"In addition to the function called mungify_exe, for this product there will be the following unexported variables:","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"mungify_exe_splitpath: the path of the executable, relative to artifact_dir, as returned by splitpath;\nmungify_exe_path: the full absolute path of the executable;","category":"page"},{"location":"jll/#FileProduct","page":"JLL packages","title":"FileProduct","text":"","category":"section"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"A FileProduct is a simple file with no special treatment.  If, for example, the FileProduct has been called data_txt, the only variables defined for it are:","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"data_txt: this exported variable has the absolute path to the mentioned file:\ndata_lines = open(data_txt, \"r\") do io\n    readlines(io)\nend\ndata_txt_path: this unexported variable is actually equal to data_txt, but is kept for consistency with all other product types.","category":"page"},{"location":"jll/#Overriding-the-artifacts-in-JLL-packages","page":"JLL packages","title":"Overriding the artifacts in JLL packages","text":"","category":"section"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"As explained above, JLL packages use the Artifacts system to provide the files. If you wish to override the content of an artifact with their own binaries/libraries/files, you can use the Overrides.toml file.","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"We detail below a couple of different ways to override the artifact of a JLL package, depending on whether the package is dev'ed or not.  The second method is particularly recommended to system administrator who wants to use system libraries in place of the libraries in JLL packages.","category":"page"},{"location":"jll/#dev'ed-JLL-packages","page":"JLL packages","title":"dev'ed JLL packages","text":"","category":"section"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"In the event that a user wishes to override the content within a dev'ed JLL package, the user may use the dev_jll() method provided by JLL packages to check out a mutable copy of the package to their ~/.julia/dev directory.  An override directory will be created within that package directory, providing a convenient location for the user to copy in their own files over the typically artifact-sourced ones.  See the segment on \"Building and testing JLL packages locally\" in the Building Packages section of this documentation for more information on this capability.","category":"page"},{"location":"jll/#Non-dev'ed-JLL-packages","page":"JLL packages","title":"Non-dev'ed JLL packages","text":"","category":"section"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"As an example, in a Linux system you can override the Fontconfig library provided by Fontconfig_jll.jl and the Bzip2 library provided by Bzip2_jll.jl respectively with /usr/lib/libfontconfig.so and /usr/local/lib/libbz2.so with the following Overrides.toml:","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"[a3f928ae-7b40-5064-980b-68af3947d34b]\nFontconfig = \"/usr\"\n\n[6e34b625-4abd-537c-b88f-471c36dfa7a0]\nBzip2 = \"/usr/local\"","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"Some comments about how to write this file:","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"The UUIDs are those of the JLL packages, a3f928ae-7b40-5064-980b-68af3947d34b for Fontconfig_jll.jl and 6e34b625-4abd-537c-b88f-471c36dfa7a0 for Bzip2_jll.jl.  You can either find them in the Project.toml files of the packages (e.g., see the Project.toml file of Fontconfig_jll) or look it up in the registry (e.g., see the entry for Fontconfig_jll in the General registry).\nThe artifacts provided by JLL packages have the same name as the packages, without the trailing _jll, Fontconfig and Bzip2 in this case.\nThe artifact location is held in the artifact_dir variable mentioned above, which is the \"prefix\" of the installation of the package.  Recall the paths of the products in the JLL package is relative to artifact_dir and the files you want to use to override the products of the JLL package must have the same tree structure as the artifact.  In our example we need to use /usr to override Fontconfig and /usr/local for Bzip2.","category":"page"},{"location":"jll/#Overriding-specific-products","page":"JLL packages","title":"Overriding specific products","text":"","category":"section"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"Instead of overriding the entire artifact, you can override a particular product (library, executable, or file) within a JLL using Preferences.jl.","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"compat: Compat\nThis section requires Julia 1.6 or later.","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"For example, to override our libbz2 example:","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"using Preferences\nset_preferences!(\n    \"LocalPreferences.toml\",\n    \"Bzip2_jll\",\n    \"libbzip2_path\" => \"/usr/local/lib/libbz2.so\",\n)","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"Note that the product name is libbzip2, but we use libbzip2_path.","category":"page"},{"location":"jll/","page":"JLL packages","title":"JLL packages","text":"warning: Warning\nThere are two common cases where this will not work:The JLL is part of the Julia stdlib, for example Zlib_jll\nThe JLL has not been compiled with JLLWrappers.jl as a dependency. In this case, it means that the last build of the JLL pre-dates the introduction of the JLLWrappers package and needs a fresh build. Please open an issue on Yggdrasil requesting a new build, or make a pull request to update the relevant build_tarballs.jl script.","category":"page"},{"location":"reference/#API-reference","page":"Reference","title":"API reference","text":"","category":"section"},{"location":"reference/#Types","page":"Reference","title":"Types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [BinaryBuilderBase, BinaryBuilder, BinaryBuilder.Auditor, BinaryBuilder.Wizard]\nOrder = [:type]","category":"page"},{"location":"reference/#BinaryBuilderBase.AbstractDependency","page":"Reference","title":"BinaryBuilderBase.AbstractDependency","text":"An AbstractDependency is a binary dependency of the JLL package.  Dependencies are installed to ${prefix} in the build environment.\n\nConcrete subtypes of AbstractDependency are\n\nDependency: a JLL package that is necessary for to build the package and to load the generated JLL package.\nBuildDependency: a JLL package that is necessary only to build the package.  This will not be a dependency of the generated JLL package.\nHostBuildDependency: similar to BuildDependency, but it will install the artifact for the host platform, instead of that for the target platform.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.AbstractSource","page":"Reference","title":"BinaryBuilderBase.AbstractSource","text":"An AbstractSource is something used as source to build the package.  Sources are installed to ${WORKSPACE}/srcdir in the build environment.\n\nConcrete subtypes of AbstractSource are:\n\nArchiveSource: a remote archive to download from the Internet;\nFileSource: a remote file to download from the Internet;\nGitSource: a remote Git repository to clone;\nDirectorySource: a local directory to mount.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.AnyPlatform","page":"Reference","title":"BinaryBuilderBase.AnyPlatform","text":"AnyPlatform()\n\nA special platform to be used to build platform-independent tarballs, like those containing only header files.  FileProduct is the only product type allowed with this platform.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.ArchiveSource","page":"Reference","title":"BinaryBuilderBase.ArchiveSource","text":"ArchiveSource(url::String, hash::String; unpack_target::String = \"\")\n\nSpecify a remote archive in one of the supported archive formats (e.g., TAR or ZIP balls) to be downloaded from the Internet from url.  hash is the 64-character SHA256 checksum of the file.\n\nIn the builder environment, the archive will be automatically unpacked to ${WORKSPACE}/srcdir, or in its subdirectory pointed to by the optional keyword unpack_target, if provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.BuildDependency","page":"Reference","title":"BinaryBuilderBase.BuildDependency","text":"BuildDependency(dep::Union{PackageSpec,String}; platforms)\n\nDefine a binary dependency that is necessary only to build the package.  The dep argument can be either a string with the name of the JLL package or a Pkg.PackageSpec.\n\nThe optional keyword argument platforms is a vector of AbstractPlatforms which indicates for which platforms the dependency should be used.  By default platforms=[AnyPlatform()], to mean that the dependency is compatible with all platforms.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.Dependency","page":"Reference","title":"BinaryBuilderBase.Dependency","text":"Dependency(dep::Union{PackageSpec,String}, build_version; compat, platforms)\n\nDefine a binary dependency that is necessary to build the package and load the generated JLL package.  The argument can be either a string with the name of the JLL package or a Pkg.PackageSpec.\n\nThe optional keyword argument build_version can be used to specify the version of the dependency to be installed when building it.\n\nThe optional keyword argument compat can be used to specify a string for use in the Project.toml of the generated Julia package.  If compat is non-empty and build_version is not passed, the latter defaults to the minimum version compatible with the compat specifier.\n\nThe optional keyword argument platforms is a vector of AbstractPlatforms which indicates for which platforms the dependency should be used.  By default platforms=[AnyPlatform()], to mean that the dependency is compatible with all platforms.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.DirectorySource","page":"Reference","title":"BinaryBuilderBase.DirectorySource","text":"DirectorySource(path::String; target::String = basename(path), follow_symlinks=false)\n\nSpecify a local directory to mount from path.\n\nThe content of the directory will be mounted in ${WORKSPACE}/srcdir, or in its subdirectory pointed to by the optional keyword target, if provided. Symbolic links are replaced by a copy of the target when follow_symlinks is true.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.DockerRunner","page":"Reference","title":"BinaryBuilderBase.DockerRunner","text":"DockerRunner\n\nUse docker as an execution engine; a reasonable backup for platforms that do not have user namespaces (e.g. MacOS, Windows).\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.ExecutableProduct","page":"Reference","title":"BinaryBuilderBase.ExecutableProduct","text":"An ExecutableProduct is a Product that represents an executable file.\n\nOn all platforms, an ExecutableProduct checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set.  On Windows platforms, it will check that the file ends with \".exe\", (adding it on automatically, if it is not already present).\n\n\n\nExecutableProduct(binname, varname::Symbol, dir_path=\"bin\")\n\nDeclares an ExecutableProduct that points to an executable located within the prefix.  binname specifies the basename of the executable, varname is the name of the variable in the JLL package that can be used to call into the library.  By default, the library is searched in the bindir, but you can specify a different directory within the prefix with the dir_path argument.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.FileProduct","page":"Reference","title":"BinaryBuilderBase.FileProduct","text":"FileProduct(path::AbstractString, varname::Symbol, dir_path = nothing)\n\nDeclares a FileProduct that points to a file located relative to the root of a Prefix, must simply exist to be satisfied.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.FileSource","page":"Reference","title":"BinaryBuilderBase.FileSource","text":"FileSource(url::String, hash::String; filename::String = basename(url))\n\nSpecify a remote file to be downloaded from the Internet from url.  hash is the 64-character SHA256 checksum of the file.\n\nIn the builder environment, the file will be saved under ${WORKSPACE}/srcdir with the same name as the basename of the originating URL, unless the the keyword argument filename is specified.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.FrameworkProduct","page":"Reference","title":"BinaryBuilderBase.FrameworkProduct","text":"A FrameworkProduct is a  Product that encapsulates a macOS Framework. It behaves mostly as a LibraryProduct for now, but is a distinct type. This implies that for cross-platform builds where a library is provided as a Framework on macOS and as a normal library on other platforms, two calls to BinaryBuilder's build_tarballs are needed: one with the LibraryProduct and all non-macOS platforms, and one with the FrameworkProduct and the MacOS platforms.\n\n\n\nFrameworkProduct(fwnames, varname::Symbol)\n\nDeclares a macOS FrameworkProduct that points to a framework located within the prefix, with a name containing fwname appended with .framework.  As an example, given that fwname is equal to QtCore, this would be satisfied by the following path:\n\nlib/QtCore.framework\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.GitSource","page":"Reference","title":"BinaryBuilderBase.GitSource","text":"GitSource(url::String, hash::String; unpack_target::String = \"\")\n\nSpecify a remote Git repository to clone form url.  hash is the 40-character SHA1 revision to checkout after cloning.\n\nThe repository will be cloned in ${WORKSPACE}/srcdir, or in its subdirectory pointed to by the optional keyword unpack_target, if provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.HostBuildDependency","page":"Reference","title":"BinaryBuilderBase.HostBuildDependency","text":"HostBuildDependency(dep::Union{PackageSpec,String}; platforms)\n\nDefine a binary dependency that is necessary only to build the package. Different from the BuildDependency, the artifact for the host platform will be installed, instead of that for the target platform.\n\nThe dep argument can be either a string with the name of the JLL package or a Pkg.PackageSpec.\n\nThe optional keyword argument platforms is a vector of AbstractPlatforms which indicates for which platforms the dependency should be used.  By default platforms=[AnyPlatform()], to mean that the dependency is compatible with all platforms.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.LibraryProduct","page":"Reference","title":"BinaryBuilderBase.LibraryProduct","text":"A LibraryProduct is a special kind of Product that not only needs to exist, but needs to be dlopen()'able.  You must know which directory the library will be installed to, and its name, e.g. to build a LibraryProduct that refers to \"/lib/libnettle.so\", the \"directory\" would be \"/lib\", and the \"libname\" would be \"libnettle\".  Note that a LibraryProduct can support multiple libnames, as some software projects change the libname based on the build configuration.\n\n\n\nLibraryProduct(libname, varname::Symbol; dir_paths=String[],\n                                         dont_dlopen=false,\n                                         dlopen_flags=Symbol[])\n\nDeclares a LibraryProduct that points to a library located within the prefix. libname specifies the basename of the library, varname is the name of the variable in the JLL package that can be used to call into the library.  By default, the library is searched in the libdir, but you can add other directories within the prefix to the dir_paths keyword argument.  You can specify the flags to pass to dlopen as a vector of Symbols with the dlopen_flags keyword argument.  If the library should not be dlopen'ed automatically by the JLL package, set dont_dlopen=true.\n\nFor example, if the libname is libnettle, this would be satisfied by the following paths:\n\nlib/libnettle.so or lib/libnettle.so.6 on Linux and FreeBSD;\nlib/libnettle.6.dylib on macOS;\nlib/libnettle-6.dll on Windows.\n\nLibraries matching the search pattern are rejected if they are not dlopen()'able.\n\nIf you are unsure what value to use for libname, you can use Base.BinaryPlatforms.parse_dl_name_version:\n\njulia> using Base.BinaryPlatforms\n\njulia> parse_dl_name_version(\"sfml-audio-2.dll\", \"windows\")[1]\n\"sfml-audio\"\n\nIf the library would have different basenames on different operating systems (e.g., libz.so on Linux and FreeBSD, libz.dylib on macOS, and zlib.dll on Windows), libname can be also a vector of Strings with the different alternatives:\n\nLibraryProduct([\"libz\", \"zlib\"], :libz)\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.Product","page":"Reference","title":"BinaryBuilderBase.Product","text":"A Product is an expected result after building or installation of a package.\n\nExamples of Products include LibraryProduct, FrameworkProduct, ExecutableProduct and FileProduct. All Product types must define the following minimum set of functionality:\n\nlocate(::Product): given a Product, locate it within the wrapped Prefix returning its location as a string\nsatisfied(::Product): given a Product, determine whether it has been successfully satisfied (e.g. it is locateable and it passes all callbacks)\nvariable_name(::Product): return the variable name assigned to a Product\nrepr(::Product): Return a representation of this Product, useful for auto-generating source code that constructs Products, if that's your thing.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilderBase.UserNSRunner","page":"Reference","title":"BinaryBuilderBase.UserNSRunner","text":"UserNSRunner\n\nA UserNSRunner represents an \"execution context\", an object that bundles all necessary information to run commands within the container that contains our crossbuild environment.  Use run() to actually run commands within the UserNSRunner, and runshell() as a quick way to get an interactive shell within the crossbuild environment.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BinaryBuilder.Wizard.WizardState","page":"Reference","title":"BinaryBuilder.Wizard.WizardState","text":"WizardState\n\nBuilding large dependencies can take a lot of time. This state object captures all relevant state of this function. It can be passed back to the function to resume where we left off. This can aid debugging when code changes are necessary.  It also holds all necessary metadata such as input/output streams.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Functions","page":"Reference","title":"Functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [BinaryBuilderBase, BinaryBuilder, BinaryBuilder.Auditor, BinaryBuilder.Wizard]\nOrder = [:function]\n# We'll include build_tarballs explicitly below, so let's exclude it here:\nFilter = x -> !(isa(x, Function) && x === build_tarballs)","category":"page"},{"location":"reference/#BinaryBuilderBase.abi_agnostic-Tuple{Platform}","page":"Reference","title":"BinaryBuilderBase.abi_agnostic","text":"abi_agnostic(p::AbstractPlatform)\n\nStrip out any tags that are not the basic annotations like libc and call_abi.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.accept_apple_sdk-Tuple{IO, IO}","page":"Reference","title":"BinaryBuilderBase.accept_apple_sdk","text":"accept_apple_sdk(ins::IO, outs::IO) -> Bool\n\nAsk the user whether they accept the terms of the macOS SDK, and return a boolean with their choice.  Write messages to outs, read input from ins.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.artifact_name-Tuple{CompilerShard}","page":"Reference","title":"BinaryBuilderBase.artifact_name","text":"artifact_name(cs::CompilerShard)\n\nReturn the bound artifact name for a particular shard.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.bindir-Tuple{Prefix}","page":"Reference","title":"BinaryBuilderBase.bindir","text":"bindir(prefix::Prefix)\n\nReturns the binary directory for the given prefix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.choose_shards-Tuple{AbstractPlatform}","page":"Reference","title":"BinaryBuilderBase.choose_shards","text":"choose_shards(p::AbstractPlatform; rootfs_build, ps_build, GCC_builds,\n                           LLVM_builds, archive_type)\n\nThis method chooses, given a Platform, which shards to download, extract and mount, returning a list of CompilerShard objects.  At the moment, this always consists of four shards, but that may not always be the case.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.chown_cleanup-Tuple{DockerRunner}","page":"Reference","title":"BinaryBuilderBase.chown_cleanup","text":"chown_cleanup(dr::DockerRunner)\n\nOn Linux, the user id inside of the docker container doesn't correspond to ours on the outside, so permissions get all kinds of screwed up.  To fix this, we have to chown -R $(id -u):$(id -g) $prefix, which really sucks, but is still better than nothing.  This is why we prefer the UserNSRunner on Linux.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.collect_jlls-Tuple{Dict, Set{var\"#s4\"} where var\"#s4\"<:AbstractString}","page":"Reference","title":"BinaryBuilderBase.collect_jlls","text":"collect_jlls(manifest::Dict, dependencies::Vector{<:AbstractString})\n\nReturn a Set of all JLL packages in the manifest with dependencies being the list of direct dependencies of the environment.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.compress_dir-Tuple{AbstractString}","page":"Reference","title":"BinaryBuilderBase.compress_dir","text":"compress_dir(dir::AbstractString;\n             compressor_stream = GzipCompressorStream,\n             level::Int = 9,\n             extension::AbstractString = \".gz\",\n             verbose::Bool = false)\n\nCompress all files in dir using the specified compressor_stream with compression level equal to level, appending extension to the filenames. Remove the original uncompressed files at the end.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.download_all_artifacts-Tuple{}","page":"Reference","title":"BinaryBuilderBase.download_all_artifacts","text":"download_all_artifacts(; verbose::Bool=false)\n\nHelper function to download all shards/helper binaries so that no matter what happens, you don't need an internet connection to build your precious, precious binaries.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.download_source","page":"Reference","title":"BinaryBuilderBase.download_source","text":"download_source(source::AbstractSource; verbose::Bool = false)\n\nDownload the given source.  All downloads are cached within the BinaryBuilder downloads storage directory.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.enable_apple_file-Tuple{}","page":"Reference","title":"BinaryBuilderBase.enable_apple_file","text":"enable_apple_file()\n\nReturn the path to file that, if exists, indicates that the user accepts to download macOS SDK.  The file is automatically created when the package is loaded if the environment variable BINARYBUILDER_AUTOMATIC_APPLE is set to \"true\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.expand_cxxstring_abis-Tuple{AbstractPlatform}","page":"Reference","title":"BinaryBuilderBase.expand_cxxstring_abis","text":"expand_cxxstring_abis(p::AbstractPlatform; skip=Sys.isbsd)\n\nGiven a Platform, returns an array of Platforms with a spread of identical entries with the exception of the cxxstring_abi tag within the Platform object.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.\n\nIf the given Platform already specifies a cxxstring_abi (as opposed to nothing) only that Platform is returned.  If skip is a function for which skip(platform) evaluates to true, the given platform is not expanded.  By default FreeBSD and macOS platforms are skipped, due to their lack of a dependence on libstdc++ and not needing this compatibility shim.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.expand_gfortran_versions-Tuple{AbstractPlatform}","page":"Reference","title":"BinaryBuilderBase.expand_gfortran_versions","text":"expand_gfortran_versions(p::AbstractPlatform)\n\nGiven a Platform, returns an array of Platforms with a spread of identical entries with the exception of the libgfortran_version tag within the Platform.  This is used to take, for example, a list of supported platforms and expand them to include multiple GCC versions for the purposes of ABI matching.  If the given Platform already specifies a libgfortran_version (as opposed to nothing) only that Platform is returned.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.expand_microarchitectures-Tuple{AbstractPlatform}","page":"Reference","title":"BinaryBuilderBase.expand_microarchitectures","text":"expand_microarchitectures(p::AbstractPlatform)\n\nGiven a Platform, returns a vector of Platforms with differing march attributes as specified by the ARCHITECTURE_FLAGS mapping.  If the given Platform alread has a march tag specified, only that platform is returned.\n\njulia> using BinaryBuilderBase\n\njulia> expand_microarchitectures(Platform(\"x86_64\", \"freebsd\"))\n4-element Vector{Platform}:\n FreeBSD x86_64 {march=x86_64}\n FreeBSD x86_64 {march=avx}\n FreeBSD x86_64 {march=avx2}\n FreeBSD x86_64 {march=avx512}\n\njulia> expand_microarchitectures(Platform(\"armv7l\", \"linux\"))\n2-element Vector{Platform}:\n Linux armv7l {call_abi=eabihf, libc=glibc, march=armv7l}\n Linux armv7l {call_abi=eabihf, libc=glibc, march=neonvfpv4}\n\njulia> expand_microarchitectures(Platform(\"aarch64\", \"linux\"))\n4-element Vector{Platform}:\n Linux aarch64 {libc=glibc, march=armv8_0}\n Linux aarch64 {libc=glibc, march=armv8_4_crypto_sve}\n Linux aarch64 {libc=glibc, march=armv8_2_crypto}\n Linux aarch64 {libc=glibc, march=armv8_1}\n\njulia> expand_microarchitectures(Platform(\"i686\", \"windows\"))\n2-element Vector{Platform}:\n Windows i686 {march=pentium4}\n Windows i686 {march=prescott}\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.expand_microarchitectures-Tuple{Vector{var\"#s1003\"} where var\"#s1003\"<:AbstractPlatform}","page":"Reference","title":"BinaryBuilderBase.expand_microarchitectures","text":"expand_microarchitectures(ps::Vector{<:Platform})\n\nExpand all platforms in the given vector with the supported microarchitectures.\n\njulia> using BinaryBuilderBase\n\njulia> expand_microarchitectures(filter!(p -> Sys.islinux(p) && libc(p) == \"glibc\", supported_platforms()))\n13-element Vector{Platform}:\n Linux i686 {libc=glibc, march=pentium4}\n Linux i686 {libc=glibc, march=prescott}\n Linux x86_64 {libc=glibc, march=x86_64}\n Linux x86_64 {libc=glibc, march=avx}\n Linux x86_64 {libc=glibc, march=avx2}\n Linux x86_64 {libc=glibc, march=avx512}\n Linux aarch64 {libc=glibc, march=armv8_0}\n Linux aarch64 {libc=glibc, march=armv8_4_crypto_sve}\n Linux aarch64 {libc=glibc, march=armv8_2_crypto}\n Linux aarch64 {libc=glibc, march=armv8_1}\n Linux armv7l {call_abi=eabihf, libc=glibc, march=armv7l}\n Linux armv7l {call_abi=eabihf, libc=glibc, march=neonvfpv4}\n Linux powerpc64le {libc=glibc, march=power8}\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.filter_platforms-Tuple{AbstractVector{var\"#s241\"} where var\"#s241\"<:AbstractDependency, AbstractPlatform}","page":"Reference","title":"BinaryBuilderBase.filter_platforms","text":"filter_platforms(deps::AbstractVector{<:AbstractDependency}, p::AbstractPlatform)\n\nFilter the dependencies deps which are compatible with platform p.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.gcc_version","page":"Reference","title":"BinaryBuilderBase.gcc_version","text":"gcc_version(p::AbstractPlatform, GCC_builds::Vector{GCCBuild},\n            compilers::Vector{Symbol}=[:c];\n            llvm_version::Union{Nothing,VersionNumber}=nothing)\n\nReturns the closest matching GCC version number for the given particular platform, from the given set of options.  The compiler ABI and the microarchitecture of the platform will be taken into account.  If no match is found, returns an empty list.  compilers is the list of compilers used in the build, to choose the right version of GCC to couple with them if necessary.  If the keyword argument llvm_version is passed, it is used to filter the version of GCC for FreeBSD platforms.\n\nThis method assumes that the compiler ABI of the platform represents a platform that binaries will be run on, and thus versions are always rounded down; e.g. if the platform supports a libstdc++ version that corresponds to GCC 5.1.0, but the only GCC versions available to be picked from are 4.8.5 and 5.2.0, it will return 4.8.5, as binaries compiled with that version will run on this platform, whereas binaries compiled with 5.2.0 may not.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.generate_compiler_wrappers!-Tuple{AbstractPlatform}","page":"Reference","title":"BinaryBuilderBase.generate_compiler_wrappers!","text":"generate_compiler_wrappers!(platform::AbstractPlatform; bin_path::AbstractString,\n                            host_platform::AbstractPlatform = Platform(\"x86_64\", \"linux\"; libc = \"musl\", cxxstring_abi = \"cxx11\"),\n                            compilers::Vector{Symbol} = [:c],\n                            allow_unsafe_flags::Bool = false,\n                            lock_microarchitecture::Bool = true)\n\nWe generate a set of compiler wrapper scripts within our build environment to force all build systems to honor the necessary sets of compiler flags to build for our systems. Note that while platform_envs() sets many environment variables, those values are intended to be optional/overridable.  These values, while still overridable by directly invoking a compiler binary directly (e.g. /opt/{target}/bin/{target}-gcc), are much more difficult to override, as the flags embedded in these wrappers are absolutely necessary, and even simple programs will not compile without them.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.generate_per_uid_squashfs","page":"Reference","title":"BinaryBuilderBase.generate_per_uid_squashfs","text":"generate_per_uid_squashfs(cs, new_uid = getuid())\n\nIn order for the sandbox to work well, we need to have the uids of the squashfs images match the uid of the current unprivileged user.  Unfortunately there is no mount-time option to do this for us.  Fortunately, squashfs is simple enough that if the ID table is uncompressed, we can just manually patch the uids to be what we need.  This function performs this operation, by rewriting all UIDs and GIDs to the given new_uid (which defaults to the current user's UID).\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.get_concrete_platform-Tuple{AbstractPlatform}","page":"Reference","title":"BinaryBuilderBase.get_concrete_platform","text":"get_concrete_platform(platform::AbstractPlatform;\n                      preferred_gcc_version = nothing,\n                      preferred_llvm_version = nothing,\n                      compilers = nothing)\n\nReturn the concrete platform for the given platform based on the GCC compiler ABI.  The set of shards is chosen by the keyword arguments (see choose_shards).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.get_concrete_platform-Tuple{Platform, Vector{CompilerShard}}","page":"Reference","title":"BinaryBuilderBase.get_concrete_platform","text":"get_concrete_platform(platform::Platform, shards::Vector{CompilerShard})\n\nReturn the concrete platform for the given platform based on the GCC compiler ABI in the shards.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.getgid-Tuple{}","page":"Reference","title":"BinaryBuilderBase.getgid","text":"getgid()\n\nWrapper around libc's getgid() function\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.getuid-Tuple{}","page":"Reference","title":"BinaryBuilderBase.getuid","text":"getuid()\n\nWrapper around libc's getuid() function\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.import_docker_image-Tuple{CompilerShard, String}","page":"Reference","title":"BinaryBuilderBase.import_docker_image","text":"import_docker_image(rootfs::CompilerShard; verbose::Bool = false)\n\nChecks to see if the given rootfs has been imported into docker yet; if it hasn't, then do so so that we can run things like:\n\ndocker run -ti binarybuilder_rootfs:v2018.08.27 /bin/bash\n\nWhich, after all, is the foundation upon which this whole doodad is built.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.includedir-Tuple{Prefix}","page":"Reference","title":"BinaryBuilderBase.includedir","text":"includedir(prefix::Prefix)\n\nReturns the include directory for the given prefix\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.is_build_dependency","page":"Reference","title":"BinaryBuilderBase.is_build_dependency","text":"is_build_dependency(dep::AbstractDependency) -> Bool\n\nReturn whether dep is a build-time dependency or not.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.is_ecryptfs-Tuple{AbstractString}","page":"Reference","title":"BinaryBuilderBase.is_ecryptfs","text":"is_ecryptfs(path::AbstractString; verbose::Bool=false)\n\nChecks to see if the given path (or any parent directory) is placed upon an ecryptfs mount.  This is known not to work on current kernels, see this bug for more details: https://bugzilla.kernel.org/show_bug.cgi?id=197603\n\nThis method returns whether it is encrypted or not, and what mountpoint it used to make that decision.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.is_host_dependency","page":"Reference","title":"BinaryBuilderBase.is_host_dependency","text":"is_host_dependency(dep::AbstractDependency) -> Bool\n\nReturn whether dep is a dependency of the host platform or not.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.is_mounted-Tuple{CompilerShard, AbstractString}","page":"Reference","title":"BinaryBuilderBase.is_mounted","text":"is_mounted(cs::CompilerShard, build_prefix::String)\n\nReturn true if the given shard is mounted.  Uses run() so will error out if something goes awry.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.is_runtime_dependency","page":"Reference","title":"BinaryBuilderBase.is_runtime_dependency","text":"is_runtime_dependency(dep::AbstractDependency) -> Bool\n\nReturn whether dep is a runtime dependency or not.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.is_target_dependency-Tuple{AbstractDependency}","page":"Reference","title":"BinaryBuilderBase.is_target_dependency","text":"is_target_dependency(dep::AbstractDependency) -> Bool\n\nReturn whether dep is a dependency of the target platform or not.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.libdirs","page":"Reference","title":"BinaryBuilderBase.libdirs","text":"libdirs(prefix::Prefix, platform = HostPlatform())\n\nReturns the library directories for the given prefix (note that this differs between unix systems and windows systems, and between 32- and 64-bit systems).\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.locate-Tuple{ExecutableProduct, Prefix}","page":"Reference","title":"BinaryBuilderBase.locate","text":"locate(ep::ExecutableProduct, prefix::Prefix;\n       platform::AbstractPlatform = HostPlatform(),\n       verbose::Bool = false,\n       isolate::Bool = false)\n\nIf the given executable file exists and is executable, return its path.\n\nOn all platforms, an ExecutableProduct checks for existence of the file.  On non-Windows platforms, it will check for the executable bit being set. On Windows platforms, it will check that the file ends with \".exe\", (adding it on automatically, if it is not already present).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.locate-Tuple{FileProduct, Prefix}","page":"Reference","title":"BinaryBuilderBase.locate","text":"locate(fp::FileProduct, prefix::Prefix;\n       platform::AbstractPlatform = HostPlatform(),\n       verbose::Bool = false,\n       isolate::Bool = false)\n\nIf the given file exists, return its path.  The platform and isolate arguments are is ignored here, but included for uniformity.  For ease of use, we support a limited number of custom variable expansions such as ${target}, and ${nbits}, so that the detection of files within target-specific folders named things like /lib32/i686-linux-musl is simpler.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.locate-Tuple{LibraryProduct, Prefix}","page":"Reference","title":"BinaryBuilderBase.locate","text":"locate(lp::LibraryProduct, prefix::Prefix;\n       verbose::Bool = false,\n       platform::AbstractPlatform = HostPlatform())\n\nIf the given library exists (under any reasonable name) and is dlopen()able, (assuming it was built for the current platform) return its location.  Note that the dlopen() test is only run if the current platform matches the given platform keyword argument, as cross-compiled libraries cannot be dlopen()ed on foreign platforms.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.logdir-Tuple{Prefix}","page":"Reference","title":"BinaryBuilderBase.logdir","text":"logdir(prefix::Prefix; subdir::AbstractString=\"\")\n\nReturns the logs directory for the given prefix.  If subdir is a non-empty string, that directory it is appended to the logdir of the given prefix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.macos_sdk_already_installed-Tuple{}","page":"Reference","title":"BinaryBuilderBase.macos_sdk_already_installed","text":"macos_sdk_already_installed()\n\nReturns true if any piece of the MacOS SDK is already installed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.map_target-Tuple{CompilerShard}","page":"Reference","title":"BinaryBuilderBase.map_target","text":"map_target(cs::CompilerShard)\n\nReturn the location this compiler shard should be mounted at.  We basically analyze the name and platform of this shard and return a path based on that.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.mount-Tuple{CompilerShard, AbstractString}","page":"Reference","title":"BinaryBuilderBase.mount","text":"mount(cs::CompilerShard, build_prefix::String)\n\nMount a compiler shard, if possible.  Uses run() so will error out if something goes awry.  Note that this function only does something when using a .squashfs shard, with a UserNS or Docker runner, on Linux. All other combinations of shard archive type, runner and platform result in a no-op from this function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.package-Tuple{Prefix, AbstractString, VersionNumber}","page":"Reference","title":"BinaryBuilderBase.package","text":"package(prefix::Prefix, output_base::AbstractString,\n        version::VersionNumber;\n        platform::AbstractPlatform = HostPlatform(),\n        verbose::Bool = false, force::Bool = false)\n\nBuild a tarball of the prefix, storing the tarball at output_base, appending a version number, a platform-dependent suffix and a file extension. If no platform is given, defaults to current platform. Returns the full path to, the SHA256 hash and the git tree SHA1 of the generated tarball.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.platform_envs-Tuple{AbstractPlatform, AbstractString}","page":"Reference","title":"BinaryBuilderBase.platform_envs","text":"platform_envs(platform::AbstractPlatform, src_name::AbstractString;\n              host_platform = default_host_platform,\n              bootstrap::Bool=!isempty(bootstrap_list),\n              compilers::Vector{Symbol}=[:c],\n              verbose::Bool = false,\n              )\n\nGiven a platform and a src_name, generate a Dict mapping representing all the environment variables to be set within the build environment to force compiles toward the defined target architecture.  Examples of things set are PATH, CC, RANLIB, as well as nonstandard things like target.\n\nAccepted keyword arguments are:\n\nhost_platform: the platform of the host system,\nbootstraop: if true, only basic environment variables will be generated,\ncompilers: list of compilers, some environment variables will be generated only if the relevant compilers are used (e.g., for Go and Rust)\nverbose: holds the value of the V and VERBOSE environment variables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.platform_exeext-Tuple{AbstractPlatform}","page":"Reference","title":"BinaryBuilderBase.platform_exeext","text":"platform_exeext(p::AbstractPlatform)\n\nGet the executable extension for the given Platform.  Includes the leading ..\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.preferred_cxxstring_abi-Tuple{AbstractPlatform, CompilerShard}","page":"Reference","title":"BinaryBuilderBase.preferred_cxxstring_abi","text":"preferred_cxxstring_abi(platform::AbstractPlatform, shard::CompilerShard;\n                        gcc_builds::Vector{GCCBuild} = available_gcc_builds)\n\nReturn the C++ string ABI preferred by the given platform or GCCBootstrap shard.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.preferred_libgfortran_version-Tuple{AbstractPlatform, CompilerShard}","page":"Reference","title":"BinaryBuilderBase.preferred_libgfortran_version","text":"preferred_libgfortran_version(platform::AbstractPlatform, shard::CompilerShard;\n                              gcc_builds::Vector{GCCBuild} = available_gcc_builds)\n\nReturn the libgfortran version preferred by the given platform or GCCBootstrap shard.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.runshell","page":"Reference","title":"BinaryBuilderBase.runshell","text":"runshell(platform::AbstractPlatform = HostPlatform())\n\nLaunch an interactive shell session within the user namespace, with environment setup to target the given platform.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.satisfied-Tuple{Product, Prefix}","page":"Reference","title":"BinaryBuilderBase.satisfied","text":"satisfied(p::Product;\n          platform::AbstractPlatform = HostPlatform(),\n          verbose::Bool = false,\n          isolate::Bool = false)\n\nGiven a Product, return true if that Product is satisfied, e.g. whether a file exists that matches all criteria setup for that Product. If isolate is set to true, will isolate all checks from the main Julia process in the event that dlopen()'ing a library might cause issues.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.setup_dependencies-Tuple{Prefix, Vector{Pkg.Types.PackageSpec}, AbstractPlatform}","page":"Reference","title":"BinaryBuilderBase.setup_dependencies","text":"setup_dependencies(prefix::Prefix, dependencies::Vector{PackageSpec}, platform::AbstractPlatform; verbose::Bool = false)\n\nGiven a list of JLL package specifiers, install their artifacts into the build prefix. The artifacts are installed into the global artifact store, then copied into a temporary location, then finally symlinked into the build prefix.  This allows us to (a) save download bandwidth by not downloading the same artifacts over and over again, (b) maintain separation in the event of catastrophic containment failure, avoiding hosing the main system if a build script decides to try to modify the dependent artifact files, and (c) keeping a record of what files are a part of dependencies as opposed to the package being built, in the form of symlinks to a specific artifacts directory.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.setup_workspace","page":"Reference","title":"BinaryBuilderBase.setup_workspace","text":"setup_workspace(build_path::String, sources::Vector{SetupSource};\n                verbose::Bool = false)\n\nSets up a workspace within build_path, creating the directory structure needed by further steps, unpacking the source within build_path, and defining the environment variables that will be defined within the sandbox environment.\n\nThis method returns the Prefix to install things into, and the runner that can be used to launch commands within this workspace.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilderBase.shard_mappings-Tuple{Vector{CompilerShard}}","page":"Reference","title":"BinaryBuilderBase.shard_mappings","text":"shard_mappings(shards::Vector{CompilerShard})\n\nReturn the default mappings for a set of compiler shards\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.shard_path-Tuple{CompilerShard}","page":"Reference","title":"BinaryBuilderBase.shard_path","text":"shard_path(cs::CompilerShard)\n\nReturn the path to this shard on-disk; for unpacked shards, this is a directory. For squashfs shards, this is a file.  This will not cause a shard to be downloaded.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.supported_platforms-Tuple{}","page":"Reference","title":"BinaryBuilderBase.supported_platforms","text":"supported_platforms(;exclude::Union{Vector{<:Platform},Function}=x->false,\n                    experimental::Bool=false)\n\nReturn the list of supported platforms as an array of Platforms.  These are the platforms we officially support building for, if you see a mapping in get_shard_hash() that isn't represented here, it's probably because that platform is still considered \"in beta\".  If experimental=true, include platforms considered experimental.\n\nPlatforms can be excluded from the list by specifying an array of platforms to exclude i.e. supported_platforms(exclude=[Platform(\"i686\", \"windows\"), Platform(\"x86_64\", \"windows\")]) or a function that returns true for exclusions i.e.\n\nsupported_platforms(exclude=Sys.islinux)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.temp_prefix-Tuple{Function}","page":"Reference","title":"BinaryBuilderBase.temp_prefix","text":"temp_prefix(func::Function)\n\nCreate a temporary prefix, passing the prefix into the user-defined function so that build/packaging operations can occur within the temporary prefix, which is then cleaned up after all operations are finished.  If the path provided exists already, it will be deleted.\n\nUsage example:\n\nout_path = abspath(\"./libfoo\")\ntemp_prefix() do p\n    # <insert build steps here>\n\n    # tarball up the built package\n    tarball_path, tarball_hash = package(p, out_path)\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.uname-Tuple{}","page":"Reference","title":"BinaryBuilderBase.uname","text":"uname()\n\nOn Linux systems, return the strings returned by the uname() function in libc\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.unmount-Tuple{CompilerShard, String}","page":"Reference","title":"BinaryBuilderBase.unmount","text":"unmount(cs::CompilerShard, build_prefix::String)\n\nUnmount a compiler shard from a given build prefix, if possible.  Uses run() so will error out if something goes awry.  Note that this function only does something when using a squashfs shard on Linux.  All other combinations of shard archive type and platform result in a no-op.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.variable_name-Tuple{Product}","page":"Reference","title":"BinaryBuilderBase.variable_name","text":"variable_name(p::Product)\n\nReturn the variable name associated with this Product as a string\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilderBase.versioninfo-Tuple{}","page":"Reference","title":"BinaryBuilderBase.versioninfo","text":"versioninfo()\n\nHelper function to print out some debugging information\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.autobuild-Tuple{AbstractString, AbstractString, VersionNumber, Vector{var\"#s223\"} where var\"#s223\"<:AbstractSource, AbstractString, Vector{T} where T, Vector{var\"#s222\"} where var\"#s222\"<:Product, Vector{var\"#s29\"} where var\"#s29\"<:AbstractDependency}","page":"Reference","title":"BinaryBuilder.autobuild","text":"autobuild(dir::AbstractString, src_name::AbstractString,\n          src_version::VersionNumber, sources::Vector,\n          script::AbstractString, platforms::Vector,\n          products::Vector, dependencies::Vector;\n          verbose = false, debug = false,\n          skip_audit = false, ignore_audit_errors = true,\n          autofix = true, code_dir = nothing,\n          meta_json_file = nothing, require_license = true, kwargs...)\n\nRuns the boiler plate code to download, build, and package a source package for a list of platforms.  This method takes a veritable truckload of arguments, here are the relevant actors, broken down in brief:\n\ndir: the root of the build; products will be placed within dir/products,  and mountpoints will be placed within dir/build/.\nsrc_name: the name of the source package being built and will set the name  of the built tarballs.\nsrc_version: the version of the source package.\nplatforms: a list of platforms to build for.\nsources: a vector of all sources to download and unpack before building begins, as AbstractSources.\nscript: a string representing a shell script to run as the build.\nproducts: the list of Products which shall be built.\ndependencies: a vector of JLL dependency packages as AbstractDependency that should be installed before building begins.\nverbose: Enable verbose mode.  What did you expect?\ndebug: cause a failed build to drop into an interactive shell so that  the build can be inspected easily.\nskip_audit: disable the typical audit that occurs at the end of a build.\nignore_audit_errors: do not kill a build even if a problem is found.\nautofix: give BinaryBuilder permission to automatically fix issues it  finds during audit passes.  Highly recommended.\ncode_dir: sets where autogenerated JLL packages will be put.\nrequire_license enables a special audit pass that requires licenses to be  installed by all packages.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.get_compilers_versions-Tuple{}","page":"Reference","title":"BinaryBuilder.get_compilers_versions","text":"get_compilers_versions(; compilers = [:c])\n\nReturn the script string that is used to print the versions of the given compilers.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.BinaryPlatforms.detect_cxxstring_abi-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}","page":"Reference","title":"Base.BinaryPlatforms.detect_cxxstring_abi","text":"detect_cxxstring_abi(oh::ObjectHandle, platform::AbstractPlatform)\n\nGiven an ObjectFile, examine its symbols to discover which (if any) C++11 std::string ABI it's using.  We do this by scanning the list of exported symbols, triggering off of instances of St7__cxx11 or _ZNSs to give evidence toward a constraint on cxx11, cxx03 or neither.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.BinaryPlatforms.detect_libstdcxx_version-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}","page":"Reference","title":"Base.BinaryPlatforms.detect_libstdcxx_version","text":"detect_libstdcxx_version(oh::ObjectHandle, platform::AbstractPlatform)\n\nGiven an ObjectFile, examine its dynamic linkage to discover which (if any) libgfortran it's linked against.  The major SOVERSION will determine which GCC version we're restricted to.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.analyze_instruction_set-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}","page":"Reference","title":"BinaryBuilder.Auditor.analyze_instruction_set","text":"analyze_instruction_set(oh::ObjectHandle, platform::AbstractPlatform; verbose::Bool = false)\n\nAnalyze the instructions within the binary located at the given path for which minimum instruction set it requires, taking note of groups of instruction sets used such as avx, sse4.2, i486, etc....\n\nSome binary files (such as libopenblas) contain multiple versions of functions, internally determining which version to call by using the cpuid instruction to determine processor support.  In an effort to detect this, we make note of any usage of the cpuid instruction, disabling our minimum instruction set calculations if such an instruction is found, and notifying the user of this if verbose is set to true.\n\nNote that this function only really makes sense for x86/x64 binaries.  Don't run this on armv7l, aarch64, ppc64le etc... binaries and expect it to work.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.audit","page":"Reference","title":"BinaryBuilder.Auditor.audit","text":"audit(prefix::Prefix, src_name::AbstractString = \"\";\n                      io=stderr,\n                      platform::AbstractPlatform = HostPlatform(),\n                      verbose::Bool = false,\n                      silent::Bool = false,\n                      autofix::Bool = false,\n                      has_csl::Bool = true,\n                      require_license::Bool = true,\n      )\n\nAudits a prefix to attempt to find deployability issues with the binary objects that have been installed within.  This auditing will check for relocatability issues such as dependencies on libraries outside of the current prefix, usage of advanced instruction sets such as AVX2 that may not be usable on many platforms, linkage against newer glibc symbols, etc...\n\nThis method is still a work in progress, only some of the above list is actually implemented, be sure to actually inspect Auditor.jl to see what is and is not currently in the realm of fantasy.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.Auditor.check_license","page":"Reference","title":"BinaryBuilder.Auditor.check_license","text":"check_license(prefix, src_name; verbose::Bool = false,, silent::Bool = false)\n\nCheck that there are license files for the project called src_name in the prefix.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.Auditor.collapse_symlinks-Tuple{Vector{String}}","page":"Reference","title":"BinaryBuilder.Auditor.collapse_symlinks","text":"collapse_symlinks(files::Vector{String})\n\nGiven a list of files, prune those that are symlinks pointing to other files within the list.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.collect_files","page":"Reference","title":"BinaryBuilder.Auditor.collect_files","text":"collect_files(path::AbstractString, predicate::Function = f -> true)\n\nFind all files that satisfy predicate() when the full path to that file is passed in, returning the list of file paths.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.Auditor.compatible_marchs-Tuple{AbstractPlatform}","page":"Reference","title":"BinaryBuilder.Auditor.compatible_marchs","text":"compatible_marchs(p::AbstractPlatform)\n\nReturn a (sorted) list of compatible microarchitectures, starting from the most compatible to the most highly specialized.  If no microarchitecture is specified within p, returns the most generic microarchitecture possible for the given architecture.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.detect_libgfortran_version-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}","page":"Reference","title":"BinaryBuilder.Auditor.detect_libgfortran_version","text":"detect_libgfortran_version(oh::ObjectHandle, platform::AbstractPlatform)\n\nGiven an ObjectFile, examine its dynamic linkage to discover which (if any) libgfortran it's linked against.  The major SOVERSION will determine which GCC version we're restricted to.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.instruction_mnemonics-Tuple{AbstractString, AbstractPlatform}","page":"Reference","title":"BinaryBuilder.Auditor.instruction_mnemonics","text":"instruction_mnemonics(path::AbstractString, platform::AbstractPlatform)\n\nDump a binary object with objdump, returning a list of instruction mnemonics for further analysis with analyze_instruction_set().\n\nNote that this function only really makes sense for x86/x64 binaries.  Don't run this on armv7l, aarch64, ppc64le etc... binaries and expect it to work.\n\nThis function returns the list of mnemonics as well as the counts of each, binned by the mapping defined within instruction_categories.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.is_for_platform-Tuple{ObjectFile.ObjectHandle, AbstractPlatform}","page":"Reference","title":"BinaryBuilder.Auditor.is_for_platform","text":"is_for_platform(h::ObjectHandle, platform::AbstractPlatform)\n\nReturns true if the given ObjectHandle refers to an object of the given platform; E.g. if the given platform is for AArch64 Linux, then h must be an ELFHandle with h.header.e_machine set to ELF.EM_AARCH64.\n\nIn particular, this method and platform_for_object() both exist because the latter is not smart enough to deal with :glibc and :musl yet.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.is_troublesome_library_link-Tuple{AbstractString, AbstractPlatform}","page":"Reference","title":"BinaryBuilder.Auditor.is_troublesome_library_link","text":"is_troublesome_library_link(libname::AbstractString, platform::AbstractPlatform)\n\nReturn true if depending on libname is known to cause problems at runtime, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.minimum_march-Tuple{Dict, AbstractPlatform}","page":"Reference","title":"BinaryBuilder.Auditor.minimum_march","text":"minimum_march(counts::Dict, p::AbstractPlatform)\n\nThis function returns the minimum instruction set required, depending on whether the object file being pointed to is a 32-bit or 64-bit one:\n\nFor 32-bit object files, this returns one of [\"i686\", \"prescott\"]\nFor 64-bit object files, this returns one of [\"x86_64\", \"avx\", \"avx2\", \"avx512\"]\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.platform_for_object-Tuple{ObjectFile.ObjectHandle}","page":"Reference","title":"BinaryBuilder.Auditor.platform_for_object","text":"platform_for_object(oh::ObjectHandle)\n\nReturns the platform the given ObjectHandle should run on.  E.g. if the given ObjectHandle is an x86_64 Linux ELF object, this function will return Platform(\"x86_64\", \"linux\").  This function does not yet distinguish between different libc's such as :glibc and :musl.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.symlink_soname_lib-Tuple{AbstractString}","page":"Reference","title":"BinaryBuilder.Auditor.symlink_soname_lib","text":"symlink_soname_lib(path::AbstractString)\n\nWe require that all shared libraries are accessible on disk through their SONAME (if it exists).  While this is almost always true in practice, it doesn't hurt to make doubly sure.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.translate_symlinks-Tuple{AbstractString}","page":"Reference","title":"BinaryBuilder.Auditor.translate_symlinks","text":"translate_symlinks(root::AbstractString; verbose::Bool=false)\n\nWalks through the root directory given within root, finding all symlinks that point to an absolute path within root, and rewriting them to be a relative symlink instead, increasing relocatability.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.update_linkage-Tuple{Prefix, AbstractPlatform, AbstractString, Any, Any}","page":"Reference","title":"BinaryBuilder.Auditor.update_linkage","text":"update_linkage(prefix::Prefix, platform::AbstractPlatform, path::AbstractString,\n               old_libpath, new_libpath; verbose::Bool = false)\n\nGiven a binary object located at path within prefix, update its dynamic linkage to point to new_libpath instead of old_libpath.  This is done using a tool within the cross-compilation environment such as install_name_tool on MacOS or patchelf on Linux.  Windows platforms are completely skipped, as they do not encode paths or RPaths within their executables.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Auditor.warn_deadlinks-Tuple{AbstractString}","page":"Reference","title":"BinaryBuilder.Auditor.warn_deadlinks","text":"warn_deadlinks(root::AbstractString)\n\nWalks through the given root directory, finding broken symlinks and warning the user about them.  This is used to catch instances such as a build recipe copying a symlink that points to a dependency; by doing so, it implicitly breaks relocatability.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.canonicalize_file_url-Tuple{Any}","page":"Reference","title":"BinaryBuilder.Wizard.canonicalize_file_url","text":"Canonicalize URL to a file within a GitHub repo\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.canonicalize_source_url-Tuple{Any}","page":"Reference","title":"BinaryBuilder.Wizard.canonicalize_source_url","text":"Canonicalize a GitHub repository URL\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.change_script!-Tuple{Any, Any}","page":"Reference","title":"BinaryBuilder.Wizard.change_script!","text":"Change the script. This will invalidate all platforms to make sure we later\nverify that they still build with the new script.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.clone-Tuple{String, String}","page":"Reference","title":"BinaryBuilder.Wizard.clone","text":"clone(url::String, source_path::String)\n\nClone a git repository hosted at url into source_path, with a progress bar displayed to stdout.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.download_source-Tuple{BinaryBuilder.Wizard.WizardState}","page":"Reference","title":"BinaryBuilder.Wizard.download_source","text":"download_source(state::WizardState)\n\nAsk the user where the source code is coming from, then download and record the relevant parameters, returning the source url, the local path it is stored at after download, and a hash identifying the version of the code. In the case of a git source URL, the hash will be a git treeish identifying the exact commit used to build the code, in the case of a tarball, it is the sha256 hash of the tarball itself.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.edit_script-Tuple{BinaryBuilder.Wizard.WizardState, AbstractString}","page":"Reference","title":"BinaryBuilder.Wizard.edit_script","text":"edit_script(state::WizardState, script::AbstractString)\n\nFor consistency (and security), use the sandbox for editing a script, launching vi within an interactive session to edit a buildscript.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.filter_object_files-Tuple{Any}","page":"Reference","title":"BinaryBuilder.Wizard.filter_object_files","text":"filter_object_files(files)\n\nGiven a list of files, filter out any that cannot be opened by readmeta() from ObjectFile.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.interactive_build-Tuple{BinaryBuilder.Wizard.WizardState, Prefix, Runner, AbstractString, AbstractPlatform}","page":"Reference","title":"BinaryBuilder.Wizard.interactive_build","text":"interactive_build(state::WizardState, prefix::Prefix,\n                  ur::Runner, build_path::AbstractString)\n\nRuns the interactive shell for building, then captures bash history to save\nreproducible steps for building this source. Shared between steps 3 and 5\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.match_files-Tuple{BinaryBuilder.Wizard.WizardState, Prefix, AbstractPlatform, Vector{T} where T}","page":"Reference","title":"BinaryBuilder.Wizard.match_files","text":"match_files(state::WizardState, prefix::Prefix,\n            platform::AbstractPlatform, files::Vector; silent::Bool = false)\n\nInspects all binary files within a prefix, matching them with a given list of files, complaining if there are any files that are not properly matched and returning the set of normalized names that were not matched, or an empty set if all names were properly matched.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.normalize_name-Tuple{AbstractString}","page":"Reference","title":"BinaryBuilder.Wizard.normalize_name","text":"normalize_name(file::AbstractString)\n\nGiven a filename, normalize it, stripping out extensions.  E.g. the file path \"foo/libfoo.tar.gz\" would get mapped to \"libfoo\".\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.pick_preferred_platform-Tuple{Any}","page":"Reference","title":"BinaryBuilder.Wizard.pick_preferred_platform","text":"Pick the first platform for use to run on. We prefer Linux x86_64 because that's generally the host platform, so it's usually easiest. After that we go by the following preferences:\n\nOS (in order): Linux, Windows, OSX\nArchitecture: x86_64, i686, aarch64, powerpc64le, armv7l\nThe first remaining after this selection\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.print_autoconf_hint-Tuple{BinaryBuilder.Wizard.WizardState}","page":"Reference","title":"BinaryBuilder.Wizard.print_autoconf_hint","text":"print_autoconf_hint(state::WizardState)\n\nPrint a hint for projects that use autoconf to have a good ./configure line.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.provide_hints-Tuple{BinaryBuilder.Wizard.WizardState, AbstractString}","page":"Reference","title":"BinaryBuilder.Wizard.provide_hints","text":"provide_hints(state::WizardState, path::AbstractString)\n\nGiven an unpacked source directory, provide hints on how a user might go about building the binary bounty they so richly desire.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step1-Tuple{BinaryBuilder.Wizard.WizardState}","page":"Reference","title":"BinaryBuilder.Wizard.step1","text":"step1(state::WizardState)\n\nIt all starts with a single step, the unabashed ambition to leave your current stability and engage with the universe on a quest to create something new, beautiful and unforeseen.  It all ends with compiler errors.\n\nThis step selects the relevant platform(s) for the built binaries.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step2-Tuple{BinaryBuilder.Wizard.WizardState}","page":"Reference","title":"BinaryBuilder.Wizard.step2","text":"step2(state::WizardState)\n\nThis step obtains the source code to be built and required binary dependencies.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step34-Tuple{BinaryBuilder.Wizard.WizardState}","page":"Reference","title":"BinaryBuilder.Wizard.step34","text":"step34(state::WizardState)\n\nStarts initial build for Linux x86_64, which is our initial test target platform.  Sources that build properly for this platform continue on to attempt builds for more complex platforms.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step3_audit-Tuple{BinaryBuilder.Wizard.WizardState, AbstractPlatform, String}","page":"Reference","title":"BinaryBuilder.Wizard.step3_audit","text":"step3_audit(state::WizardState, platform::AbstractPlatform, prefix::Prefix)\n\nAudit the prefix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step3_interactive-Tuple{BinaryBuilder.Wizard.WizardState, Prefix, AbstractPlatform, Runner, AbstractString, Vector{String}}","page":"Reference","title":"BinaryBuilder.Wizard.step3_interactive","text":"step3_interactive(state::WizardState, prefix::Prefix, platform::AbstractPlatform,\n                  ur::Runner, build_path::AbstractString)\n\nThe interactive portion of step3, moving on to either rebuild with an edited script or proceed to step 4.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step3_retry-Tuple{BinaryBuilder.Wizard.WizardState}","page":"Reference","title":"BinaryBuilder.Wizard.step3_retry","text":"step3_retry(state::WizardState)\n\nRebuilds the initial Linux x86_64 build after things like editing the script file manually, etc...\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.step4-Tuple{BinaryBuilder.Wizard.WizardState, Runner, AbstractPlatform, AbstractString, Prefix}","page":"Reference","title":"BinaryBuilder.Wizard.step4","text":"step4(state::WizardState, ur::Runner, platform::AbstractPlatform,\n      build_path::AbstractString, prefix::Prefix)\n\nThe fourth step selects build products after the first build is done\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.with_gitcreds-Tuple{Any, AbstractString, AbstractString}","page":"Reference","title":"BinaryBuilder.Wizard.with_gitcreds","text":"with_gitcreds(f, username::AbstractString, password::AbstractString)\n\nCalls f with an LibGit2.UserPasswordCredential object as an argument, constructed from the username and password values. with_gitcreds ensures that the credentials object gets properly shredded after it's no longer necessary. E.g.:\n\njulia with_gitcreds(user, token) do creds     LibGit2.clone(\"https://github.com/foo/bar.git\", \"bar\"; credentials=creds) end`\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.yggdrasil_build_tarballs_path-Tuple{Any}","page":"Reference","title":"BinaryBuilder.Wizard.yggdrasil_build_tarballs_path","text":"yggdrasil_build_tarballs_path(name::String)\n\nReturn the relative path within an Yggdrasil clone where this project (given its name) would be stored.  This is useful for things like generating the build_tarballs.jl file and checking to see if it already exists, etc...\n\nNote that we do not allow case-ambiguities within Yggdrasil, we check for this using the utility function case_insensitive_file_exists(path).\n\n\n\n\n\n","category":"method"},{"location":"reference/#BinaryBuilder.Wizard.yggdrasil_deploy","page":"Reference","title":"BinaryBuilder.Wizard.yggdrasil_deploy","text":"yggdrasil_deploy(state::WizardState)\n\nWrite out a WizardState to a build_tarballs.jl in an Yggdrasil clone, then open a pull request against Yggdrasil.\n\n\n\n\n\n","category":"function"},{"location":"reference/#BinaryBuilder.Wizard.yn_prompt","page":"Reference","title":"BinaryBuilder.Wizard.yn_prompt","text":"yn_prompt(state::WizardState, question::AbstractString, default = :y)\n\nPerform a [Y/n] or [y/N] question loop, using default to choose between the prompt styles, and looping until a proper response (e.g. \"y\", \"yes\", \"n\" or \"no\") is received.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Command-Line","page":"Reference","title":"Command Line","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"build_tarballs","category":"page"},{"location":"reference/#BinaryBuilder.build_tarballs","page":"Reference","title":"BinaryBuilder.build_tarballs","text":"build_tarballs(ARGS, src_name, src_version, sources, script, platforms,\n               products, dependencies; kwargs...)\n\nThis should be the top-level function called from a build_tarballs.jl file. It takes in the information baked into a build_tarballs.jl file such as the sources to download, the products to build, etc... and will automatically download, build and package the tarballs, generating a build.jl file when appropriate.\n\nGenerally, ARGS should be the top-level Julia ARGS command-line arguments object.  build_tarballs does some rudimentary parsing of the arguments. To see what it can do, you can call it with --help in the ARGS or see the Command Line section in the manual.\n\nThe kwargs are passed on to autobuild, see there for a list of supported ones. A few additional keyword arguments are accept:\n\njulia_compat can be set to a version string which is used to set the supported Julia version in the [compat] section of the Project.toml of the generated JLL package. The default value is \"1.0\".\nlazy_artifacts sets whether the artifacts should be lazy.\ninit_block may be set to a string containing Julia code; if present, this code will be inserted into the initialization path of the generated JLL package. This can for example be used to invoke an initialization API of a shared library.\n\nnote: Note\nThe init_block keyword argument is experimental and may be removed in a future version of this package. Please use it sparingly.\n\n\n\n\n\n","category":"function"},{"location":"reference/","page":"Reference","title":"Reference","text":"The build_tarballs function also parses command line arguments. The syntax is described in the --help output:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"using BinaryBuilder, Markdown\nMarkdown.parse(\"\"\"\n```\n$(BinaryBuilder.BUILD_HELP)\n```\n\"\"\")","category":"page"},{"location":"troubleshooting/#Build-Troubleshooting","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"This page collects some known build errors and trick how to fix them.","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"If you have additional tips, please submit a PR with suggestions.","category":"page"},{"location":"troubleshooting/#All-platforms","page":"Build Troubleshooting","title":"All platforms","text":"","category":"section"},{"location":"troubleshooting/#General-comments","page":"Build Troubleshooting","title":"General comments","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"While below you will find some tips about common problems found when building packages in BinaryBuilder, keep in mind that if something fails during the build, there is not a magic recipe to fix it: you will need to understand what the problem is.  Most of the time it's a matter of trial-and-error.  The best recommendation is to access the build environment and carefully read the log files generated by the build systems: it is not uncommon that build systems would only print to screen misleading error messages, and the actual problem is completely different (e.g. \"library XYZ can't be found\", when the problem instead is that the command they run to look for library XYZ fails for unrelated reasons, for example for a wrong compiler flag used in the check).  Having an understanding of what the build system is doing would also be extremely useful.","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"You are welcome to open a pull request to Yggdrasil with a non-working build recipe, or ask for help in the #binarybuilder channel in the JuliaLang Slack.  Someone will likely help you out if and when they are available, like for any support provided by volunteers.","category":"page"},{"location":"troubleshooting/#How-to-retrieve-in-progress-build-script","page":"Build Troubleshooting","title":"How to retrieve in-progress build script","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"If the Wizard-based build fails after the first platform target, the Wizard may occasionally exit without resumability (because the only resume mode is to retry the failed platform). In this situation, the last build state and in-progress build script may be retrieved using the following steps:","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"state = BinaryBuilder.Wizard.load_wizard_state() # select 'resume'\nBinaryBuilder.Wizard.print_build_tarballs(stdout, state)","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"The build script may then be edited as appropriate – for example to disable the failing platform – and rerun directly with julia  build_tarballs.jl --debug --verbose (see manual build documentation) to debug and complete without starting from scratch.","category":"page"},{"location":"troubleshooting/#Header-files-of-the-dependencies-can't-be-found","page":"Build Troubleshooting","title":"Header files of the dependencies can't be found","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Sometimes the build system can't find the header files of the dependencies, even if they're properly installed.  When this happens, you have to inform the C/C++ preprocessor where the files are.","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"For example, if the project uses Autotools you can set the CPPFLAGS environment variable:","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"export CPPFLAGS=\"-I${prefix}/include\"\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs}\nmake install","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"See for example Cairo build script.","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"If instead the project uses CMake you'll need to use a different environment variable, since CMake ignores CPPFLAGS.  If the compiler that can't find the header file is the C one, you need to add the path to the CFLAGS variable (e.g., CFLAGS=\"-I${prefix}/include\"), in case it's the C++ one you have to set the CXXFLAGS variable (e.g., CXXFLAGS=\"-I${prefix}/include\").","category":"page"},{"location":"troubleshooting/#Libraries-of-the-dependencies-can't-be-found","page":"Build Troubleshooting","title":"Libraries of the dependencies can't be found","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Like in the section above, it may happen that the build system fails to find the libraries of the dependencies, even when they're installed to the right place, i.e. in the ${libdir} directory.  In these cases, you have to inform the linker where the libraries are by passing the option -L${libdir}.  The details of how to do that depend on the specific build system in use.","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"For Autotools- and CMake-based builds, you can the set the LDFLAGS environment variable:","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"export LDFLAGS=\"-L${libdir}\"\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs}\nmake install","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"See for example libwebp build script (in this case this was needed only when building for FreeBSD).","category":"page"},{"location":"troubleshooting/#Old-Autoconf-helper-scripts","page":"Build Troubleshooting","title":"Old Autoconf helper scripts","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Packages using Autoconf come with some helper scripts – like config.sub and config.guess – that the upstream developers need to keep up-to-date in order to get the latest improvements.  Some packages ship very old copies of these scripts, that for example don't know about the Musl C library.  In that case, after running ./configure you may get an error like","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"checking build system type... Invalid configuration `x86_64-linux-musl': system `musl' not recognized\nconfigure: error: /bin/sh ./config.sub x86_64-linux-musl failed","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"The BinaryBuilder environment provides the utility update_configure_scripts to automatically update these scripts, call it before ./configure:","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"update_configure_scripts\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nproc}\nmake install","category":"page"},{"location":"troubleshooting/#Building-with-an-old-GCC-version-a-library-that-has-dependencies-built-with-newer-GCC-versions","page":"Build Troubleshooting","title":"Building with an old GCC version a library that has dependencies built with newer GCC versions","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"The keyword argument preferred_gcc_version to the build_tarballs function allows you to select a newer compiler to build a library, if needed.  Pure C libraries have good compatibility so that a library built with a newer compiler should be able to run on a system using an older GCC version without problems.  However, keep in mind that each GCC version in BinaryBuilder.jl comes bundled with a specific version of binutils  – which provides the ld linker – see this table.","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"ld is quite picky and a given version of this tool doesn't like to link a library linked with a newer version: this means that if you build a library with, say, GCC v6, you'll need to build all libraries depending on it with GCC >= v6.  If you fail to do so, you'll get a cryptic error like this:","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"/opt/x86_64-linux-gnu/bin/../lib/gcc/x86_64-linux-gnu/4.8.5/../../../../x86_64-linux-gnu/bin/ld: /workspace/destdir/lib/libvpx.a(vp8_cx_iface.c.o): unrecognized relocation (0x2a) in section `.text'\n/opt/x86_64-linux-gnu/bin/../lib/gcc/x86_64-linux-gnu/4.8.5/../../../../x86_64-linux-gnu/bin/ld: final link failed: Bad value","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"The solution is to build the downstream libraries with at least the maximum of the GCC versions used by the dependencies:","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"build_tarballs(ARGS, name, version, sources, script, platforms, products, dependencies; preferred_gcc_version=v\"8\")","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"For instance, FFMPEG has to be built with GCC v8 because LibVPX requires GCC v8.","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Generally speaking, we try to build with the as old as possible version of GCC (v4.8.5 being the oldest one currently available), for maximum compatibility.","category":"page"},{"location":"troubleshooting/#Running-foreign-executables","page":"Build Troubleshooting","title":"Running foreign executables","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"The build environment provided by BinaryBuilder is a x86_64-linux-musl, and it can run executables for the following platforms: x86_64-linux-musl, x86_64-linux-gnu, i686-linux-gnu.  For all other platforms, if the build system tries to run a foreign executable you'll get an error, usually something like","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"./foreign.exe: line 1: ELF��\n                       @@xG@8@@@@@@���@�@@����A�A����A�A���@�@: not found\n./foreign.exe: line 1: syntax error: unexpected end of file (expecting \")\")","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"This is one of worst cases when cross-compiling, and there isn't a simple solution.  You have to look into the build process to see if running the executable can be skipped (see for example the patch to not run dot in #351), or replaced by something else.  If the executable is a compile-time only utility, try to build it with the native compiler (see for example the patch to build a native mkdefs in #351)","category":"page"},{"location":"troubleshooting/#PowerPC-Linux","page":"Build Troubleshooting","title":"PowerPC Linux","text":"","category":"section"},{"location":"troubleshooting/#Shared-library-not-built","page":"Build Troubleshooting","title":"Shared library not built","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Sometimes the shared library for powerpc64le-linux-gnu is not built after a successful compilation, and audit fails because only the static library has been compiled.  If the build uses Autotools, this most likely happens because the configure script was generated with a very old version of Autotools, which didn't know how to build shared libraries for this system.  The trick here is to regenerate the configure script with autoreconf:","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"autoreconf -vi\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nproc}\nmake install","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"See for example the builder for Giflib.  If you need to regenerate configure, you'll probably need to run update_configure_scripts to make other platforms work as well.","category":"page"},{"location":"troubleshooting/#FreeBSD","page":"Build Troubleshooting","title":"FreeBSD","text":"","category":"section"},{"location":"troubleshooting/#undefined-reference-to-backtrace_symbols'","page":"Build Troubleshooting","title":"undefined reference to `backtrace_symbols'","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"If compilation fails because of the following errors","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"undefined reference to `backtrace_symbols'\nundefined reference to `backtrace'","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"then you need to link to execinfo:","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"if [[ \"${target}\" == *-freebsd* ]]; then\n    export LDFLAGS=\"-lexecinfo\"\nfi\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs}\nmake install","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"See for example #354 and #982.","category":"page"},{"location":"troubleshooting/#undefined-reference-to-environ'","page":"Build Troubleshooting","title":"undefined reference to `environ'","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"This problem is caused by the -Wl,--no-undefined flag. Removing this flag may also fix the above problem with backtrace, if the undefined references appear together.","category":"page"},{"location":"troubleshooting/#Windows","page":"Build Troubleshooting","title":"Windows","text":"","category":"section"},{"location":"troubleshooting/#Libtool-refuses-to-build-shared-library-because-of-undefined-symbols","page":"Build Troubleshooting","title":"Libtool refuses to build shared library because of undefined symbols","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"When building for Windows, sometimes libtool refuses to build the shared library because of undefined symbols.  When this happens, compilation is successful but BinaryBuilder's audit can't find the expected LibraryProducts.","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"In the log of compilation you can usually find messages like","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"libtool: warning: undefined symbols not allowed in i686-w64-mingw32 shared libraries; building static only","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"or","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"libtool:   error: can't build i686-w64-mingw32 shared library unless -no-undefined is specified","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"In these cases you have to pass the -no-undefined option to the linker, as explicitly suggested by the second message.","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"A proper fix requires to add the -no-undefined flag to the LDFLAGS of the corresponding libtool archive in the Makefile.am file.  For example, this is done in CALCEPH, ERFA, and libsharp2.","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"A quick and dirty alternative to patching the Makefile.am file is to pass LDFLAGS=-no-undefined only to make:","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"FLAGS=()\nif [[ \"${target}\" == *-mingw* ]]; then\n    FLAGS+=(LDFLAGS=\"-no-undefined\")\nfi\n./configure --prefix=${prefix} --build=${MACHTYPE} --host=${target}\nmake -j${nprocs} \"${FLAGS[@]}\"\nmake install","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"Note that setting LDFLAGS=-no-undefined before ./configure would make this fail because it would run a command like cc -no-undefined conftest.c, which upsets the compiler).  See for example #170, #354.","category":"page"},{"location":"troubleshooting/#Libtool-refuses-to-build-shared-library-because-'-lmingw32'-is-not-a-real-file","page":"Build Troubleshooting","title":"Libtool refuses to build shared library because '-lmingw32' is not a real file","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"If you see errors like:","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"[14:12:52] *** Warning: linker path does not have real file for library -lmingw32.\n[14:12:52] *** I have the capability to make that library automatically link in when\n[14:12:52] *** you link to this library.  But I can only do this if you have a\n[14:12:52] *** shared version of the library, which you do not appear to have\n[14:12:52] *** because I did check the linker path looking for a file starting\n[14:12:52] *** with libmingw32 and none of the candidates passed a file format test\n[14:12:52] *** using a file magic. Last file checked: /opt/x86_64-w64-mingw32/x86_64-w64-mingw32/sys-root/lib/libmingw32.a","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"This is a bug in autoconf's ACF77LIBRARYLDFLAGS (or ACFCLIBRARYLDFLAGS) macro. A patch has been submitted to fix this upstream. In the meantime, you may be able to remove these macros. They are often not required.","category":"page"},{"location":"troubleshooting/#macOS","page":"Build Troubleshooting","title":"macOS","text":"","category":"section"},{"location":"troubleshooting/#CMake-complains-\"No-known-for-CXX-compiler\"","page":"Build Troubleshooting","title":"CMake complains \"No known for CXX compiler\"","text":"","category":"section"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"E.g. error messages like:","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"CMake Error in CMakeLists.txt:\n  No known features for CXX compiler\n\n  \"Clang\"\n\n  version 12.0.0.","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"This issue is caused by not setting CMake policy CMP0025. This policy is supposed to only affect the CompilerId for AppleClang, but it also has the effect of turning off feature detection for upstream clang (which is what we're using here) on CMake versions prior to CMake 3.18. Add","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"cmake_policy(SET CMP0025 NEW)","category":"page"},{"location":"troubleshooting/","page":"Build Troubleshooting","title":"Build Troubleshooting","text":"At the very top of your CMakeLists.txt, before the project definition (or get an updated version of CMake).","category":"page"},{"location":"building/#Building-Packages","page":"Building Packages","title":"Building Packages","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"A BinaryBuilder.jl build script (what is often referred to as a build_tarballs.jl file) looks something like this:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"using BinaryBuilder\n\nname = \"libfoo\"\nversion = v\"1.0.1\"\nsources = [\n    ArchiveSource(\"<url to source tarball>\", \"sha256 hash\"),\n]\n\nscript = raw\"\"\"\ncd ${WORKSPACE}/srcdir/libfoo-*\nmake -j${nproc}\nmake install\n\"\"\"\n\nplatforms = supported_platforms()\n\nproducts = [\n    LibraryProduct(\"libfoo\", :libfoo),\n    ExecutableProduct(\"fooifier\", :fooifier),\n]\n\ndependencies = [\n    Dependency(\"Zlib_jll\"),\n]\n\nbuild_tarballs(ARGS, name, version, sources, script, platforms, products, dependencies)","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"The build_tarballs function takes in the variables defined above and runs the builds, placing output tarballs into the ./products directory, and optionally generating and publishing the JLL package.  Let's see in more details what are the ingredients of the builder.","category":"page"},{"location":"building/#Name","page":"Building Packages","title":"Name","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"This is the name that will be used in the tarballs and for the JLL package.  It should be the name of the upstream package, not for example that of a specific library or executable provided by it, even though they may coincide.  The case of the name should match that of the upstream package.  Note that the name should be a valid Julia identifier, so it has meet some requirements, among which:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"it cannot start with a number,\nit cannot have spaces, dashes, or dots in the name.  You can use underscores to replace them.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"If you are unsure, you can use Base.isidentifer to check whehter the name is acceptable:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"julia> Base.isidentifier(\"valid_package_name\")\ntrue\n\njulia> Base.isidentifier(\"100-invalid package.name\")\nfalse","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Note that _jll will be automatically appended to the name of the generated JLL package.","category":"page"},{"location":"building/#Version-number","page":"Building Packages","title":"Version number","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"This is the version number used in tarballs and should coincide with the version of the upstream package.  However, note that this should only contain major, minor and patch numbers, so","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"julia> v\"1.2.3\"\nv\"1.2.3\"","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"is acceptable, but","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"julia> v\"1.2.3-alpha\"\nv\"1.2.3-alpha\"\n\njulia> v\"1.2.3+3\"\nv\"1.2.3+3\"","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"or a version including more than three levels (e.g., 1.2.3.4) are not. Truncate the version to the patch number if necessary.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"The generated JLL package will automatically add a build number, increasing it for each rebuild of the same package version.","category":"page"},{"location":"building/#Sources","page":"Building Packages","title":"Sources","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"The sources are what will be compiled with the build script.  They will be placed under ${WORKSPACE}/srcdir inside the build environment.  Sources can be of the following types:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"ArchiveSource: a compressed archive (e.g., tar.gz, tar.bz2, tar.xz, zip) that will be downloaded and automatically uncompressed;\nGitSource: a git repository that will be automatically cloned.  The specified revision will be checked out;\nFileSource: a generic file that will be downloaded from the Internet, without special treatment;\nDirectorySource: a local directory whose content will be copied in ${WORKSPACE}/srcdir.  This usually contains local patches used to non-interactively edit files in the source code of the package you want to build.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Example of packages with multiple sources of different types:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"libftd2xx.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Sources are not to be confused with the binary dependencies.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"note: Note\nEach builder should build a single package: don't use multiple sources to bundle multiple packages into a single recipe.  Instead, build each package separately, and use them as binary dependencies as appropriate.  This will increase reusability of packages.","category":"page"},{"location":"building/#Build-script","page":"Building Packages","title":"Build script","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"The script is a bash script executed within the build environment, which is a x86_64 Linux environment using the Musl C library, based on Alpine Linux (triplet: x86_64-linux-musl).  The section Build Tips provides more details about what you can usually do inside the build script.","category":"page"},{"location":"building/#Platforms","page":"Building Packages","title":"Platforms","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"The builder should also specify the list of platforms for which you want to build the package.  At the time of writing, we support Linux (x86_64, i686, armv6l, armv7l, aarch64, ppc64le), Windows (x86_64, i686), macOS (x86_64, aarch64) and FreeBSD (x86_64).  When possible, we try to build for all supported platforms, in which case you can set","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"platforms = supported_platforms()","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"You can get the list of the supported platforms and their associated triplets by using the functions supported_platforms and triplet:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"using BinaryBuilder\nsupported_platforms()\ntriplet.(supported_platforms())","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"The triplet of the platform is used in the name of the tarball generated.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"For some packages, (cross-)compilation may not be possible for all those platforms, or you have interested in building the package only for a subset of them.  Examples of packages built only for some platforms are","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"libevent;\nXorg_libX11: this is built only for Linux and FreeBSD systems, automatically filtered from supported_platforms, instead of listing the platforms explicitly.","category":"page"},{"location":"building/#Expanding-C-string-ABIs-or-libgfortran-versions","page":"Building Packages","title":"Expanding C++ string ABIs or libgfortran versions","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Building libraries is not a trivial task and entails a lot of compatibility issues, some of which are detailed in Tricksy Gotchas.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"You should be aware of two incompatibilities in particular:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"The standard C++ library that comes with GCC can have one of two incompatible ABIs for std::string, an old one usually referred to as C++03 string ABI, and a newer one conforming to the 2011 C++ standard.\nnote: Note\nThis ABI does not have to do with the C++ standard used by the source code, in fact you can build a C++03 library with the C++11 std::string ABI and a C++11 library with the C++03 std::string ABI.  This is achieved by appropriately setting the _GLIBCXX_USE_CXX11_ABI macro.\nThis means that when building with GCC a C++ library or program which exposes the std::string ABI, you must make sure that the user whill run a binary matching their std::string ABI.  You can manually specify the std::string ABI in the compiler_abi part of the platform, but BinaryBuilder lets you automatically expand the list of platform to include an entry for the C++03 std::string ABI and another one for the C++11 std::string ABI, by using the expand_cxxstring_abis function:\njulia> using BinaryBuilder\n\njulia> platforms = [Platform(\"x86_64\", \"linux\")]\n1-element Vector{Platform}:\n Linux x86_64 {libc=glibc}\n\njulia> expand_cxxstring_abis(platforms)\n2-element Vector{Platform}:\n Linux x86_64 {cxxstring_abi=cxx03, libc=glibc}\n Linux x86_64 {cxxstring_abi=cxx11, libc=glibc}\nExample of packages dealing with the C++ std::string ABIs are:\nGEOS: expands the the C++ std::string ABIs for all supported platforms;\nBloaty: builds the package only for some platforms and expands the C++ std::string ABIs;\nlibcgal_julia: builds only for platforms with C++11 std::string ABI.\nThe libgfortran that comes with GCC changed the ABI in a backward-incompatible way in the 6.X -> 7.X and the 7.X -> 8.X transitions. This means that when you build a package that will link to libgfortran, you must be sure that the user will use a package linking to a libgfortran version compatible with their own.  Also in this case you can either manually specify the libgfortran version in the compiler_abi part fo the platform or use a function, expand_gfortran_versions, to automatically expand the list of platform to include all possible libgfortran versions:\njulia> using BinaryBuilder\n\njulia> platforms = [Platform(\"x86_64\", \"linux\")]\n1-element Vector{Platform}:\n Linux x86_64 {libc=glibc}\n\njulia> expand_gfortran_versions(platforms)\n3-element Vector{Platform}:\n Linux x86_64 {libc=glibc, libgfortran_version=3.0.0}\n Linux x86_64 {libc=glibc, libgfortran_version=4.0.0}\n Linux x86_64 {libc=glibc, libgfortran_version=5.0.0}\nExample of packages expanding the libgfortran versions are:\nOpenSpecFun: expands the libgfortran versions for all supported platforms;\nLibAMVW: builds the package only for some platforms and expands the libgfortran versions.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Note that whether you need to build for different C++ string ABIs or libgfortran versions depends exclusively on whether the products of the current build expose the std::string ABI or directly link to libgfortran.  The fact that some of the dependencies need to expand the C++ string ABIs or libgfortran versions is not relevant for the current build recipe and BinaryBuilder will take care of installing libraries with matching ABI.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Don't worry if you don't know whether you need to expand the list of platforms for the C++ std::string ABIs or the libgfortran versions: this is often not possible to know in advance without thoroughly reading the source code or actually building the package.  In any case the audit will inform you if you have to use these expand-* functions.","category":"page"},{"location":"building/#Platform-independent-packages","page":"Building Packages","title":"Platform-independent packages","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"BinaryBuilder.jl is particularly useful to build packages involving shared libraries and binary executables.  There is little benefit in using this package to build a package that would be platform-independent, for example to install a dataset to be used in a Julia package on the user's machine.  For this purpose a simple Artifacts.toml file generated with create_artifact would do exactly the same job.  Nevertheless, there are cases where a platform-independent JLL package would still be useful, for example to build a package containing only header files that will be used as dependency of other packages.  To build a platform-independent package you can use the special platform AnyPlatform:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"platforms = [AnyPlatform()]","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Within the build environment, an AnyPlatform looks like x86_64-linux-musl, but this shouldn't affect your build in any way.  Note that when building a package for AnyPlatform you can only have products of type FileProduct, as all other types are platform-dependent.  The JLL package generated for an AnyPlatform is platform-independent and can thus be installed on any machine.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Example of builders using AnyPlatform:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"OpenCL_Headers;\nSPIRV_Headers.","category":"page"},{"location":"building/#Products","page":"Building Packages","title":"Products","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"The products are the files expected to be present in the generated tarballs.  If a product is not found in the tarball, the build will fail.  Products can be of the following types:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"LibraryProduct: this represent a shared library;\nExecutableProduct: this represent a binary executable program. Note: this cannot be used for interpreted scripts;\nFrameworkProduct (only when building for MacOS): this represents a macOS framework;\nFileProduct: a file of any type, with no special treatment.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"The audit will perform a series of sanity checks on the products of the builder, with the exclusion FileProducts, trying also to automatically fix some common issues.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"You don't need to list as products all files that will end up in the tarball, but only those you want to make sure are there and on which you want the audit to perform its checks.  This usually includes the shared libraries and the binary executables.  If you are also generating a JLL package, the products will have some variables that make it easy to reference them.  See the documentation of JLL packages for more information about this.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Packages listing products of different types:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Fontconfig.","category":"page"},{"location":"building/#Binary-dependencies","page":"Building Packages","title":"Binary dependencies","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"A build script can depend on binaries generated by another builder. A builder specifies dependencies in the form of previously-built JLL packages:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"# Dependencies of Xorg_xkbcomp\ndependencies = [\n    Dependency(\"Xorg_libxkbfile_jll\"),\n    BuildDependency(\"Xorg_util_macros_jll\"),\n]","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Dependency specify a JLL package that is necessary to build and load the current builder.  Binaries for the target platform will be installed;\nBuildDependency is a JLL package necessary only to build the current package, but not to load it.  This dependency will install binaries for the target platforms and will not be added to the list of the dependencies of the generated JLL package;\nHostBuildDependency: similar to BuildDependency, but it will install binaries for the host system.  This kind of dependency is usually added to provide some binary utilities to run during the build process.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"The argument of Dependency, BuildDependency, and HostBuildDependency can also be a Pkg.PackageSpec, with which you can specify more details about the dependency, like a version number, or also a non-registered package.  Note that in Yggdrasil only JLL packages in the General registry can be accepted.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"The dependencies for the target system (Dependency and BuildDependency) will be installed under ${prefix} within the build environment, while the dependencies for the host system (HostBuildDependency) will be installed under ${host_prefix}.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"In the wizard, dependencies can be specified with the prompt: Do you require any (binary) dependencies?  [y/N].","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Examples of builders that depend on other binaries include:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Xorg_libX11 depends on Xorg_libxcb_jll, and Xorg_xtrans_jll at build- and run-time, and on Xorg_xorgproto_jll and Xorg_util_macros_jll only at build-time.","category":"page"},{"location":"building/#Platform-dependent-dependencies","page":"Building Packages","title":"Platform-dependent dependencies","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"By default, all dependencies are used for all platforms, but there are some cases where a package requires some dependencies only on some platforms.  You can specify the platforms where a dependency is needed by passing the platforms keyword argument to the dependency constructor, which is the vector of AbstractPlatforms where the dependency should be used.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"For example, assuming that the variable platforms holds the vector of the platforms for which to build your package, you can specify that Package_jl is required on all platforms excluding Windows one with","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Dependency(\"Package_jll\"; platforms=filter(!Sys.iswindows, platforms))","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"The information that a dependency is only needed on some platforms is transferred to the JLL package as well: the wrappers will load the platform-dependent JLL dependencies only when needed.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"warning: Warning\nJulia's package manager doesn't have the concept of optional (or platform-dependent) dependencies: this means that when installing a JLL package in your environment, all of its dependencies will always be installed as well in any case.  It's only at runtime that platform-specific dependencies will be loaded where necessary.For the same reason, even if you specify a dependency to be not needed on for a platform, the build recipe may still pull it in if that's also an indirect dependency required by some other dependencies.  At the moment BinaryBuilder.jl isn't able to propagate the information that a dependency is platform-dependent when installing the artifacts of the dependencies.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Examples:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"ADIOS2 uses MPICH_jll to provide an MPI implementations on all platforms excluding Windows, and MicrosoftMPI_jll for Windows.\nGTK3 uses the X11 software stack only on Linux and FreeBSD platforms, and Wayland only on Linux.\nNativeFileDialog uses GTK3 only on Linux and FreeBSD, on all other platforms it uses system libraries, so no other packages are needed in those cases.","category":"page"},{"location":"building/#Version-number-of-dependencies","page":"Building Packages","title":"Version number of dependencies","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"There are two different ways to specify the version of a dependency, with two different meanings:","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Dependency(\"Foo_jll\", v\"1.2.3\"): the second argument of Dependency specifies the version of the package to be used for building: this version is not reflected into a compatibility bound in the project of the generated JLL package.  This is useful when the package you want to build is compatible with all the versions of the dependency starting from the given one (and then you don't want to restrict compatibility bounds of the JLL package), but to maximize compatibility you want to build against the oldest compatible version.\nDependency(PackageSpec(; name=\"Foo_jll\", version=v\"1.2.3\")): if the package is given as a Pkg.PackageSpec and the version keyword argument is given, this version of the package is used for the build and the generated JLL package will be compatible with the provided version of the package.  This should be used when your package is compatible only with a single version of the dependency, a condition that you want to reflect also in the project of the JLL package.","category":"page"},{"location":"building/#Building-and-testing-JLL-packages-locally","page":"Building Packages","title":"Building and testing JLL packages locally","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"As a package developer, you may want to test JLL packages locally, or as a binary dependency developer you may want to easily use custom binaries.  Through a combination of dev'ing out the JLL package and creating an overrides directory, it is easy to get complete control over the local JLL package state.","category":"page"},{"location":"building/#Overriding-a-prebuilt-JLL-package's-binaries","page":"Building Packages","title":"Overriding a prebuilt JLL package's binaries","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"After running pkg> dev LibFoo_jll, a local JLL package will be checked out to your depot's dev directory (on most installations this is ~/.julia/dev) and by default the JLL package will make use of binaries within your depot's artifacts directory.  If an override directory is present within the JLL package directory, the JLL package will look within that override directory for binaries, rather than in any artifact directory.  Note that there is no mixing and matching of binaries within a single JLL package; if an override directory is present, all products defined within that JLL package must be found within the override directory, none will be sourced from an artifact.  Dependencies (e.g. found within another JLL package) may still be loaded from their respective artifacts, so dependency JLLs must themselves be dev'ed and have override directories created with files or symlinks created within them.","category":"page"},{"location":"building/#Auto-populating-the-override-directory","page":"Building Packages","title":"Auto-populating the override directory","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"To ease creation of an override directory, JLL packages contain a dev_jll() function, that will ensure that a ~/.julia/dev/<jll name> package is dev'ed out, and will copy the normal artifact contents into the appropriate override directory.  This will result in no functional difference from simply using the artifact directory, but provides a template of files that can be replaced by custom-built binaries.","category":"page"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"Note that this feature is rolling out to new JLL packages as they are rebuilt; if a JLL package does not have a dev_jll() function, open an issue on Yggdrasil and a new JLL version will be generated to provide the function.","category":"page"},{"location":"building/#Building-a-custom-JLL-package-locally","page":"Building Packages","title":"Building a custom JLL package locally","text":"","category":"section"},{"location":"building/","page":"Building Packages","title":"Building Packages","text":"When building a new version of a JLL package, if --deploy is passed to build_tarballs.jl then a newly-built JLL package will be deployed to a GitHub repository.  (Read the documentation in the Command Line section or given by passing --help to a build_tarballs.jl script for more on --deploy options).  If --deploy=local is passed, the JLL package will still be built in the ~/.julia/dev/ directory, but it will not be uploaded anywhere.  This is useful for local testing and validation that the built artifacts are working with your package.","category":"page"},{"location":"#BinaryBuilder.jl","page":"Home","title":"BinaryBuilder.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The purpose of the BinaryBuilder.jl Julia package is to provide a system for compiling 3rd-party binary dependencies that should work anywhere the official Julia distribution does.  In particular, using this package you will be able to compile your large pre-existing codebases of C, C++, Fortran, Rust, Go, etc... software into binaries that can be downloaded and loaded/run on a very wide range of machines.  As it is difficult (and often expensive) to natively compile software packages across the growing number of platforms that this package will need to support, we focus on providing a set of Linux-hosted cross-compilers.  This package will therefore set up an environment to perform cross-compilation for all of the major platforms, and will do its best to make the compilation process as painless as possible.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that at this time, BinaryBuilder itself runs on Linux x86_64 and macOS x86_64 systems only, with Windows support under active development.  On macOS and Windows, you must have docker installed as the backing virtualization engine.  Note that Docker Desktop is the recommended version; if you have Docker Machine installed it may not work correctly or may need additional configuration.","category":"page"},{"location":"#Project-flow","page":"Home","title":"Project flow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Suppose that you have a Julia package Foo.jl which wants to use a compiled libfoo shared library.  As your first step in writing Foo.jl, you may compile libfoo locally on your own machine with your system compiler, then using Libdl.dlopen() to open the library, and ccall() to call into the exported functions.  Once you have written your C bindings in Julia, you will naturally desire to share the fruits of your labor with the rest of the world, and this is where BinaryBuilder can help you.  Not only will BinaryBuilder aid you in constructing compiled versions of all your dependencies, but it will also build a wrapper Julia package (referred to as a JLL package) to aid in installation, versioning, and build product localization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The first step in the BinaryBuilder journey is to create a build recipe, usually named build_tarballs.jl.  The Julia community curates a tree of build recipes, Yggdrasil, that already contains many examples of how to write a build_tarballs.jl file.  These files contain information such as the name, version and source locations for a particular build, as well as the actual steps (in the form of a bash script) and the products that should be generated by the build.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The result of a successful build is an autogenerated JLL package, typically uploaded to the JuliaBinaryWrappers github organization.  Binaries for each version of every build are uploaded to the GitHub releases page of the relevant JLL package.  Finally, a registration request is opened against the General Julia registry, so that packages such as the aforementioned Foo.jl can simply pkg> add libfoo_jll to download the binary artifacts as well as the autogenerated Julia wrapper code.  See also the FAQ, build tips, build troubleshooting and tricksy gotchas for help with common problems.","category":"page"},{"location":"#Wizard-interface","page":"Home","title":"Wizard interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BinaryBuilder.jl supports an interactive method for building the binary dependencies and capturing the commands used to build it into a build_tarballs.jl file: the Wizard interface.  To launch it, run","category":"page"},{"location":"","page":"Home","title":"Home","text":"using BinaryBuilder\nstate = BinaryBuilder.run_wizard()","category":"page"},{"location":"","page":"Home","title":"Home","text":"and follow the instructions on-screen.  You can watch an asciinema demo of the use of the wizard.","category":"page"},{"location":"#Manually-create-or-edit-build_tarballs.jl","page":"Home","title":"Manually create or edit build_tarballs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The wizard is a great tool, especially to get started with BinaryBuilder and create your first simple recipes for new packages.  However, it lacks the full control of all options you can use in a build_tarballs.jl script.  To generate this file (explained in greater detail in Building Packages), one can clone Yggdrasil, copy an existing build recipe, modify it, and submit a new pull request.  Manually editing the build_tarballs.jl script is also the recommended way when you want to update an existing recipe, rather then starting from scratch with the wizard.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The build_tarballs.jl script can be used as a command line utility, it takes a few options and as argument the list of triplets of the targets.  You can find more information about the syntax of the script in the Command Line section or by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia build_tarballs.jl --help","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can build the tarballs with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia build_tarballs.jl --debug --verbose","category":"page"},{"location":"","page":"Home","title":"Home","text":"The --debug option will drop you into the BinaryBuilder interactive shell if an error occurs.  If the build fails, after finding out the steps needed to fix the build you have to manually update the script in build_tarballs.jl.  You should run again the above command to make sure that everything is actually working.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since build_tarballs.jl takes as argument the comma-separated list of triplets for which to build the tarballs, you can select only a few of them.  For example, with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia build_tarballs.jl --debug --verbose aarch64-linux-musl,arm-linux-musleabihf","category":"page"},{"location":"","page":"Home","title":"Home","text":"you'll run the build script only for the aarch64-linux-musl and arm-linux-musleabihf target platforms.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you decide to use this workflow, however, you will need to manually open pull requests for Yggdrasil.","category":"page"},{"location":"#GitHub-Codespaces","page":"Home","title":"GitHub Codespaces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you already have access to the GitHub Codespaces service, you can use use BinaryBuilder and all the workflows described above in your browser or with Visual Studio Code, on any operating system, including those not natively supported by the package!  Head to Yggdrasil and create a new Codespace.","category":"page"},{"location":"#How-does-this-all-work?","page":"Home","title":"How does this all work?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BinaryBuilder.jl wraps a root filesystem that has been carefully constructed so as to provide the set of cross-compilers needed to support the wide array of platforms that Julia runs on.  This RootFS is then used as the chroot jail for a sandboxed process which runs within the RootFS as if that were the whole world.  The workspace containing input source code and (eventually) output binaries is mounted within the RootFS and environment variables are setup such that the appropriate compilers for a particular target platform are used by build tools.","category":"page"},{"location":"#Videos-and-tutorials","page":"Home","title":"Videos and tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"BinaryBuilder has been covered in some videos, you may want to check them out if you want to know more about the framework (the date is specified in parentheses, to make it clear how old/new the videos are):","category":"page"},{"location":"","page":"Home","title":"Home","text":"10 tips on how to build better binaries: JuliaCon 2018 talk by Elliot Saba introducing an early version of BinaryBuilder (2018-08-09)\nIntroduction to BinaryBuilder.jl: live building session by Mosè Giordano (2020-04-10)\nBinaryBuilder.jl - The Subtle Art of Binaries That Just Work: JuliaCon 2020 workshop by Elliot Saba and Mosè Giordano to guide users through the use of BinaryBuilder (2020-07-25)\nYour first BinaryBuilder.jl recipe with Julia: live building by Miguel Raz Guzmán Macedo (2021-04-07)\nBinaryBuilder.jl — The Subtle Art of Binaries That \"Just Work\": AlpineConf 2021 talk by Elliot Saba and Mosè Giordano, starts at 4:19:00 (2021-05-15)\nBinaryBuilder.jl — Using Julia's Pkg to deliver binary libraries: PackagingCon 2021 talk by Mosè Giordano & Elliot Saba (2021-11-10)","category":"page"},{"location":"tricksy_gotchas/#Tricksy-Gotchas","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"","category":"section"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"There are a plethora of gotchas when it comes to binary compilation and distribution that must be appropriately addressed, or the binaries will only work on certain machines and not others.  Here is an incomplete list of things that BinaryBuilder.jl takes care of for you:","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Uniform compiler interface","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"No need to worry about invoking compilers through weird names; just run gcc within the proper environment and you'll get the appropriate cross-compiler.  Triplet-prefixed names (such as x86_64-linux-gnu-gcc) are, of course, also available, and the same version of gcc, g++ and gfortran is used across all platforms.","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"glibc versioning","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"On Linux platforms that use glibc as the C runtime library (at the time of writing, this is the great majority of most desktop and server distros), it is necessary to compile code against a version of glibc that is older than any glibc version it will be run on.  E.g. if your code is compiled against glibc v2.5, it will run on glibc v2.6, but it will not run on glibc v2.4.  Therefore, to maximize compatibility, all code should be compiled against as old a version of glibc as possible.","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"gfortran versioning","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"When compiling FORTRAN code, the gfortran compiler has broken ABI compatibility in the 6.X -> 7.X transition, and the 7.X -> 8.X transition.  This means that code built with gfortran 6.X cannot be linked against code built with gfortran 7.X.  We therefore compile all gfortran code against multiple different gfortran versions, then at runtime decide which to download based upon the currently running process' existing linkage.","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"cxx11 string ABI","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"When switching from the cxx03 standard to cxx11 in GCC 5, the internal layout of std::string objects changed.  This causes incompatibility between C++ code passing strings back and forth across the public interface if they are not built with the same C++ string ABI.  We therefore detect when std::string objects are being passed around, and warn that you need to build two different versions, one with cxx03-style strings (doable by setting -D_GLIBCXX_USE_CXX11_ABI=0 for newer GCC versions) and one with cxx11-style strings.","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Library Dependencies","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"A large source of problems in binary distribution is improper library linkage.  When building a binary object that depends upon another binary object, some operating systems (such as macOS) bake the absolute path to the dependee library into the dependent, whereas others rely on the library being present within a default search path.  BinaryBuilder.jl takes care of this by automatically discovering these errors and fixing them by using the RPATH/RUNPATH semantics of whichever platform it is targeting.  Note that this is technically a build system error, and although we will fix it automatically, it will raise a nice yellow warning during build prefix audit time.","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Embedded absolute paths","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Similar to library dependencies, plain files (and even symlinks) can have the absolute location of files embedded within them.  BinaryBuilder.jl will automatically transform symlinks to files within the build prefix to be the equivalent relative path, and will alert you if any files within the prefix contain absolute paths to the build prefix within them.  While the latter cannot be automatically fixed, it may help in tracking down problems with the software later on.","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"Instruction Set Differences","category":"page"},{"location":"tricksy_gotchas/","page":"Tricksy Gotchas","title":"Tricksy Gotchas","text":"When compiling for architectures that have evolved over time (such as x86_64), it is important to target the correct instruction set, otherwise a binary may contain instructions that will run on the computer it was compiled on, but will fail rather ungracefully when run on a machine that does not have as new a processor.  BinaryBuilder.jl will automatically disassemble every built binary object and inspect the instructions used, warning the user if a binary is found that does not conform to the agreed-upon minimum instruction set architecture.  It will also notice if the binary contains a cpuid instruction, which is a good sign that the binary is aware of this issue and will internally switch itself to use only available instructions.","category":"page"}]
}
