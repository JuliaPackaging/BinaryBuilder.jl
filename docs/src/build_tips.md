# Tips for Building Packages

BinaryBuilder provides a convenient environment to enable cross-platform building. But, many libraries have complicated build scripts that may need to be adapted to support all of the BinaryBuilder targets.

*If you have additional tips, please submit a PR with suggestions.*

## Initiating different shell commands based on target

Sometimes, you need to adapt build scripts based on the target platform. This can be done within the shell script. Here is an example from [staticfloat/OpenBLASBuilder](https://github.com/staticfloat/OpenBLASBuilder/blob/master/build_tarballs.jl):

```sh
# Set BINARY=32 on i686 platforms and armv7l
if [[ ${nbits} == 32 ]]; then
    flags="${flags} BINARY=32"
fi
```

Here are other examples of scripts with target-specific checks:

* [XZ](https://github.com/JuliaPackaging/Yggdrasil/blob/8b9ba2b7b4652e96daf506c98c2b373b48eef5cb/X/XZ/build_tarballs.jl) - Custom windows installation
* [Sundials](https://github.com/JuliaPackaging/Yggdrasil/blob/fdbb7392c498cbf5b440cc947c29ab6790de18c6/S/Sundials/build_tarballs.jl#L52-L60) - 32-bit check

It is also possible to run quite different scripts for each target by running different build scripts for different sets of targets. Here is an example where windows builds are separated from other targets:

* [Git](https://github.com/JuliaPackaging/Yggdrasil/blob/bf4ac37978764a3e953d06d7ed052ef06968f3bf/G/Git/build_tarballs.jl)

## Autoconfigure builds

Autoconfigure builds are generally quite straightforward. Here is a typical approach:

```sh
./configure --prefix=$prefix --host=${target}
make -j${nproc}
make install
```

Here are examples of autoconfigure build scripts:

* [Patchelf](https://github.com/JuliaPackaging/Yggdrasil/blob/4cacbf2377730f60255500b4e7dd58d9f9c18752/P/Patchelf/build_tarballs.jl#L18-L20)
* [LibCURL](https://github.com/JuliaPackaging/Yggdrasil/blob/4dd53a5ea3df104aa9f3f8f4cd9996568871d2af/L/LibCURL/build_tarballs.jl#L37-L39)


## CMake builds

For CMake, the wizard will suggest a template for running CMake. Typically, this will look like:

```sh
cmake -DCMAKE_INSTALL_PREFIX=${prefix} -DCMAKE_TOOLCHAIN_FILE=${CMAKE_TARGET_TOOLCHAIN}
```

The toolchain file sets up several CMake environment variables for better cross-platform support, such as `CMAKE_SYSROOT`, `CMAKE_C_COMPILER`, etc...  Examples of builds that include CMake parts include:

* [JpegTurbo](https://github.com/JuliaPackaging/Yggdrasil/blob/92fb385b4de0bdd0c378b45e83ef4bad116bbd08/J/JpegTurbo/build_tarballs.jl)

* [Sundials](https://github.com/JuliaPackaging/Yggdrasil/blob/fdbb7392c498cbf5b440cc947c29ab6790de18c6/S/Sundials/build_tarballs.jl#L46-L60)
  - Needs `-DSUNDIALS_INDEX_TYPE=int32_t` on 32-bit targets (Sundials-specific way to specify integer size)
  - Needs to copy *.dll files from `destdir/lib` to `destdir/bin` for windows; this also removes symlinks by using `cp -L`
  - Needs `-DCMAKE_FIND_ROOT_PATH="$WORKSPACE/destdir"`, so CMake's `find_library` can find libraries from KLU


## Builds with binary dependencies

A build script can depend on binaries generated by another Builder repository. A builder specifies `dependencies` in the form of previously-built JLL packages:

```julia
dependencies = [
    # We need libogg to build FLAC
    "Ogg_jll",
]
```

In the wizard, this can be specified with the prompt: *Do you require any (binary) dependencies?  [y/N]*.

Examples of builders that depend on other binaries include:

* [ImageMagick](https://github.com/JuliaPackaging/Yggdrasil/blob/029e588412f232f215e5e6a7564693d3dbf8e922/I/ImageMagick/build_tarballs.jl#L32-L35) depends on `Zlib`, `libpng`, `JpegTurbo` and `Libtiff`.

## Editing files in the wizard

In the wizard, the `vim` editor is available for editing files. But, it doesn't leave any record in the build script. One generally needs to provide patch files or use something like `sed`. If a file needs patching, we suggest using `git` to add the entire worktree to a new repo, make the changes you need, then use `git diff -p` to output a patch that can be included alongside your build recipe.

You can include local files like patches very easily by placing them within a `bundled/patches` nested directory, and then providing `"./bundled"` as one of the `sources` for your build.  See, for example, [`OpenBLAS`](https://github.com/JuliaPackaging/Yggdrasil/tree/029e588412f232f215e5e6a7564693d3dbf8e922/O/OpenBLAS).

## Using GCC on macOS and FreeBSD

For these target systems Clang is the default compiler, however some programs may not be compatible with Clang.  There isn't an automatic switch to use GCC, but if you need to use this compiler you only need to set the appropriate variables.  For example, this setting can be used to build most C/C++/Fortran programs with GCC for FreeBSD and macOS:
```sh
if [[ "${target}" == *-freebsd* ]] || [[ "${target}" == *-apple-* ]]; then
    CC=/opt/${target}/bin/${target}-gcc
    CXX=/opt/${target}/bin/${target}-g++
    FC=/opt/${target}/bin/${target}-gfortran
    LD=/opt/${target}/bin/${target}-ld
    AR=/opt/${target}/bin/${target}-ar
    AS=/opt/${target}/bin/${target}-as
    NM=/opt/${target}/bin/${target}-nm
    OBJDUMP=/opt/${target}/bin/${target}-objdump
fi
```
