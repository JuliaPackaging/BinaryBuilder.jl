<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>JLL packages · BinaryBuilder.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><script src="../../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BinaryBuilder.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../building/">Building Packages</a></li><li><a class="tocitem" href="../build_tips/">Build Tips</a></li><li class="is-active"><a class="tocitem" href>JLL packages</a><ul class="internal"><li><a class="tocitem" href="#Anatomy-of-a-JLL-package"><span>Anatomy of a JLL package</span></a></li><li><a class="tocitem" href="#The-wrappers"><span>The wrappers</span></a></li><li><a class="tocitem" href="#Overriding-the-artifacts-in-JLL-packages"><span>Overriding the artifacts in JLL packages</span></a></li></ul></li><li><a class="tocitem" href="../FAQ/">FAQ</a></li><li><a class="tocitem" href="../troubleshooting/">Build Troubleshooting</a></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../rootfs/">RootFS</a></li><li><a class="tocitem" href="../environment_variables/">Environment Variables</a></li><li><a class="tocitem" href="../tricksy_gotchas/">Tricksy Gotchas</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>JLL packages</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>JLL packages</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaPackaging/BinaryBuilder.jl/blob/master/docs/src/jll.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="JLL-packages"><a class="docs-heading-anchor" href="#JLL-packages">JLL packages</a><a id="JLL-packages-1"></a><a class="docs-heading-anchor-permalink" href="#JLL-packages" title="Permalink"></a></h1><p><code>BinaryBuilder.jl</code> is designed to produce tarballs that can be used in any environment, but so far their main use has been to provide pre-built libraries and executables to be readily used in Julia packages.  This is accomplished by JLL packages (a pun on &quot;Dynamic-Link Library&quot;, with the J standing for Julia). They can be installed like any other Julia packages with the <a href="https://julialang.github.io/Pkg.jl/v1/">Julia package manager</a> in the REPL with</p><pre><code class="nohighlight hljs">]add NAME_jll</code></pre><p>and then loaded with</p><pre><code class="nohighlight hljs">using NAME_jll</code></pre><p>However, most users will not ever need to do these steps on their own, JLL packages are usually only used as dependencies of packages wrapping binary libraries or executables.</p><p>Most JLL packages live under the <a href="https://github.com/JuliaBinaryWrappers"><code>JuliaBinaryWrappers</code></a> organization on GitHub, and the builders to generate them are maintaned in <a href="https://github.com/JuliaPackaging/Yggdrasil/">Yggdrasil</a>, the community build tree.  <code>BinaryBuilder.jl</code> allows anyone to create their own JLL package and publish them to a GitHub repository of their choice without using Yggdrasil, see the <a href="../FAQ/#Frequently-Asked-Questions">Frequently Asked Questions</a>.</p><h2 id="Anatomy-of-a-JLL-package"><a class="docs-heading-anchor" href="#Anatomy-of-a-JLL-package">Anatomy of a JLL package</a><a id="Anatomy-of-a-JLL-package-1"></a><a class="docs-heading-anchor-permalink" href="#Anatomy-of-a-JLL-package" title="Permalink"></a></h2><p>A somewhat popular misconception is that JLL packages are &quot;special&quot;.  Instead, they are simple Julia packages with a common structure, as they are generated automatically.  This is the typical tree of a JLL package, called in this example <code>NAME_jll.jl</code>:</p><pre><code class="nohighlight hljs">NAME_jll
├── Artifacts.toml
├── LICENSE
├── Project.toml
├── README.md
└── src/
    ├── NAME_jll.jl
    └── wrappers/
        ├── aarch64-linux-gnu.jl
        ├── aarch64-linux-musl.jl
        ├── armv7l-linux-gnueabihf.jl
        ├── armv7l-linux-musleabihf.jl
        ├── i686-linux-gnu.jl
        ├── i686-linux-musl.jl
        ├── i686-w64-mingw32.jl
        ├── powerpc64le-linux-gnu.jl
        ├── x86_64-apple-darwin14.jl
        ├── x86_64-linux-gnu.jl
        ├── x86_64-linux-musl.jl
        ├── x86_64-unknown-freebsd11.1.jl
        └── x86_64-w64-mingw32.jl</code></pre><p>These are the main ingredients of a JLL package:</p><ul><li><code>LICENSE</code>, a file stating the license of the JLL package.  Note that this may differ from the license of the library it wraps, which is instead shipped inside the tarballs;</li><li>a <a href="https://en.wikipedia.org/wiki/README"><code>README.md</code></a> file providing some information about the content of the wrapper, like the list of &quot;products&quot; provided by the package;</li><li>the <a href="https://julialang.github.io/Pkg.jl/v1/artifacts/#Artifacts.toml-files-1"><code>Artifacts.toml</code> file</a> contains the information about all the available tarballs for the given package.  The tarballs are uploaded to GitHub releases;</li><li>the <a href="https://julialang.github.io/Pkg.jl/v1/toml-files/#Project.toml-1"><code>Project.toml</code></a> file describes the packages dependencies and their compatibilities;</li><li>the main entry point of the package is the file called <code>src/NAME_jll.jl</code>. This is what is executed when you issue the command<pre><code class="language-jl hljs">using NAME_jll</code></pre>This file reads the list of tarballs available in <code>Artifacts.toml</code> and choose the platform matching the current platform.  Some JLL packages are not built for all supported platforms.  If the current platform is one of those platform not supported by the JLL package, this is the end of the package.  Instead, if the current platform is supported, the corresponding wrapper in the <code>src/wrappers/</code> directory will be included;</li><li>the <code>wrappers/</code> directory contains a file for each of the supported platforms.  They are actually mostly identical, with some small differences due to platform-specific details.  The wrappers are analyzed in more details in the following section.</li></ul><h2 id="The-wrappers"><a class="docs-heading-anchor" href="#The-wrappers">The wrappers</a><a id="The-wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#The-wrappers" title="Permalink"></a></h2><p>The files in the <code>src/wrappers/</code> directory are very thin automatically-generated wrappers around the binary package provided by the JLL package.  They load all the JLL packages that are dependencies of the current JLL package and export the names of the products listed in the <code>build_tarballs.jl</code> script that produced the current JLL package.  Among others, they also define the following unexported variables:</p><ul><li><code>artifact_dir</code>: the absolute path to where the artifact for the current platform has been installed.  This is the &quot;prefix&quot; where the binaries/libraries/files are placed;</li><li><code>PATH</code>: the value of the <a href="https://en.wikipedia.org/wiki/PATH_(variable)"><code>PATH</code></a> environment variable needed to run executables in the current JLL package, if any;</li><li><code>PATH_list</code>: the list of directories in <code>PATH</code> as a vector of <code>String</code>s;</li><li><code>LIBPATH</code>: the value of the environment variable that holds the list of directories in which to search shared libraries.  This has the correct value for the libraries provided by the current JLL package;</li><li><code>LIBPATH_list</code>: the list of directories in <code>LIBPATH</code> as a vector of <code>String</code>s.</li></ul><p>The wrapper files for each platform also define the <a href="https://docs.julialang.org/en/v1/manual/modules/index.html#Module-initialization-and-precompilation-1"><code>__init__()</code></a> function of the JLL package, the code that is executed every time the package is loaded.  The <code>__init__()</code> function will populate most of the variables mentioned above and automatically open the shared libraries, if any, listed in the products of the <code>build_tarballs.jl</code> script that generated the JLL package.</p><p>The rest of the code in the wrappers is specific to each of the products of the JLL package and detailed below.  If you want to see a concrete example of a package providing all the main three products, have a look at <a href="https://github.com/JuliaBinaryWrappers/Fontconfig_jll.jl/tree/785936d816d1ae65c2a6648f3a6acbfd72535e36"><code>Fontconfig_jll.jl</code></a>.</p><p>In addition to the variables defined above by each JLL wrapper, the package <a href="https://github.com/JuliaPackaging/JLLWrappers.jl"><code>JLLWrappers</code></a> defines an additional unexported variable:</p><ul><li><code>LIBPATH_env</code>: the name of the environment variable of the search paths of the shared libraries for the current platform.  This is equal to <code>LD_LIBRARY_PATH</code> on Linux and FreeBSD, <code>DYLD_FALLBACK_LIBRARY_PATH</code> on macOS, and <code>PATH</code> on Windows.</li></ul><p>In what follows, we will use as an example a builder that has these products:</p><pre><code class="language-julia hljs">products = [
    FileProduct(&quot;src/data.txt&quot;, :data_txt),
    LibraryProduct(&quot;libdataproc&quot;, :libdataproc),
    ExecutableProduct(&quot;mungify&quot;, :mungify_exe),
]</code></pre><h3 id="LibraryProduct"><a class="docs-heading-anchor" href="#LibraryProduct">LibraryProduct</a><a id="LibraryProduct-1"></a><a class="docs-heading-anchor-permalink" href="#LibraryProduct" title="Permalink"></a></h3><p>A <a href="../reference/#BinaryBuilderBase.LibraryProduct"><code>LibraryProduct</code></a> is a shared library that can be <a href="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/"><code>ccall</code></a>ed from Julia.  Assuming that the product is called <code>libdataproc</code>, the wrapper defines the following variables:</p><ul><li><p><code>libdataproc</code>: this is the exported <a href="https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Constants-1"><code>const</code></a> variable that should be used in <a href="https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/index.html"><code>ccall</code></a>:</p><pre><code class="language-julia hljs">num_chars = ccall((:count_characters, libdataproc), Cint,
                  (Cstring, Cint), data_lines[1], length(data_lines[1]))</code></pre><p>Roughly speaking, the value of this variable is the basename of the shared library, not its full absolute path;</p></li><li><p><code>libdataproc_path</code>: the full absolute path of the shared library.  Note that this is not <code>const</code>, thus it can&#39;t be used in <code>ccall</code>;</p></li><li><p><code>libdataproc_handle</code>: the address in memory of the shared library after it has been loaded at initialization time.</p></li></ul><h3 id="ExecutableProduct"><a class="docs-heading-anchor" href="#ExecutableProduct">ExecutableProduct</a><a id="ExecutableProduct-1"></a><a class="docs-heading-anchor-permalink" href="#ExecutableProduct" title="Permalink"></a></h3><p>An <a href="../reference/#BinaryBuilderBase.ExecutableProduct"><code>ExecutableProduct</code></a> is a binary executable that can be run on the current platform.  If, for example, the <code>ExecutableProduct</code> has been called <code>mungify_exe</code>, the wrapper defines an exported function named <code>mungify_exe</code> that should run by the user in one the following ways: versions:</p><pre><code class="language-julia hljs"># Only available in Julia v1.6+
run(`$(mungify_exe()) $arguments`)</code></pre><pre><code class="language-julia hljs">mungify_exe() do exe
    run(`$exe $arguments`)
end</code></pre><p>Note that in the latter form <code>exe</code> can be replaced with any name of your choice: with the <a href="https://docs.julialang.org/en/v1/manual/functions/#Do-Block-Syntax-for-Function-Arguments-1"><code>do</code>-block</a> syntax you are defining the name of the variable that will be used to actually call the binary with <a href="https://docs.julialang.org/en/v1/base/base/#Base.run"><code>run</code></a>.</p><p>The former form is only available when using Julia v1.6, but should be preferred going forward, as it is thread-safe and generally more flexible.</p><p>A common point of confusion about <code>ExecutableProduct</code>s in JLL packages is why these function wrappers are needed: while in principle you could run the executable directly by using its absolute path in <code>run</code>, these functions ensure that the executable will find all shared libraries it needs while running.</p><p>In addition to the function called <code>mungify_exe</code>, for this product there will be the following unexported variables:</p><ul><li><code>mungify_exe_path</code>: the full absolute path of the executable;</li></ul><h3 id="FileProduct"><a class="docs-heading-anchor" href="#FileProduct">FileProduct</a><a id="FileProduct-1"></a><a class="docs-heading-anchor-permalink" href="#FileProduct" title="Permalink"></a></h3><p>A <a href="../reference/#BinaryBuilderBase.FileProduct"><code>FileProduct</code></a> is a simple file with no special treatment.  If, for example, the <code>FileProduct</code> has been called <code>data_txt</code>, the only variables defined for it are:</p><ul><li><p><code>data_txt</code>: this exported variable has the absolute path to the mentioned file:</p><pre><code class="language-julia hljs">data_lines = open(data_txt, &quot;r&quot;) do io
    readlines(io)
end</code></pre></li><li><p><code>data_txt_path</code>: this unexported variable is actually equal to <code>data_txt</code>, but is kept for consistency with all other product types.</p></li></ul><h2 id="Overriding-the-artifacts-in-JLL-packages"><a class="docs-heading-anchor" href="#Overriding-the-artifacts-in-JLL-packages">Overriding the artifacts in JLL packages</a><a id="Overriding-the-artifacts-in-JLL-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Overriding-the-artifacts-in-JLL-packages" title="Permalink"></a></h2><p>As explained above, JLL packages use the <a href="https://julialang.github.io/Pkg.jl/v1/artifacts">Artifacts system</a> to provide the files. If you wish to override the content of an artifact with their own binaries/libraries/files, you can use the <a href="https://julialang.github.io/Pkg.jl/v1/artifacts/#Overriding-artifact-locations-1"><code>Overrides.toml</code> file</a>.</p><p>We detail below a couple of different ways to override the artifact of a JLL package, depending on whether the package is <code>dev</code>&#39;ed or not.  The second method is particularly recommended to system administrator who wants to use system libraries in place of the libraries in JLL packages.</p><h3 id="dev&#39;ed-JLL-packages"><a class="docs-heading-anchor" href="#dev&#39;ed-JLL-packages"><code>dev</code>&#39;ed JLL packages</a><a id="dev&#39;ed-JLL-packages-1"></a><a class="docs-heading-anchor-permalink" href="#dev&#39;ed-JLL-packages" title="Permalink"></a></h3><p>In the event that a user wishes to override the content within a <code>dev</code>&#39;ed JLL package, the user may use the <code>dev_jll()</code> method provided by JLL packages to check out a mutable copy of the package to their <code>~/.julia/dev</code> directory.  An <code>override</code> directory will be created within that package directory, providing a convenient location for the user to copy in their own files over the typically artifact-sourced ones.  See the segment on &quot;Building and testing JLL packages locally&quot; in the <a href="../building/">Building Packages</a> section of this documentation for more information on this capability.</p><h3 id="Non-dev&#39;ed-JLL-packages"><a class="docs-heading-anchor" href="#Non-dev&#39;ed-JLL-packages">Non-<code>dev</code>&#39;ed JLL packages</a><a id="Non-dev&#39;ed-JLL-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Non-dev&#39;ed-JLL-packages" title="Permalink"></a></h3><p>As an example, in a Linux system you can override the Fontconfig library provided by <a href="https://github.com/JuliaBinaryWrappers/Fontconfig_jll.jl"><code>Fontconfig_jll.jl</code></a> and the Bzip2 library provided by <a href="https://github.com/JuliaBinaryWrappers/Bzip2_jll.jl"><code>Bzip2_jll.jl</code></a> respectively with <code>/usr/lib/libfontconfig.so</code> and <code>/usr/local/lib/libbz2.so</code> with the following <code>Overrides.toml</code>:</p><pre><code class="language-toml hljs">[a3f928ae-7b40-5064-980b-68af3947d34b]
Fontconfig = &quot;/usr&quot;

[6e34b625-4abd-537c-b88f-471c36dfa7a0]
Bzip2 = &quot;/usr/local&quot;</code></pre><p>Some comments about how to write this file:</p><ul><li>The UUIDs are those of the JLL packages, <code>a3f928ae-7b40-5064-980b-68af3947d34b</code> for <code>Fontconfig_jll.jl</code> and <code>6e34b625-4abd-537c-b88f-471c36dfa7a0</code> for <code>Bzip2_jll.jl</code>.  You can either find them in the <code>Project.toml</code> files of the packages (e.g., see <a href="https://github.com/JuliaBinaryWrappers/Fontconfig_jll.jl/blob/8904cd195ea4131b89cafd7042fd55e6d5dea241/Project.toml#L2">the <code>Project.toml</code> file of <code>Fontconfig_jll</code></a>) or look it up in the registry (e.g., see <a href="https://github.com/JuliaRegistries/General/blob/caddd31e7878276f6e052f998eac9f41cdf16b89/F/Fontconfig_jll/Package.toml#L2">the entry for <code>Fontconfig_jll</code> in the General registry</a>).</li><li>The artifacts provided by JLL packages have the same name as the packages, without the trailing <code>_jll</code>, <code>Fontconfig</code> and <code>Bzip2</code> in this case.</li><li>The artifact location is held in the <code>artifact_dir</code> variable mentioned above, which is the &quot;prefix&quot; of the installation of the package.  Recall the paths of the products in the JLL package is relative to <code>artifact_dir</code> and the files you want to use to override the products of the JLL package must have the same tree structure as the artifact.  In our example we need to use <code>/usr</code> to override Fontconfig and <code>/usr/local</code> for Bzip2.</li></ul><h3 id="Overriding-specific-products"><a class="docs-heading-anchor" href="#Overriding-specific-products">Overriding specific products</a><a id="Overriding-specific-products-1"></a><a class="docs-heading-anchor-permalink" href="#Overriding-specific-products" title="Permalink"></a></h3><p>Instead of overriding the entire artifact, you can override a particular product (library, executable, or file) within a JLL using <a href="https://github.com/JuliaPackaging/Preferences.jl">Preferences.jl</a>.</p><div class="admonition is-compat"><header class="admonition-header">Compat</header><div class="admonition-body"><p>This section requires Julia 1.6 or later.</p></div></div><p>For example, to override our <code>libbz2</code> example:</p><pre><code class="language-julia hljs">using Preferences
set_preferences!(
    &quot;LocalPreferences.toml&quot;,
    &quot;Bzip2_jll&quot;,
    &quot;libbzip2_path&quot; =&gt; &quot;/usr/local/lib/libbz2.so&quot;,
)</code></pre><p>Note that the product name is <code>libbzip2</code>, but we use <code>libbzip2_path</code>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>There are two common cases where this will not work:</p><ol><li>The JLL is part of the <a href="https://github.com/JuliaLang/julia/tree/master/stdlib">Julia stdlib</a>, for example <code>Zlib_jll</code></li><li>The JLL has not been compiled with <a href="https://github.com/JuliaPackaging/JLLWrappers.jl">JLLWrappers.jl</a> as a dependency. In this case, it means that the last build of the JLL pre-dates the introduction of the JLLWrappers package and needs a fresh build. Please open an issue on <a href="https://github.com/JuliaPackaging/Yggdrasil/">Yggdrasil</a> requesting a new build, or make a pull request to update the relevant <code>build_tarballs.jl</code> script.</li></ol></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../build_tips/">« Build Tips</a><a class="docs-footer-nextpage" href="../FAQ/">FAQ »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Tuesday 8 February 2022 22:05">Tuesday 8 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
